{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Harry Xiong",
  "home_page_url": "https://harryxiong24.github.io/zh/",
  "feed_url": "https://harryxiong24.github.io/zh/feed.json",
  "description": "A piano player playing on the keyboard",
  "favicon": "https://harryxiong24.github.io/favicon.ico",
  "items": [
    {
      "title": "About Me",
      "url": "https://harryxiong24.github.io/zh/about-me/intro.html",
      "id": "https://harryxiong24.github.io/zh/about-me/intro.html",
      "summary": "Welcome 👋 你好！欢迎来访！ 🤟 自述 我是一名对软件开发有浓厚兴趣的 coder，尤其是在 Web 应用的开发和构建领域。 我在 Typescript 和 JavaScript 方面有不错的基础。 我曾经在字节跳动和腾讯工作，担任 Web 前端工程师。 另外，我不是一个只会沉迷于编码的男孩。 我有很多爱好，我相信享受属于我们自己的生活是世...",
      "content_html": "<h1> About Me</h1>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Welcome 👋</p>\n<p>你好！欢迎来访！</p>\n</div>\n<h3> 🤟 自述</h3>\n<p>我是一名对软件开发有浓厚兴趣的 coder，尤其是在 Web 应用的开发和构建领域。 我在 Typescript 和 JavaScript 方面有不错的基础。 我曾经在字节跳动和腾讯工作，担任 Web 前端工程师。 另外，我不是一个只会沉迷于编码的男孩。 我有很多爱好，我相信享受属于我们自己的生活是世界上最幸福的事情之一！</p>\n<h3> 🌟 座右铭</h3>\n<p>所有苦難與背負盡頭，都是行雲流水般的此世光陰。</p>\n<h3> 🌱 兴趣爱好</h3>\n<p>Coding &amp; Piano &amp; Reading &amp; 🏀 &amp;  🏊‍♂️ &amp; 🏸 &amp; 🚴‍♂️ &amp; 🎤 &amp; etc.</p>\n<h3> 📫 怎样联系我</h3>\n<p><a href=\"/zh/about-me/contact\">点击这里！</a></p>\n<h3> Plus</h3>\n<p><a href=\"/en/about-me/intro\">跳转到英文版本</a></p>\n",
      "date_published": "2023-06-20T00:00:00.000Z",
      "date_modified": "2023-06-19T09:15:20.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "联系我",
      "url": "https://harryxiong24.github.io/zh/about-me/contact.html",
      "id": "https://harryxiong24.github.io/zh/about-me/contact.html",
      "summary": "很期待认识你！ 应用名称 联系方式 :--: :--------- GitHub (https://github.com/HarryXiong24) Gmail (mailto:harryxiong24@gmail.com) Instagram (https://www.instagram.com/harryxiong24) Twitter (http...",
      "content_html": "<h1> 联系我</h1>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">很期待认识你！</p>\n</div>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">应用名称</th>\n<th style=\"text-align:left\">联系方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\"><a href=\"https://github.com/HarryXiong24\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\"><a href=\"mailto:harryxiong24@gmail.com\">Gmail</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\"><a href=\"https://www.instagram.com/harryxiong24\" target=\"_blank\" rel=\"noopener noreferrer\">Instagram</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\"><a href=\"https://twitter.com/HarryXiong24\" target=\"_blank\" rel=\"noopener noreferrer\">Twitter</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\"><a href=\"https://weibo.com/harryxiong24\" target=\"_blank\" rel=\"noopener noreferrer\">Weibo</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\"><a href=\"https://space.bilibili.com/381730331\" target=\"_blank\" rel=\"noopener noreferrer\">BiliBili</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\"><a href=\"https://www.linkedin.com/in/haowei-xiong-5a418827b/\" target=\"_blank\" rel=\"noopener noreferrer\">Linkedin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\"><a href=\"https://juejin.cn/user/1319894200641784\" target=\"_blank\" rel=\"noopener noreferrer\">Jue Jing</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">HarryXiong24</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">1291192015</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2023-06-20T00:00:00.000Z",
      "date_modified": "2023-06-19T09:15:20.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Web Backend",
      "url": "https://harryxiong24.github.io/zh/back-end/",
      "id": "https://harryxiong24.github.io/zh/back-end/",
      "content_html": "<h1> Web Backend</h1>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Web Frontend",
      "url": "https://harryxiong24.github.io/zh/front-end/",
      "id": "https://harryxiong24.github.io/zh/front-end/",
      "content_html": "<h1> Web Frontend</h1>\n",
      "date_published": "2020-06-03T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Markdown基本语法",
      "url": "https://harryxiong24.github.io/zh/markdown/markdown.html",
      "id": "https://harryxiong24.github.io/zh/markdown/markdown.html",
      "summary": "[[TOC]] 1. 标题 1.1 使用#号标记 1.2 使用=和-号标记一级和二级标题 效果如下： image-20200308191149927 2. 段落 2.1 字体 效果如下： 斜体文本 斜体文本 粗体文本 粗体文本 *粗斜体文本* *粗斜体文本* 注：一般加粗不要包括到标点符号 2.2 分割线 你可以在一行中用三个以上的星号、减号、底线来建...",
      "content_html": "<h1> Markdown基本语法</h1>\n\n<hr>\n<h2> 1. 标题</h2>\n<h3> 1.1 使用#号标记</h3>\n<div class=\"language-text\" data-ext=\"text\"></div><h3> 1.2 使用=和-号标记一级和二级标题</h3>\n<div class=\"language-text\" data-ext=\"text\"></div><p>效果如下：</p>\n<p></p>\n<h2> 2. 段落</h2>\n<h3> 2.1 字体</h3>\n<div class=\"language-chinese\" data-ext=\"chinese\"></div><p>效果如下：</p>\n<p><em>斜体文本</em>\n<em>斜体文本</em>\n<strong>粗体文本</strong>\n<strong>粗体文本</strong>\n<em><strong>粗斜体文本</strong></em>\n<em><strong>粗斜体文本</strong></em></p>\n<p>注：一般加粗不要包括到标点符号</p>\n<h3> 2.2 分割线</h3>\n<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><h3> 2.3 删除线</h3>\n<p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可，实例如下：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>效果如下：</p>\n<p>RUNOOB.COM\nGOOGLE.COM\n<s>BAIDU.COM</s></p>\n<h3> 2.4 下划线</h3>\n<p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code>标签来实现：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>效果如下：</p>\n<p><u>带下划线文本</u></p>\n<h3> 2.5 注脚</h3>\n<p>脚注是对文本的补充说明。</p>\n<p>Markdown 脚注的格式如下:</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>以下实例演示了脚注的用法：</p>\n<p>Markdown <sup class=\"footnote-ref\"><a href=\"#footnote1\">[1]</a><a class=\"footnote-anchor\" id=\"footnote-ref1\"></a></sup></p><a class=\"footnote-anchor\" id=\"footnote-ref1\">\n</a><h2><a class=\"footnote-anchor\" id=\"footnote-ref1\"></a> 3. 列表</h2>\n<h3> 3.1 无序列表</h3>\n<p>无序列表使用星号(<em><strong><strong>)、加号(</strong>+</strong>)或是减号(</em><em>-</em>*)作为列表标记：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>效果如下：</p>\n<ul>\n<li>\n<p>第一项</p>\n</li>\n<li>\n<p>第二项</p>\n</li>\n<li>\n<p>第三项</p>\n</li>\n<li>\n<p>第一项</p>\n</li>\n<li>\n<p>第二项</p>\n</li>\n<li>\n<p>第三项</p>\n</li>\n<li>\n<p>第一项</p>\n</li>\n<li>\n<p>第二项</p>\n</li>\n<li>\n<p>第三项</p>\n</li>\n</ul>\n<h3> 3.2 有序列表</h3>\n<p>有序列表使用数字并加上 <strong>.</strong> 号来表示，如：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><ol>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ol>\n<h3> 3.3 列表嵌套</h3>\n<p>列表嵌套只需在子列表中的选项添加四个空格即可：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>效果如下：</p>\n<ol>\n<li>第一项：\n<ul>\n<li>第一项嵌套的第一个元素</li>\n<li>第一项嵌套的第二个元素</li>\n</ul>\n</li>\n<li>第二项：\n<ul>\n<li>第二项嵌套的第一个元素</li>\n<li>第二项嵌套的第二个元素</li>\n</ul>\n</li>\n</ol>\n<h2> 4. 区块引用</h2>\n<h3> 4.1 引用</h3>\n<p>Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><blockquote>\n<p>区块引用\n菜鸟教程\n学的不仅是技术更是梦想</p>\n</blockquote>\n<p>另外区块是可以嵌套的，一个 <strong>&gt;</strong> 符号是最外层，两个 <strong>&gt;</strong> 符号是第一层嵌套，以此类推：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><blockquote>\n<p>最外层</p>\n<blockquote>\n<p>第一层嵌套</p>\n<blockquote>\n<p>第二层嵌套</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3> 4.2  区块中使用列表</h3>\n<p>区块中使用列表实例如下：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>显示结果如下：</p>\n<blockquote>\n<p>区块中使用列表</p>\n<ol>\n<li>第一项</li>\n<li>第二项</li>\n</ol>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n</blockquote>\n<h3> 4.3 列表中使用区块</h3>\n<p>如果要在列表项目内放进区块，那么就需要在 <strong>&gt;</strong> 前添加四个空格的缩进。</p>\n<p>区块中使用列表实例如下：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>显示结果如下：</p>\n<ul>\n<li>第一项\n<blockquote>\n<p>菜鸟教程\n学的不仅是技术更是梦想</p>\n</blockquote>\n</li>\n<li>第二项</li>\n</ul>\n<h2> 5. 功能块</h2>\n<h3> 5.1 代码块</h3>\n<p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（<strong>`</strong>），例如：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>显示结果如下：</p>\n<p><code>printf()</code> 函数</p>\n<p>代码区块使用 <strong>```</strong> 包裹一段代码，并指定一种语言（也可以不指定）：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>显示结果如下：</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 5.2 公式块</h3>\n<p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><h2> 6. 链接</h2>\n<p>链接使用方法如下：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>例如：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>显示结果如下：</p>\n<p>这是一个链接 <a href=\"https://www.google.com\" target=\"_blank\" rel=\"noopener noreferrer\">Google</a></p>\n<p>链接也可以用变量来代替，文档末尾附带变量地址：</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>显示结果如下：\n这个链接用 1 作为网址变量 <a href=\"http://www.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Google</a></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"footnote1\" class=\"footnote-item\"><p>It is really easy! <a href=\"#footnote-ref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2020-06-11T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Markdown"
      ]
    },
    {
      "title": "Git",
      "url": "https://harryxiong24.github.io/zh/git/",
      "id": "https://harryxiong24.github.io/zh/git/",
      "summary": "Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。在开发中分布式文件管理系统，可以便于多人协作开发。 Git 安装 安装教程 (install.md); Git 教程 Git 总体介绍 (whatIsGit.md); 创建版本库 (createRepository.md); 纵向查看 (statusView.md); 版本回...",
      "content_html": "<h1> Git</h1>\n<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。在开发中分布式文件管理系统，可以便于多人协作开发。</p>\n<h2> Git 安装</h2>\n<ul>\n<li><a href=\"/zh/git/install.html\" target=\"blank\">安装教程</a></li>\n</ul>\n<h2> Git 教程</h2>\n<ul>\n<li>\n<p><a href=\"/zh/git/whatIsGit.html\" target=\"blank\">Git 总体介绍</a></p>\n</li>\n<li>\n<p><a href=\"/zh/git/createRepository.html\" target=\"blank\">创建版本库</a></p>\n</li>\n<li>\n<p><a href=\"/zh/git/statusView.html\" target=\"blank\">纵向查看</a></p>\n</li>\n<li>\n<p><a href=\"/zh/git/backRoll.html\" target=\"blank\">版本回退</a></p>\n</li>\n<li>\n<p><a href=\"/zh/git/workingDirectory.html\" target=\"blank\">工作区和暂存区</a></p>\n</li>\n<li>\n<p><a href=\"/zh/git/change.html\" target=\"blank\">修改管理</a></p>\n</li>\n<li>\n<p><a href=\"/zh/git/remote.html\" target=\"blank\">远程仓库</a></p>\n</li>\n<li>\n<p><a href=\"/zh/git/branch.html\" target=\"blank\">分支管理</a></p>\n</li>\n<li>\n<p><a href=\"/zh/git/tag.html\" target=\"blank\">标签管理</a></p>\n</li>\n<li>\n<p><a href=\"/zh/git/customGit.html\" target=\"blank\">自定义 Git</a></p>\n</li>\n<li>\n<p><a href=\"/zh/git/gitLFS.html\" target=\"blank\">大文件管理存储</a></p>\n</li>\n</ul>\n<h2> 在线教程</h2>\n<ul>\n<li><a href=\"https://www.runoob.com/git/git-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a></li>\n</ul>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "版本回退",
      "url": "https://harryxiong24.github.io/zh/git/backRoll.html",
      "id": "https://harryxiong24.github.io/zh/git/backRoll.html",
      "summary": "修改 readme.txt 文件如下: 然后尝试提交: 像这样不断对文件进行修改，然后不断提交修改到版本库里，每当文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在 Git 中被称为 commit。如果把文件改乱了，或者误删了文件，还可以从最近的一个 commit 恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 现在，我们回顾一下 r...",
      "content_html": "<h1> 版本回退</h1>\n<p>修改 readme.txt 文件如下:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>然后尝试提交:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>像这样不断对文件进行修改，然后不断提交修改到版本库里，每当文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在 Git 中被称为 <code>commit</code>。如果把文件改乱了，或者误删了文件，还可以从最近的一个 <code>commit</code> 恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>\n<p>现在，我们回顾一下 <code>readme.txt</code> 文件一共有几个版本被提交到 Git 仓库里了:</p>\n<ul>\n<li>版本 1: wrote a readme file</li>\n</ul>\n<div class=\"language-markdown\" data-ext=\"md\"></div><ul>\n<li>版本 2: add distributed</li>\n</ul>\n<div class=\"language-markdown\" data-ext=\"md\"></div><ul>\n<li>版本 3: append GPL</li>\n</ul>\n<div class=\"language-markdown\" data-ext=\"md\"></div><h2> 查看版本信息</h2>\n<p>版本控制系统用 <code>git log</code> 命令可以告诉我们历史记录，在 Git 中，我们查看:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>git log</code> 命令显示从最近到最远的提交日志，我们可以看到 3 次提交，最近的一次是 <code>append GPL</code>，上一次是 <code>add distributed</code>，最早的一次是 <code>wrote a readme file</code>。</p>\n<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 <code>--pretty=oneline</code> 参数:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>一大串类似 <code>1094adb...</code> 的是 <code>commit id</code> (版本号)，和 SVN 不一样，Git 的 commit id 不是 1，2，3…… 递增的数字，而是一个 SHA1 计算出来的一个非常大的数字，用十六进制表示，为什么 commit id 需要用这么一大串数字表示呢？因为 Git 是分布式的版本控制系统，多人在同一个版本库里工作，如果大家都用 1，2，3…… 作为版本号，那肯定就冲突了。</p>\n<p>每提交一个新版本，实际上 Git 就会把它们自动串成一条时间线。如果使用可视化工具查看 Git 历史，就可以更清楚地看到提交历史的时间线:</p>\n<p></p>\n<h2> 回退版本</h2>\n<p>好了，现在准备把 readme.txt 回退到上一个版本，也就是 <code>add distributed</code> 的那个版本，怎么做呢？</p>\n<p>首先，Git 必须知道当前版本是哪个版本，在 Git 中，用<code>HEAD</code>表示当前版本，也就是最新的提交 <code>1094adb...</code> (注意我的提交 ID 和您的肯定不一样)，上一个版本就是 <code>HEAD^</code>，上上一个版本就是 <code>HEAD^^</code>，当然往上 100 个版本写 100 个 <code>^</code> 比较容易数不过来，所以写成 <code>HEAD~100</code>。</p>\n<p>现在，要把当前版本 <code>append GPL</code> 回退到上一个版本 <code>add distributed</code>，就可以使用 <code>git reset</code> 命令:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>看看 readme.txt 的内容是不是版本 add distributed:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>果然被还原了。</p>\n<p>还可以继续回退到上一个版本 wrote a readme file，不过且慢，然我们用 <code>git log</code> 再看看现在版本库的状态:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最新的那个版本 append GPL 已经看不到了！肿么办？</p>\n<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，您就可以顺着往上找啊找啊，找到那个 append GPL 的 commit id 是 1094adb...，于是就可以指定回到未来的某个版本:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>版本号没必要写全，前几位就可以了，Git 会自动去找。当然也不能只写前一两位，因为 Git 可能会找到多个版本号，就无法确定是哪一个了。</p>\n<p>再小心翼翼地看看 readme.txt 的内容:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>果然，我胡汉三又回来了。</p>\n<p>Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 <code>HEAD</code> 指针，当您回退版本的时候，Git 仅仅是把 <code>HEAD</code> 从指向 append GPL:</p>\n<p></p>\n<p>改为指向 <code>add distributed</code>:</p>\n<p></p>\n<p>然后顺便把工作区的文件更新了。所以您让 <code>HEAD</code> 指向哪个版本号，您就把当前版本定位在哪。</p>\n<h2> 找回 commit id</h2>\n<p>如果回退到了某个版本找不到新版本的 <code>commit id</code>，在 Git 中，就无法用 <code>$ git reset --hard HEAD^</code> 回退。</p>\n<p>所以 Git 提供了一个命令 <code>git reflog</code> 用来记录您的每一次命令:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><div class=\"language-bash\" data-ext=\"sh\"></div><p>终于舒了口气，从输出可知，append GPL 的 commit id 是 1094adb，现在，您又可以乘坐时光机回到未来了。</p>\n<h2> 小结</h2>\n<ul>\n<li>\n<p><code>HEAD</code> 指向的版本就是当前版本，因此，Git 允许我们在版本的历史之间穿梭，使用命令 <code>git reset --hard commit_id</code>。</p>\n</li>\n<li>\n<p>用 <code>git log</code> 可以查看提交历史，以便确定要回退到哪个版本。</p>\n</li>\n<li>\n<p>用 <code>git reflog</code> 查看命令历史，以便确定要回到未来的哪个版本。</p>\n</li>\n</ul>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "分支管理",
      "url": "https://harryxiong24.github.io/zh/git/branch.html",
      "id": "https://harryxiong24.github.io/zh/git/branch.html",
      "summary": "概述 分支就是科幻电影里面的平行宇宙，当您正在电脑前努力学习 Git 的时候，另一个您正在另一个平行宇宙里努力学习 SVN。 如果两个平行宇宙互不干扰，那对现在的您也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，您既学会了 Git 又学会了 SVN！ learn-branches 分支在实际中有什么用呢？假设您准备开发一个新功能，但是需要两周...",
      "content_html": "<h1> 分支管理</h1>\n<h2> 概述</h2>\n<p>分支就是科幻电影里面的平行宇宙，当您正在电脑前努力学习 Git 的时候，另一个您正在另一个平行宇宙里努力学习 SVN。</p>\n<p>如果两个平行宇宙互不干扰，那对现在的您也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，您既学会了 Git 又学会了 SVN！</p>\n<p></p>\n<p>分支在实际中有什么用呢？假设您准备开发一个新功能，但是需要两周才能完成，第一周您写了 50% 的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>\n<p>现在有了分支，就不用怕了。您创建了一个属于您自己的分支，别人看不到，还继续在原来的分支上正常工作，而您在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>\n<p>其他版本控制系统如 SVN 等都有分支管理，但是用过之后您会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>\n<p>但 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成！无论您的版本库是 1 个文件还是 1 万个文件。</p>\n<hr>\n<h2> 创建与合并分支</h2>\n<p>在版本回退里，您已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即 <code>master</code> 分支。<code>HEAD</code> 严格来说不是指向提交，而是指向 <code>master</code>，<code>master</code> 才是指向提交的，所以，<code>HEAD</code> 指向的就是当前分支。</p>\n<p>一开始的时候，<code>master</code> 分支是一条线，Git 用 <code>master</code> 指向最新的提交，再用 <code>HEAD</code> 指向 <code>master</code>，就能确定当前分支，以及当前分支的提交点:</p>\n<p></p>\n<p>每次提交，<code>master</code> 分支都会向前移动一步，这样，随着您不断提交，<code>master</code> 分支的线也越来越长:</p>\n<p>当我们创建新的分支，例如 dev 时，Git 新建了一个指针叫 <code>dev</code>，指向 <code>master</code> 相同的提交，再把 <code>HEAD</code> 指向 <code>dev</code>，就表示当前分支在 dev 上:</p>\n<p></p>\n<p>您看，Git 创建一个分支很快，因为除了增加一个 <code>dev</code> 指针，改改 <code>HEAD</code> 的指向，工作区的文件都没有任何变化！</p>\n<p>不过，从现在开始，对工作区的修改和提交就是针对 dev 分支了，比如新提交一次后，<code>dev</code> 指针往前移动一步，而 <code>master</code> 指针不变:</p>\n<p></p>\n<p>假如我们在 dev 上的工作完成了，就可以把 dev 合并到 master 上。Git 怎么合并呢？最简单的方法，就是直接把 master 指向 dev 的当前提交，就完成了合并:</p>\n<p></p>\n<p>所以 Git 合并分支也很快！就改改指针，工作区内容也不变！</p>\n<p>合并完分支后，甚至可以删除 dev 分支。删除 dev 分支就是把 dev 指针给删掉，删掉后，我们就剩下了一条 master 分支:</p>\n<p></p>\n<p>下面开始实战。首先，我们创建 dev 分支，然后切换到 dev 分支:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p><code>git checkout</code> 命令加上 <code>-b</code> 参数表示创建并切换，相当于以下两条命令:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>然后，用<code>git branch</code>命令查看当前分支:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p><code>git branch</code> 命令会列出所有分支，当前分支前面会标一个 <code>*</code> 号。</p>\n<p>然后，我们就可以在 dev 分支上正常提交，比如对 <code>readme.txt</code> 做个修改，加上一行:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>然后提交:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>现在，dev 分支的工作完成，我们就可以切换回 master 分支:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>切换回 master 分支后，再查看一个 <code>readme.txt</code> 文件，刚才添加的内容不见了！因为那个提交是在 dev 分支上，而 master 分支此刻的提交点并没有变:</p>\n<p></p>\n<p>现在，我们把 dev 分支的工作成果合并到 master 分支上:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p><code>git merge</code> 命令用于合并指定分支到当前分支。合并后，再查看 readme.txt 的内容，就可以看到，和 dev 分支的最新提交是完全一样的。</p>\n<p>注意到上面的 <code>Fast-forward</code> 信息，Git 告诉我们，这次合并是 “快进模式”，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。当然，也不是每次合并都能 <code>Fast-forward</code>。合并完成后，就可以放心地删除 dev 分支了:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>删除后，查看 <code>branch</code>，就只剩下 <code>master</code> 分支了:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>因为创建、合并和删除分支非常快，所以 Git 鼓励您使用分支完成某个任务，合并后再删掉分支，这和直接在 <code>master</code> 分支上工作效果是一样的，但过程更安全。</p>\n<h3> 分支小结</h3>\n<ul>\n<li>\n<p>查看分支: <code>git branch</code></p>\n</li>\n<li>\n<p>创建分支: <code>git branch &lt;name&gt;</code></p>\n</li>\n<li>\n<p>切换分支: <code>git checkout &lt;name&gt;</code></p>\n</li>\n<li>\n<p>创建+切换分支: <code>git checkout -b &lt;name&gt;</code></p>\n</li>\n<li>\n<p>合并某分支到当前分支: <code>git merge &lt;name&gt;</code></p>\n</li>\n<li>\n<p>删除分支: <code>git branch -d &lt;name&gt;</code></p>\n</li>\n</ul>\n<hr>\n<h2> 冲突</h2>\n<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>\n<p>准备新的 <code>feature1</code> 分支，继续我们的新分支开发:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>修改 readme.txt 最后一行，改为:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>在 <code>feature1</code> 分支上提交:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>切换到 <code>master</code> 分支:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>Git 还会自动提示我们当前 <code>master</code> 分支比远程的 <code>master</code> 分支要超前 1 个提交。</p>\n<p>在 <code>master</code> 分支上把 readme.txt 文件的最后一行改为:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>提交:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>现在，<code>master</code> 分支和 <code>feature1</code> 分支各自都分别有新的提交，变成了这样:</p>\n<p></p>\n<p>这种情况下，Git 无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>果然冲突了！Git 告诉我们，<code>readme.txt</code> 文件存在冲突，必须手动解决冲突后再提交。<code>git status</code> 也可以告诉我们冲突的文件:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们可以直接查看 readme.txt 的内容:</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>Git 用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 标记出不同分支的内容，我们修改如下后保存:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>再提交:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>现在，<code>master</code> 分支和 <code>feature1</code> 分支变成了下图所示:</p>\n<p></p>\n<p>用带参数的 <code>git log</code> 也可以看到分支的合并情况:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后，删除 feature1 分支:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><h3> 冲突小结</h3>\n<ul>\n<li>\n<p>当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交。</p>\n</li>\n<li>\n<p>用 <code>git log --graph</code> 命令可以看到分支合并图。</p>\n</li>\n</ul>\n<hr>\n<h2> 分支管理策略</h2>\n<p>通常，合并分支时，如果可能，Git 会用 <code>Fast forward</code> 模式，但这种模式下，删除分支后，会丢掉分支信息。</p>\n<p>如果要强制禁用 <code>Fast forward</code> 模式，Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。</p>\n<p>实战一下 <code>--no-ff</code> 方式的 <code>git merge</code>。首先，仍然创建并切换 <code>dev</code> 分支:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>修改 readme.txt 文件，并提交一个新的 <code>commit</code>:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>现在，我们切换回 <code>master</code>:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>准备合并 <code>dev</code> 分支，请注意 <code>--no-ff</code> 参数，表示禁用 <code>Fast forward</code>:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>因为本次合并要创建一个新的 <code>commit</code>，所以加上 <code>-m</code> 参数，把 <code>commit</code> 描述写进去。</p>\n<p>合并后，我们用 <code>git log</code> 看看分支历史:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>可以看到，不使用 <code>Fast forward</code> 模式，<code>merge</code> 后就像这样:</p>\n<p></p>\n<h3> 分支管理惯例</h3>\n<p>在实际开发中，我们应该按照几个基本原则进行分支管理:</p>\n<p>首先，<code>master</code> 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>\n<p>那在哪干活呢？干活都在 <code>dev</code> 分支上，也就是说，<code>dev</code> 分支是不稳定的，到某个时候，比如 <code>1.0</code> 版本发布时，再把 <code>dev</code> 分支合并到 <code>master</code> 上，在<code>master</code> 分支发布 <code>1.0</code> 版本；</p>\n<p>您和您的小伙伴们每个人都在 <code>dev</code> 分支上干活，每个人都有自己的分支，时不时地往 <code>dev</code> 分支上合并就可以了。</p>\n<p>所以，团队合作的分支看起来就像这样:</p>\n<p></p>\n<h3> 分支管理小结</h3>\n<ul>\n<li>\n<p>Git 分支十分强大，在团队开发中应该充分应用。</p>\n</li>\n<li>\n<p>合并分支时，加上 <code>--no-ff</code> 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 <code>fast forward</code> 合并就看不出来曾经做过合并。</p>\n</li>\n</ul>\n<hr>\n<h2> Bug 分支</h2>\n<p>软件开发中，bug 就像家常便饭一样。有了 bug 就需要修复，在 Git 中，由于分支是如此的强大，所以，每个 bug 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>\n<p>当您接到一个修复一个代号 101 的 bug 的任务时，很自然地，您想创建一个分支 <code>issue-101</code> 来修复它，但是，等等，当前正在 dev 上进行的工作还没有提交:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>并不是您不想提交，而是工作只进行到一半，还没法提交，预计完成还需 1 天时间。但是，必须在两个小时内修复该 bug，怎么办？</p>\n<p>幸好，Git 还提供了一个 <code>stash</code> 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>现在，用 <code>git status</code> 查看工作区，就是干净的(除非有没有被 Git 管理的文件)，因此可以放心地创建分支来修复 bug。</p>\n<p>首先确定要在哪个分支上修复 bug，假定需要在 master 分支上修复，就从 master 创建临时分支:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>现在修复 bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>修复完成后，切换到 <code>master</code> 分支，并完成合并，最后删除 <code>issue-101</code> 分支:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>太棒了，原计划两个小时的 bug 修复只花了 5 分钟！现在，是时候接着回到 <code>dev</code> 分支干活了！</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>工作区是干净的，刚才的工作现场存到哪去了？用 <code>git stash list</code> 命令看看:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>工作现场还在，Git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法:</p>\n<p>一是用 <code>git stash apply</code> 恢复，但是恢复后，<code>stash</code> 内容并不删除，您需要用 <code>git stash drop</code> 来删除；</p>\n<p>另一种方式是用 <code>git stash pop</code>，恢复的同时把 <code>stash</code> 内容也删了:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再用 <code>git stash list</code> 查看，就看不到任何 stash 内容了。您可以多次 stash，恢复的时候，先用 <code>git stash list</code> 查看，然后恢复指定的 stash，用命令:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><h3> 暂存小结</h3>\n<ul>\n<li>\n<p>修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；</p>\n</li>\n<li>\n<p>当手头工作没有完成时，先把工作现场 <code>git stash</code> 一下，然后去修复 bug，修复后，再 <code>git stash pop</code>，回到工作现场。</p>\n</li>\n</ul>\n<hr>\n<h2> Feature 分支</h2>\n<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>\n<p>添加一个新功能时，您肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个 <code>feature</code> 分支，在上面开发，完成后，合并，最后，删除该 <code>feature</code> 分支。</p>\n<p>现在，您终于接到了一个新任务: 开发代号为 <code>Vulcan</code> 的新功能，该功能计划用于下一代星际飞船。</p>\n<p>于是准备开发:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>5 分钟后，开发完毕:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>切回 <code>dev</code>，准备合并:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>一切顺利的话，feature 分支和 bug 分支是类似的，合并，然后删除。</p>\n<p>但是！</p>\n<p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p>\n<p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>销毁失败。Git 友情提醒，feature-vulcan 分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的 <code>-D</code> 参数。。</p>\n<p>现在我们强行删除:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>终于删除成功！</p>\n<h3> 删除小结</h3>\n<ul>\n<li>\n<p>开发一个新 feature，最好新建一个分支；</p>\n</li>\n<li>\n<p>如果要丢弃一个没有被合并过的分支，可以通过 <code>git branch -D &lt;name&gt;</code> 强行删除。</p>\n</li>\n</ul>\n<hr>\n<h2> 多人协作</h2>\n<p>当您从远程仓库克隆时，实际上 Git 自动把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支对应起来了，并且，远程仓库的默认名称是 <code>origin</code>。</p>\n<p>要查看远程库的信息，用 <code>git remote</code>:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>或者，用 <code>git remote -v</code> 显示更详细的信息:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>上面显示了可以抓取和推送的 <code>origin</code> 的地址。如果没有推送权限，就看不到 push 的地址。</p>\n<h3> 推送分支</h3>\n<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>如果要推送其他分支，比如 <code>dev</code>，就改成:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>\n<p><code>master</code> 分支是主分支，因此要时刻与远程同步；</p>\n<p><code>dev</code> 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>\n<p><code>bug</code> 分支只用于在本地修复 bug，就没必要推到远程了，除非老板要看看您每周到底修复了几个 bug；</p>\n<p><code>feature</code> 分支是否推到远程，取决于您是否和您的小伙伴合作在上面开发。</p>\n<p>总之，就是在 Git 中，分支完全可以在本地自己藏着玩，是否推送，视您的心情而定！</p>\n<h3> 抓取分支</h3>\n<p>多人协作时，大家都会往 <code>master</code> 和 <code>dev</code> 分支上推送各自的修改。</p>\n<p>现在，模拟一个您的小伙伴，可以在另一台电脑 (注意要把 SSH Key 添加到 Github) 或者同一台电脑的另一个目录下克隆:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>当您的小伙伴从远程库 clone 时，默认情况下，您的小伙伴只能看到本地的 <code>master</code> 分支。不信可以用 <code>git branch</code> 命令看看:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>现在，您的小伙伴要在 <code>dev</code> 分支上开发，就必须创建远程 <code>origin</code> 的 <code>dev</code> 分支到本地，于是他用这个命令创建本地 <code>dev</code> 分支:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>现在，他就可以在 <code>dev</code> 上继续修改，然后，时不时地把 <code>dev</code> 分支 push 到远程:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>您的小伙伴已经向 <code>origin/dev</code> 分支推送了他的提交，而碰巧您也对同样的文件作了修改，并试图推送:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>推送失败，因为您的小伙伴的最新提交和您试图推送的提交有冲突，解决办法也很简单，Git 已经提示我们，先用 <code>git pull</code> 把最新的提交从 <code>origin/dev</code> 抓下来，然后，在本地合并，解决冲突，再推送:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>git pull</code> 也失败了，原因是没有指定本地 <code>dev</code> 分支与远程 <code>origin/dev</code> 分支的链接，根据提示，设置 <code>dev</code> 和 <code>origin/dev</code> 的链接:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>再 pull:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>这回 <code>git pull</code> 成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再 push:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因此，多人协作的工作模式通常是这样:</p>\n<p>首先，可以试图用 <code>git push origin &lt;branch-name&gt;</code> 推送自己的修改；</p>\n<p>如果推送失败，则因为远程分支比您的本地更新，需要先用 <code>git pull</code> 试图合并；</p>\n<p>如果合并有冲突，则解决冲突，并在本地提交；</p>\n<p>没有冲突或者解决掉冲突后，再用 <code>git push origin &lt;branch-name&gt;</code> 推送就能成功！</p>\n<p>如果 <code>git pull</code> 提示 <code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令 <code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>\n<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>\n<h3> 多人协作小结</h3>\n<ul>\n<li>\n<p>查看远程库信息，使用 <code>git remote -v</code>；</p>\n</li>\n<li>\n<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>\n</li>\n<li>\n<p>从本地推送分支，使用 <code>git push origin branch-name</code>，如果推送失败，先用 <code>git pull</code> 抓取远程的新提交；</p>\n</li>\n<li>\n<p>在本地创建和远程分支对应的分支，使用 <code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>\n</li>\n<li>\n<p>建立本地分支和远程分支的关联，使用 <code>git branch --set-upstream branch-name origin/branch-name</code>；</p>\n</li>\n<li>\n<p>从远程抓取分支，使用 <code>git pull</code>，如果有冲突，要先处理冲突。</p>\n</li>\n</ul>\n<hr>\n<h2> Rebase</h2>\n<p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后 <code>push</code> 的童鞋不得不先 <code>pull</code>，在本地合并，然后才能 <code>push</code> 成功。</p>\n<p>每次合并再 <code>push</code> 后，分支变成了这样:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>总之看上去很乱，有强迫症的童鞋会问: 为什么 Git 的提交历史不能是一条干净的直线？其实是可以做到的！</p>\n<p>Git 有一种称为 <code>rebase</code> 的操作，有人把它翻译成“变基”。</p>\n<p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p>\n<p>在和远程分支同步后，我们对 <code>hello.py</code> 这个文件做了两次提交。用 <code>git log</code> 命令看看:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意到 Git 用 <code>(HEAD -&gt; master)</code> 和 <code>(origin/master)</code> 标识出当前分支的 <code>HEAD</code> 和远程 <code>origin</code> 的位置分别是 <code>582d922 add author</code> 和 <code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p>\n<p>现在我们尝试推送本地分支:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先 pull 一下:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再用 <code>git status</code> 看看状态:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>加上刚才合并的提交，现在我们本地分支比远程分支超前 3 个提交。</p>\n<p>用 <code>git log</code> 看看:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支 <code>push</code> 到远程，有没有问题？</p>\n<p>有！</p>\n<p>什么问题？</p>\n<p>不好看！</p>\n<p>有没有解决方法？</p>\n<p>有！</p>\n<p>这个时候，rebase 就派上了用场。我们输入命令 <code>git rebase</code> 试试:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出了一大堆操作，到底是啥效果？再用 <code>git log</code> 看看:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现 Git 把我们本地的提交“挪动”了位置，放到了 <code>f005ed4 (origin/master) set exit=1</code> 之后，这样，整个提交历史就成了一条直线。rebase 操作前后，最终的提交内容是一致的，但是，我们本地的 commit 修改内容已经变化了，它们的修改不再基于 <code>d1be385 init hello</code>，而是基于 <code>f005ed4 (origin/master) set exit=1</code>，但最后的提交 <code>7e61ed4</code> 内容是一致的。</p>\n<p>这就是 <code>rebase</code> 操作的特点: 把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>\n<p>最后，通过 <code>push</code> 操作把本地分支推送到远程:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>再用 <code>git log</code> 看看效果:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>远程分支的提交历史也是一条直线。</p>\n<h2> Rebase 小结</h2>\n<ul>\n<li>\n<p><code>rebase</code> 操作可以把本地未 <code>push</code> 的分叉提交历史整理成直线；</p>\n</li>\n<li>\n<p><code>rebase</code> 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>\n</li>\n</ul>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "修改管理",
      "url": "https://harryxiong24.github.io/zh/git/change.html",
      "id": "https://harryxiong24.github.io/zh/git/change.html",
      "summary": "管理修改 Git 比其他版本控制系统设计得优秀，因为 Git 跟踪并管理的是修改，而非文件。 您会问，什么是修改？比如您新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 为什么说 Git 管理的是修改，而不是文件呢？我们还是做实验。第一步，对 rea...",
      "content_html": "<h1> 修改管理</h1>\n<h2> 管理修改</h2>\n<p>Git 比其他版本控制系统设计得优秀，因为 Git 跟踪并管理的是修改，而非文件。</p>\n<p>您会问，什么是修改？比如您新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>\n<p>为什么说 Git 管理的是修改，而不是文件呢？我们还是做实验。第一步，对 readme.txt 做一个修改，比如加一行内容:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>然后，添加:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>然后，再修改 readme.txt:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>提交:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>提交后，再看看状态:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>怎么第二次的修改没有被提交？我们回顾一下操作过程:</p>\n<p>第一次修改 → <code>git add</code> → 第二次修改 → <code>git commit</code></p>\n<p>您看，我们前面讲了，Git 管理的是修改，当您用 <code>git add</code> 命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>\n<p>提交后，用 <code>git diff HEAD -- readme.txt</code> 命令可以查看工作区和版本库里面最新版本的区别:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可见，第二次修改确实没有被提交。</p>\n<p>那怎么提交第二次修改呢？您可以继续 <code>git add</code> 再 <code>git commit</code>，也可以别着急提交第一次修改，先 <code>git add</code> 第二次修改，再 <code>git commit</code>，就相当于把两次修改合并后一块提交了:</p>\n<p>第一次修改 → <code>git add</code> → 第二次修改 → <code>git add</code> → <code>git commit</code></p>\n<p>好，现在，把第二次修改提交了，然后开始小结。</p>\n<h3> 管理小结</h3>\n<p>现在，您又理解了 Git 是如何跟踪修改的，每次修改，如果不用 <code>git add</code> 到暂存区，那就不会加入到 <code>commit</code> 中。</p>\n<hr>\n<h2> 撤销修改</h2>\n<p>自然，您是不会犯错的。不过现在是凌晨两点，您正在赶一份工作报告，您在 readme.txt 中添加了一行:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>在您准备提交前，一杯咖啡起了作用，您猛然发现了 <code>'stupid boss'</code> 可能会让您丢掉这个月的奖金！</p>\n<p>既然错误发现得很及时，就可以很容易地纠正它。您可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用 <code>git status</code> 查看一下:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>您可以发现，Git 会告诉您，<code>git checkout -- &lt;file&gt;</code> 可以丢弃工作区的修改:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>命令 <code>git checkout -- readme.txt</code> 意思就是，把 readme.txt 文件在工作区的修改全部撤销，这里有两种情况:</p>\n<p>一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>\n<p>一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>\n<p>总之，就是让这个文件回到最近一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p>\n<p>现在，看看 readme.txt 的文件内容:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>文件内容果然复原了。</p>\n<p><code>git checkout -- file</code> 命令中的 <code>--</code> 很重要，没有 <code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到 <code>git checkout</code> 命令。</p>\n<p>现在假定是凌晨 3 点，您不但写了一些胡话，还 <code>git add</code> 到暂存区了:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>庆幸的是，在 <code>commit</code> 之前，您发现了这个问题。用 <code>git status</code> 查看一下，修改只是添加到了暂存区，还没有提交:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>Git 同样告诉我们，用命令 <code>git reset HEAD &lt;file&gt;</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p><code>git reset</code> 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用 <code>HEAD</code> 时，表示当前的指针(最新的版本)。</p>\n<p>再用 <code>git status</code> 查看一下，现在暂存区是干净的，工作区有修改:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>还记得如何丢弃工作区的修改吗？</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>整个世界终于清静了！</p>\n<p>现在，假设您不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是您还没有把自己的本地版本库推送到远程。还记得 Git 是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦您把 <code>stupid boss</code> 提交推送到远程版本库，您就真的惨了……</p>\n<h3> 撤销小结</h3>\n<p>场景 1: 当您改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <code>git checkout -- file</code>。</p>\n<p>场景 2: 当您不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <code>git reset HEAD &lt;file&gt;</code>，就回到了场景 1，第二步按场景 1 操作。</p>\n<p>场景 3: 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>\n<hr>\n<h2> 删除文件</h2>\n<h3> 如何删除文件</h3>\n<p>在 Git 中，删除也是一个修改操作，我们实战一下，先添加一个新文件 test.txt 到 Git 并且提交:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>一般情况下，您通常直接在文件管理器中把没用的文件删了，或者用 <code>rm</code> 命令删了:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>这个时候，Git 知道您删除了文件，因此，工作区和版本库就不一致了，<code>git status</code> 命令会立刻告诉您哪些文件被删除了:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>现在您有两个选择，一是确实要从版本库中删除该文件，那就用命令 <code>git rm</code> 删掉，并且 <code>git commit</code>:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>现在，文件就从版本库中被删除了。</p>\n<h3> 撤销删除</h3>\n<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p><code>git checkout</code> 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>\n<h3> 删除小结</h3>\n<p>命令 <code>git rm</code> 用于删除一个文件。如果一个文件已经被提交到版本库，那么您永远不用担心误删，但是要小心，您只能恢复文件到最新版本，您会丢失最近一次提交后您修改的内容。</p>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "Git 版本库",
      "url": "https://harryxiong24.github.io/zh/git/createRepository.html",
      "id": "https://harryxiong24.github.io/zh/git/createRepository.html",
      "summary": "什么是版本库呢？版本库又名仓库，英文名repository，您可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除， Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 初始化版本库 创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录: pwd 命令用于显示当前目录。 ...",
      "content_html": "<h1> Git 版本库</h1>\n<p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，您可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除， Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>\n<h2> 初始化版本库</h2>\n<p>创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p><code>pwd</code> 命令用于显示当前目录。</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>使用 Windows 系统时，为了避免遇到各种莫名其妙的问题，请确保目录名(包括父目录)不包含中文。</p>\n</div>\n<p>第二步，通过 <code>git init</code> 命令把这个目录变成 Git 可以管理的仓库:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>瞬间 Git 就把仓库建好了，而且告诉您是一个空的仓库(empty Git repository)，可以发现当前目录下多了一个.git 的目录，这个目录是 Git 来跟踪管理版本库的，如果这个目录里面的文件破坏了，Git 仓库也破坏了。</p>\n<p>如果您没有看到.git 目录，那是因为这个目录默认是隐藏的，用 ls -ah 命令就可以看见。</p>\n<p>也不一定必须在空目录下创建 Git 仓库，选择一个已经有东西的目录也是可以的。</p>\n<div class=\"hint-container danger\">\n<p class=\"hint-container-title\">警告</p>\n<p>请不要用已经在使用的项目练习 git！</p>\n</div>\n<h2> 把文件添加到版本库</h2>\n<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如 TXT 文件，网页，所有的程序代码等等，Git 也不例外。版本控制系统可以告诉您每次的改动，比如在第 5 行加了一个单词“Linux”，在第 8 行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB，但到底改了啥，版本控制系统不知道，也没法知道。(Microsoft 的 Word 格式是二进制格式，所以很不幸) 所以要使用版本控制系统，就要以纯文本方式编写文件。</p>\n<p>因为文本是有编码的，比如中文有常用的 GBK 编码，日文有 Shift_JIS 编码，如果没有历史遗留问题，强烈建议使用标准的 UTF-8 编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。原因是 Microsoft 开发记事本的团队使用了一个非常弱智的行为来保存 UTF-8 编码的文件，他们自作聪明地在每个文件开头添加了 0xefbbbf(十六进制)的字符，您会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。</p>\n</div>\n<p>现在编写一个 readme.txt 文件，内容如下:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>一定要放到 <code>learngit</code> 目录下(子目录也行)，因为这是一个 Git 仓库，放到其他地方 Git 再厉害也找不到这个文件。</p>\n<p><strong>把一个文件放到 Git 仓库只需要两步。</strong></p>\n<p>第一步，用命令 <code>git add</code> 告诉 Git，把文件添加到仓库:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>执行上面的命令，没有任何显示，这就对了，Unix 的哲学是“没有消息就是好消息”，说明添加成功。</p>\n<p>第二步，用命令 git commit 告诉 Git，把文件提交到仓库:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p><code>git commit</code> 命令，<code>-m</code> 后面输入的是本次提交的说明，这样您就能从历史记录里方便地找到改动记录。</p>\n<p><code>git commit</code> 命令执行成功后会告诉您，<code>1 file changed</code>: 1 个文件被改动(我们新添加的 readme.txt 文件)；<code>2 insertions</code>: 插入了两行内容(readme.txt 有两行内容)。</p>\n<p>为什么 Git 添加文件需要 <code>add</code>，<code>commit</code> 一共两步呢？因为 <code>commit</code> 可以一次提交很多文件，所以您可以多次 <code>add</code> 不同的文件，比如:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><h2> 小结</h2>\n<ul>\n<li>\n<p>初始化一个 Git 仓库，使用 <code>git init</code> 命令。</p>\n</li>\n<li>\n<p>添加文件到 Git 仓库，分两步:</p>\n<ol>\n<li>使用命令 <code>git add &lt;file&gt;</code>，可反复多次使用，添加多个文件；</li>\n<li>使用命令 <code>git commit -m &lt;message&gt;</code>，完成。</li>\n</ol>\n</li>\n</ul>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "自定义 Git",
      "url": "https://harryxiong24.github.io/zh/git/customGit.html",
      "id": "https://harryxiong24.github.io/zh/git/customGit.html",
      "summary": "在安装 Git 一节中，我们已经配置了user.name和`user.email，实际上，Git 还有很多可配置项。 比如，让 Git 显示颜色，会让命令输出看起来更醒目: 这样，Git 会适当地显示不同的颜色，比如git status命令，文件名就会标上颜色。 忽略特殊文件 有些时候，您必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保...",
      "content_html": "<h1> 自定义 Git</h1>\n<p>在安装 Git 一节中，我们已经配置了<code>user.name</code>和<code>user.email</code>，实际上，Git 还有很多可配置项。</p>\n<p>比如，让 Git 显示颜色，会让命令输出看起来更醒目:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>这样，Git 会适当地显示不同的颜色，比如<code>git status</code>命令，文件名就会标上颜色。</p>\n<h2> 忽略特殊文件</h2>\n<p>有些时候，您必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files</code> ...，有强迫症的童鞋心里肯定不爽。</p>\n<p>好在 Git 考虑到了大家的感受，这个问题解决起来也很简单，在 Git 工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。</p>\n<ul>\n<li><a href=\"https://git-scm.com/docs/gitignore\" target=\"_blank\" rel=\"noopener noreferrer\">gitignore 配置规则</a></li>\n</ul>\n<p>忽略文件的原则是:</p>\n<p>忽略操作系统自动生成的文件，比如缩略图等；\n忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的<code>.class</code>文件；\n忽略您自己的带有敏感信息的配置文件，比如存放口令的配置文件。\n举个例子:</p>\n<p>假设您在 Windows 下进行 Python 开发，Windows 会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有<code>Desktop.ini</code>文件，因此您需要忽略 Windows 自动生成的垃圾文件:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>然后，继续忽略 Python 编译产生的<code>.pyc</code>、<code>.pyo</code>、<code>dist</code>等文件或目录:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>加上您自己定义的文件，最终得到一个完整的<code>.gitignore</code>文件，内容如下:</p>\n<div class=\"language-markdown line-numbers-mode\" data-ext=\"md\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后一步就是把.gitignore 也提交到 Git，就完成了！当然检验.gitignore 的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p>\n<p>使用 Windows 的童鞋注意了，如果您在资源管理器里新建一个<code>.gitignore</code>文件，它会非常弱智地提示您必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p>\n<p>有些时候，您想添加一个文件到 Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>如果您确实想添加该文件，可以用<code>-f</code>强制添加到 Git:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>或者您发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>Git 会告诉我们，<code>.gitignore</code>的第 3 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>\n<h3> gitignore 小结</h3>\n<ul>\n<li>\n<p>忽略某些文件时，需要编写<code>.gitignore</code>；</p>\n</li>\n<li>\n<p><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</p>\n</li>\n</ul>\n<h2> 配置别名</h2>\n<p>有没有经常敲错命令？比如<code>git status</code>？<code>status</code>这个单词真心不好记。</p>\n<p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>\n<p>我们只需要敲一行命令，告诉 Git，以后<code>st</code>就表示<code>status</code>:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>好了，现在敲<code>git st</code>看看效果。</p>\n<p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>以后提交就可以简写成:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。</p>\n<p>在撤销修改一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉(unstage)，重新放回工作区。既然是一个<code>unstage</code>操作，就可以配置一个<code>unstage</code>别名:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>当您敲入命令:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>实际上 Git 执行的是:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>配置一个<code>git last</code>，让其显示最后一次提交信息:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>这样，用<code>git last</code>就能显示最近一次的提交:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>甚至还有人丧心病狂地把<code>lg</code>配置成了:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>来看看<code>git lg</code>的效果:</p>\n<p></p>\n<p>为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！</p>\n<h2> 配置文件</h2>\n<p>配置 Git 的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>\n<p>配置文件放哪了？每个仓库的 Git 配置文件都放在<code>.git/config</code>文件中:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>\n<p>而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>\n<h3> 别名小结</h3>\n<ul>\n<li>给 Git 配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</li>\n</ul>\n<hr>\n<h2> 搭建 Git 服务器</h2>\n<p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了 7x24 小时开机并交换大家的修改。</p>\n<p>GitHub 就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给 GitHub 交保护费，那就只能自己搭建一台 Git 服务器作为私有仓库使用。</p>\n<p>搭建 Git 服务器需要准备一台运行 Linux 的机器，强烈推荐用 Ubuntu 或 Debian，这样，通过几条简单的 apt 命令就可以完成安装。</p>\n<p>假设您已经有 sudo 权限的用户账号，下面，正式开始安装。</p>\n<ul>\n<li>\n<p>第一步，安装 git:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div></li>\n<li>\n<p>第二步，创建一个 git 用户，用来运行 git 服务:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div></li>\n<li>\n<p>第三步，创建证书登录:</p>\n<p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p>\n</li>\n<li>\n<p>第四步，初始化 Git 仓库:</p>\n<p>先选定一个目录作为 Git 仓库，假定是/srv/sample.git，在/srv 目录下输入命令:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>Git 就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的 Git 仓库通常都以.git 结尾。然后，把 owner 改为 git:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div></li>\n<li>\n<p>第五步，禁用 shell 登录:</p>\n<p>出于安全考虑，第二步创建的 git 用户不允许登录 shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>改为:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>这样，git 用户可以正常通过 ssh 使用 git，但无法登录 shell，因为我们为 git 用户指定的 git-shell 每次一登录就自动退出。</p>\n</li>\n<li>\n<p>第六步，克隆远程仓库:</p>\n<p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>剩下的推送就简单了。</p>\n</li>\n</ul>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "Git Large File Storage",
      "url": "https://harryxiong24.github.io/zh/git/gitLFS.html",
      "id": "https://harryxiong24.github.io/zh/git/gitLFS.html",
      "summary": "Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remot...",
      "content_html": "<h1> Git Large File Storage</h1>\n<p>Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.</p>\n<h2> Getting Started</h2>\n<ol>\n<li>\n<p>Download and install the Git command line extension. Once downloaded and installed, set up Git LFS and its respective hooks by running:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>You'll need to run this in your repository directory, once per repository.</p>\n</li>\n<li>\n<p>Select the file types you'd like Git LFS to manage (or directly edit your .gitattributes). You can configure additional file extensions at anytime.</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>Make sure .gitattributes is tracked</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div></li>\n</ol>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "Git 安装与配置",
      "url": "https://harryxiong24.github.io/zh/git/install.html",
      "id": "https://harryxiong24.github.io/zh/git/install.html",
      "summary": "Git 下载 由于官网在国外，网速较慢，可以查看功能部群文件找到安装包下载安装。在安装 Git 前推荐安装好 VSCode。 官网下载 (https://git-scm.com/downloads/); Git 的安装 1. 点击 “next”。 gitinstall1 2. 按照图示勾选。 gitinstall2 3. 选择使用 VSCode 作为 ...",
      "content_html": "<h1> Git 安装与配置</h1>\n<h2> Git 下载</h2>\n<p>由于官网在国外，网速较慢，可以查看功能部群文件找到安装包下载安装。在安装 Git 前推荐安装好 VSCode。</p>\n<ul>\n<li><a href=\"https://git-scm.com/downloads/\" target=\"_blank\" rel=\"noopener noreferrer\">官网下载</a></li>\n</ul>\n<h2> Git 的安装</h2>\n<ol>\n<li>\n<p>点击 “next”。</p>\n<p></p>\n</li>\n<li>\n<p>按照图示勾选。</p>\n<p></p>\n</li>\n<li>\n<p>选择使用 VSCode 作为 git 的默认编辑器。</p>\n<p></p>\n</li>\n<li>\n<p>选择第二项。</p>\n<p></p>\n</li>\n<li>\n<p>选择默认选中的第一项。</p>\n<p></p>\n</li>\n<li>\n<p>选择最后一项，直接检查与提交换行。</p>\n<p></p>\n</li>\n<li>\n<p>选择第二项，使用 Windows 默认的控制台窗口。</p>\n<p></p>\n</li>\n<li>\n<p>勾选全部特性，开始安装。</p>\n<p></p>\n</li>\n</ol>\n<p>安装完成后，在开始菜单里找到 “Git” -&gt; “Git Bash” (Mac 上叫 Git Shell)，蹦出一个类似命令行窗口的东西，就说明 Git 安装成功！</p>\n<p></p>\n<h2> Git 的初次配置</h2>\n<ol>\n<li>\n<p>为配置配置用户名和密码。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>将上方的字符串换成您自己的名字和邮箱。</p>\n</li>\n<li>\n<p>创建 SSH Key。打开 Shell (Windows 下打开 cmd)，创建 SSH Key:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>您需要把邮件地址换成您自己的邮件地址，然后一路回车，使用默认值即可，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</p>\n<p>如果一切顺利的话，可以在用户主目录里找到.ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>\n</li>\n<li>\n<p>打开 <a href=\"https://github.com\" target=\"_blank\" rel=\"noopener noreferrer\">Github</a> 并选择 \"Sign in\" 注册自己的账号。</p>\n<p></p>\n<p>登陆 Github 后，点击右上角头像，进入设置。</p>\n<p>进入 \"安全设置\" 下的 \"SSH 公钥\" 界面。</p>\n<p></p>\n<p>在标题中填写公钥的备注名称，把 id_rsa.pub 文件的内容粘贴到底下的输入框中，设置一个自己可以记起的备注。</p>\n</li>\n</ol>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "远程仓库",
      "url": "https://harryxiong24.github.io/zh/git/remote.html",
      "id": "https://harryxiong24.github.io/zh/git/remote.html",
      "summary": "什么是远程仓库 Git 是分布式版本控制系统，同一个 Git 仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 实际情况往往是这样，找一台电脑充当服务器的角色，每天 24 小时开机，其他每个人都从这个“服务器”仓库克隆一份到自...",
      "content_html": "<h1> 远程仓库</h1>\n<h2> 什么是远程仓库</h2>\n<p>Git 是分布式版本控制系统，同一个 Git 仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>\n<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天 24 小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>\n<p>完全可以自己搭建一台运行 Git 的服务器，不过现阶段，为了学 Git 先搭个服务器绝对是小题大作。好在这个世界上有个叫 GitHub 的神奇的网站，从名字就可以看出，这个网站就是提供 Git 仓库托管服务的，所以，只要注册一个 GitHub 账号，就可以免费获得 Git 远程仓库。</p>\n<p>在继续阅读后续内容前，请自行注册 Github 账号。由于您的本地 Git 仓库和 Github 仓库之间的传输是通过 SSH 加密的，所以，需要一点设置:</p>\n<ul>\n<li>\n<p>第 1 步: 创建 SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开 Shell (Windows 下打开 Git Bash)，创建 SSH Key:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>您需要把邮件地址换成您自己的邮件地址，然后一路回车，使用默认值即可，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</p>\n<p>如果一切顺利的话，可以在用户主目录里找到.ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>\n</li>\n<li>\n<p>第 2 步: 登陆 Github，点击右上角头像，进入设置。</p>\n<p>进入安全设置下的 SSH 公钥界面。</p>\n<p>在标题中填写公钥的备注名称，把 id_rsa.pub 文件的内容粘贴到底下的输入框中。</p>\n</li>\n</ul>\n<p>为什么 Github 需要 SSH Key 呢？因为 Github 需要识别出您推送的提交确实是您推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以，Github 只要知道了您的公钥，就可以确认只有您自己才能推送。</p>\n<p>当然，Github 允许您添加多个 Key。假定您有若干电脑，您一会儿在公司提交，一会儿在家里提交，只要把每台电脑的 Key 都添加到 Github，就可以在每台电脑上往 Github 推送了。</p>\n<p>最后友情提示，在 Github 上免费托管的 Git 仓库，任何人都可以看到喔(但只有您自己才能改)。所以，不要把敏感信息放进去。</p>\n<p>如果您不想让别人看到 Git 库，一是让 Github 把公开的仓库变成私有的，这样别人就看不见了(不可读更不可写)。另一个办法是自己动手，搭一个 Git 服务器，因为是您自己的 Git 服务器，所以别人也是看不见的。</p>\n<p>确保您拥有一个 Github 账号后，我们就即将开始远程仓库的学习。</p>\n<h2> 添加远程库</h2>\n<p>现在的情景是，您已经在本地创建了一个 Git 仓库后，又想在 Github 创建一个 Git 仓库，并且让这两个仓库进行远程同步，这样，Github 上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>\n<p>首先，登陆 Github，然后，在右上角找到“+”按钮，点击 \"New Repository\"。</p>\n<p>在项目填入 learngit，其他保持默认设置，点击“创建”按钮，就成功地创建了一个新的 Git 仓库:</p>\n<p>目前，在 Github 上的这个 learngit 仓库还是空的，Github 告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 Github 仓库。</p>\n<p>现在，我们根据 Github 的提示，在本地的 learngit 仓库下运行命令:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>请千万注意，把上面的 nenuStudentUnion 替换成您自己的 Github 账户名，否则，您在本地关联的就是我的远程库，关联没有问题，但是推送是推不上去的，因为您的 SSH Key 公钥不在我的账户列表中。</p>\n<p>添加后，远程库的名字就是 <code>origin</code>，这是 Git 默认的叫法，也可以改成别的。</p>\n<p>下一步，就可以把本地库的所有内容推送到远程库上:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>把本地库的内容推送到远程，用 <code>git push</code> 命令，实际上是把当前分支 <code>master</code> 推送到远程。</p>\n<p>由于远程库是空的，我们第一次推送 <code>master</code> 分支时，加上了-u 参数，Git 不但会把本地的 <code>master</code> 分支内容推送的远程新的 <code>master</code> 分支，还会把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>\n<p>推送成功后，可以立刻在 Github 页面中看到远程库的内容已经和本地一模一样:</p>\n<p>从现在起，只要本地作了提交，就可以通过命令:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>把本地 <code>master</code> 分支的最新修改推送至 Github，现在，您就拥有了真正的分布式版本库！</p>\n<h2> SSH 警告</h2>\n<p>当您第一次使用 Git 的 clone 或者 push 命令连接 Github 时，会得到一个警告:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>这是因为 Git 使用 SSH 连接，而 SSH 连接在第一次验证 Github 服务器的 Key 时，需要您确认 Github 的 Key 的指纹信息是否真的来自 Github 的服务器，输入<code>yes</code>回车即可。</p>\n<p>Git 会输出一个警告，告诉您已经把 Github 的 Key 添加到本机的一个信任列表里了:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>\n<p>如果您实在担心有人冒充 Github 服务器，输入 yes 前可以对照 Github 的 RSA Key 的指纹信息是否与 SSH 连接给出的一致。</p>\n<h3> 关联小结</h3>\n<p>要关联一个远程库，使用命令 git remote add origin git@server-name:path/repo-name.git；</p>\n<p>关联后，使用命令 <code>git push -u origin master</code> 第一次推送 master 分支的所有内容；</p>\n<p>此后，每次本地提交后，只要有必要，就可以使用命令 <code>git push origin master</code> 推送最新修改；</p>\n<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>\n<h2> 从远程库克隆</h2>\n<p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>\n<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>\n<p>首先，登陆 Github，创建一个新的仓库，名字叫 <code>gitskills</code>:</p>\n<p>我们勾选使用 “readme 初始化项目”，这样 Github 会自动为我们创建一个 README.md 文件。创建完毕后，可以看到 README.md 文件。</p>\n<p>现在，远程库已经准备好了，下一步是用命令 <code>git clone</code> 克隆一个本地库:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>注意把 Git 库的地址换成您自己的，然后进入 <code>gitskills</code> 目录看看，已经有 README.md 文件了:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>\n<p>您也许还注意到，Github 给出的地址不止一个，还可以用 <a href=\"https://github.com/nenuyouth/gitskills.git\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/nenuyouth/gitskills.git</a> 这样的地址。实际上，Git 支持多种协议，默认的 <code>git://</code> 使用 ssh，但也可以使用 https 等其他协议。</p>\n<p>使用 https 除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。</p>\n<h3> 克隆小结</h3>\n<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用 <code>git clone</code> 命令克隆。</p>\n<p>Git 支持多种协议，包括 https，但通过 ssh 支持的原生 git 协议速度最快。</p>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "纵向查看",
      "url": "https://harryxiong24.github.io/zh/git/statusView.html",
      "id": "https://harryxiong24.github.io/zh/git/statusView.html",
      "summary": "我们已经成功地添加并提交了一个 readme.txt 文件，继续修改 readme.txt 文件，改成如下内容: 现在，运行 git status 命令看看结果: git status 命令可以输出仓库当前的状态，上面的命令输出告诉我们，readme.txt 被修改过了，但还没有准备提交的修改。 Git 现在只告诉我们 readme.txt 被修改了，...",
      "content_html": "<h1> 纵向查看</h1>\n<p>我们已经成功地添加并提交了一个 readme.txt 文件，继续修改 readme.txt 文件，改成如下内容:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>现在，运行 <code>git status</code> 命令看看结果:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p><code>git status</code> 命令可以输出仓库当前的状态，上面的命令输出告诉我们，readme.txt 被修改过了，但还没有准备提交的修改。</p>\n<p>Git 现在只告诉我们 readme.txt 被修改了，我们用 <code>git diff</code> 这个命令能看看具体修改了什么内容:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p><code>git diff</code> 顾名思义就是查看 difference，显示的格式正是 Unix 通用的 diff 格式，可以从上面的命令输出看到，我们在第一行添加了一个 distributed 单词。</p>\n<p>知道了对 readme.txt 作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是 <code>git add</code>:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>同样没有任何输出。在执行第二步 <code>git commit</code> 之前，我们再运行 <code>git status</code> 看看当前仓库的状态:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p><code>git status</code> 告诉我们，将要被提交的修改包括 readme.txt，下一步，就可以放心地提交了:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>提交后，我们再用 <code>git status</code> 命令看看仓库的当前状态:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>Git 告诉我们当前没有需要提交的修改，而且，工作目录是干净(working tree clean)的。</p>\n<h2> 小结</h2>\n<ul>\n<li>\n<p>要随时掌握工作区的状态，使用 <code>git status</code> 命令。</p>\n</li>\n<li>\n<p>如果 <code>git status</code> 告诉您有文件被修改过，用 <code>git diff</code> 可以查看修改内容。</p>\n</li>\n</ul>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "标签管理",
      "url": "https://harryxiong24.github.io/zh/git/tag.html",
      "id": "https://harryxiong24.github.io/zh/git/tag.html",
      "summary": "为什么要有 tag 发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git 的标签虽然是版本库的快照，但其实它就是指向某个commit的指针(跟分支很像对不对？但是分支可以移动，标签不能移动)，所以...",
      "content_html": "<h1> 标签管理</h1>\n<h2> 为什么要有 tag</h2>\n<p>发布一个版本时，我们通常先在版本库中打一个标签(<code>tag</code>)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>\n<p>Git 的标签虽然是版本库的快照，但其实它就是指向某个<code>commit</code>的指针(跟分支很像对不对？但是分支可以移动，标签不能移动)，所以，创建和删除标签都是瞬间完成的。</p>\n<p>Git 有<code>commit</code>，为什么还要引入<code>tag</code>？</p>\n<p>“请把上周一的那个版本打包发布，<code>commit</code>号是 6a5819e...”</p>\n<p>“一串乱七八糟的数字不好找！”</p>\n<p>如果换一个办法:</p>\n<p>“请把上周一的那个版本打包发布，版本号是<code>v1.2</code>”</p>\n<p>“好的，按照<code>tag v1.2</code>查找<code>commit</code>就行！”</p>\n<p>所以，<code>tag</code>就是一个让人容易记住的有意义的名字，它跟某个<code>commit</code>绑在一起。</p>\n<hr>\n<h2> 创建标签</h2>\n<p>在 Git 中打标签非常简单，首先，切换到需要打标签的分支上:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>可以用命令<code>git tag</code>查看所有标签:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>默认标签是打在最新提交的<code>commit</code>上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>\n<p>方法是找到历史提交的<code>commit id</code>，然后打上就可以了:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>比方说要对<code>add merge</code>这次提交打标签，它对应的<code>commit id</code>是<code>f52c633</code>，敲入命令:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>再用命令<code>git tag</code>查看标签:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p>\n<p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>注意: 标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。</p>\n</blockquote>\n<h3> 添加小结</h3>\n<p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个<code>commit id</code>；</p>\n<p>命令<code>git tag -a &lt;tagname&gt; -m \"blablabla...\"</code>可以指定标签信息；</p>\n<p>命令<code>git tag</code>可以查看所有标签。</p>\n<hr>\n<h2> 操作标签</h2>\n<p>如果标签打错了，也可以删除:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>\n<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>或者，一次性推送全部尚未推送到远程的本地标签:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>然后，从远程删除。删除命令也是 push，但是格式如下:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>要看看是否真的从远程库删除了标签，可以登陆 Github 查看。</p>\n<h3> 管理标签小结</h3>\n<ul>\n<li>\n<p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p>\n</li>\n<li>\n<p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p>\n</li>\n<li>\n<p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p>\n</li>\n<li>\n<p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p>\n</li>\n</ul>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "Git 总体介绍",
      "url": "https://harryxiong24.github.io/zh/git/whatIsGit.html",
      "id": "https://harryxiong24.github.io/zh/git/whatIsGit.html",
      "summary": "什么是 Git Git 是什么？ Git 是目前世界上最先进的分布式版本控制系统(没有之一)。 版本控制系统 如果您用 Microsoft Word 写过长篇大论，那您一定有这样的经历: 想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的 Word 文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直...",
      "content_html": "<h1> Git 总体介绍</h1>\n<h2> 什么是 Git</h2>\n<p>Git 是什么？</p>\n<p>Git 是目前世界上最先进的分布式版本控制系统(没有之一)。</p>\n<h2> 版本控制系统</h2>\n<p>如果您用 Microsoft Word 写过长篇大论，那您一定有这样的经历:</p>\n<p>想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的 Word 文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去。过了一周，您想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。</p>\n<p>看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。</p>\n<p>更要命的是，有些部分需要您的财务同事帮助填写，于是您把文件 Copy 到 U 盘里给她(也可能通过 Email 发送一份给她)，然后，您继续修改 Word 文件。一天后，同事再把 Word 文件传给您，此时，您必须想想，发给她之后到您收到她的文件期间，您作了哪些改动，得把您的改动和她的部分合并，真困难。</p>\n<p>于是您想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？</p>\n<p>这个软件用起来就应该像这个样子，能记录每次文件的改动:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">版本</th>\n<th style=\"text-align:center\">文件名</th>\n<th style=\"text-align:center\">用户</th>\n<th style=\"text-align:center\">说明</th>\n<th style=\"text-align:center\">日期</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">service.doc</td>\n<td style=\"text-align:center\">张三</td>\n<td style=\"text-align:center\">删除了软件服务条款 5</td>\n<td style=\"text-align:center\">7/12 10:38</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">service.doc</td>\n<td style=\"text-align:center\">张三</td>\n<td style=\"text-align:center\">增加了 License 人数限制</td>\n<td style=\"text-align:center\">7/12 18:09</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">service.doc</td>\n<td style=\"text-align:center\">李四</td>\n<td style=\"text-align:center\">财务部门调整了合同金额</td>\n<td style=\"text-align:center\">7/13 9:51</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">service.doc</td>\n<td style=\"text-align:center\">张三</td>\n<td style=\"text-align:center\">延长了免费升级周期</td>\n<td style=\"text-align:center\">7/14 15:17</td>\n</tr>\n</tbody>\n</table>\n<p>这样，您就结束了手动管理多个“版本”的史前时代，进入到版本控制的 20 世纪。</p>\n<hr>\n<h2> 分布式的 Git</h2>\n<p>CVS 及 SVN 都是集中式的版本控制系统，而 Git 是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？</p>\n<h3> 集中式版本控制系统</h3>\n<p>集中式版本控制系统版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，您要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>\n<p></p>\n<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个 10M 的文件就需要 5 分钟，这还不得把人给憋死啊。</p>\n<h3> 分布式版本控制系统</h3>\n<p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，您工作的时候，就不需要联网了，因为版本库就在您自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说您在自己电脑上改了文件 A，您的同事也在他的电脑上改了文件 A，这时，您们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>\n<h3> 分布式系统的优势</h3>\n<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>\n<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能您们俩不在一个局域网内，两台电脑互相访问不了，也可能今天您的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>\n<p></p>\n<p>当然，Git 的优势不单是不必联网这么简单，后面介绍的 Git 极其强大的分支管理，把 SVN 等远远抛在了后面。</p>\n<p>CVS 作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于 CVS 自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的 SVN 修正了 CVS 的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</p>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "工作区和暂存区",
      "url": "https://harryxiong24.github.io/zh/git/workingDirectory.html",
      "id": "https://harryxiong24.github.io/zh/git/workingDirectory.html",
      "summary": "Git 和其他版本控制系统如 SVN 的一个不同之处就是有暂存区的概念。 工作区(Working Directory) 就是您在电脑里能看到的目录，比如 learngit 文件夹就是一个工作区: 版本库(Repository) 工作区有一个隐藏目录.git，这个不算工作区，而是 Git 的版本库。 Git 的版本库里存了很多东西，其中最重要的就是称为 ...",
      "content_html": "<h1> 工作区和暂存区</h1>\n<p>Git 和其他版本控制系统如 SVN 的一个不同之处就是有暂存区的概念。</p>\n<h2> 工作区(Working Directory)</h2>\n<p>就是您在电脑里能看到的目录，比如 learngit 文件夹就是一个工作区:</p>\n<h2> 版本库(Repository)</h2>\n<p>工作区有一个隐藏目录.git，这个不算工作区，而是 Git 的版本库。</p>\n<p>Git 的版本库里存了很多东西，其中最重要的就是称为 stage(或者叫 index)的暂存区，还有 Git 为我们自动创建的第一个分支 <code>master</code>，以及指向 master 的一个指针叫 <code>HEAD</code>。</p>\n<p></p>\n<p>前面讲了我们把文件往 Git 版本库里添加的时候，提交更改，实际上就是把暂存区的所有内容提交到当前分支。我们创建 Git 版本库时，Git 自动为我们创建了唯一一个 <code>master</code> 分支，所以，现在，<code>git commit</code> 就是往 master 分支上提交更改。</p>\n<p>您可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>\n<p>先对 readme.txt 做个修改，比如加上一行内容:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><p>然后，在工作区新增一个 LICENSE 文本文件(内容随便写)。</p>\n<p>先用 <code>git status</code> 查看一下状态:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Git 非常清楚地告诉我们，readme.txt 被修改了，而 LICENSE 还从来没有被添加过，所以它的状态是 <code>Untracked</code>。</p>\n<p>现在，使用两次命令 <code>git add</code>，把 readme.txt 和 LICENSE 都添加后，用 <code>git status</code> 再查看一下:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>现在，暂存区的状态就变成这样了:</p>\n<p></p>\n<p>所以，<code>git add</code> 命令实际上就是把要提交的所有修改放到暂存区(Stage)，然后，执行 <code>git commit</code> 就可以一次性把暂存区的所有修改提交到分支。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>一旦提交后，如果您又没有对工作区做任何修改，那么工作区就是“干净”的:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div>",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "写在前面",
      "url": "https://harryxiong24.github.io/zh/poem/",
      "id": "https://harryxiong24.github.io/zh/poem/",
      "content_html": "<h1> 写在前面</h1>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "诗集"
      ]
    },
    {
      "title": "Python 安装",
      "url": "https://harryxiong24.github.io/zh/python/install.html",
      "id": "https://harryxiong24.github.io/zh/python/install.html",
      "summary": "要开始学习 Python 编程，首先就得把 Python 安装到您的电脑里。安装后，您会得到 Python 解释器(就是负责运行 Python 程序的)，一个命令行交互环境，还有一个简单的集成开发环境。本节将指导您如何安装 Python。 在 Mac 上安装 Python 如果您正在使用 Mac，系统是 OS X>=10.9，那么系统自带的 Pytho...",
      "content_html": "<p>要开始学习 Python 编程，首先就得把 Python 安装到您的电脑里。安装后，您会得到 Python 解释器(就是负责运行 Python 程序的)，一个命令行交互环境，还有一个简单的集成开发环境。本节将指导您如何安装 Python。</p>\n<h2> 在 Mac 上安装 Python</h2>\n<p>如果您正在使用 Mac，系统是 OS X&gt;=10.9，那么系统自带的 Python 版本是 2.7。要安装最新的 Python 3.8，有两个方法:</p>\n<p>方法一:从 Python 官网下载 Python 3.8 的安装程序，下载后双击运行并安装；</p>\n<p>方法二:如果安装了 Homebrew，直接通过命令 brew install python3 安装即可。</p>\n<h2> 在 Linux 上安装 Python</h2>\n<p>用 Linux 的人自行安装 Python 3 应该没有问题，否则，请换回 Windows 系统。</p>\n<h2> 在 Windows 上安装 Python</h2>\n<p>首先，从 Python 的官方网站下载 Python 3.8 对应的 64 位安装程序，然后，运行下载的 exe 安装包。</p>\n<blockquote>\n<p>这年头应该没人用 32 位的系统了吧 😏</p>\n</blockquote>\n<p>特别要注意勾上 <code>Add Python 3.8 to PATH</code>，然后点 “Install Now” 即可完成安装。</p>\n<h2> 运行 Python</h2>\n<p>安装成功后，打开命令提示符窗口，敲入 <code>python</code> 后，会出现两种情况:</p>\n<p>情况一:</p>\n<p></p>\n<p>看到上面的画面，就说明 Python 安装成功！</p>\n<p>您看到提示符 <code>&gt;&gt;&gt;</code> 就表示我们已经在 Python 交互式环境中了，可以输入任何 Python 代码，回车后会立刻得到执行结果。现在，输入 <code>exit()</code> 并回车，就可以退出 Python 交互式环境(直接关掉命令行窗口也可以)。</p>\n<p>情况二:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>这是因为 Windows 会根据一个 Path 的环境变量设定的路径去查找 python.exe，如果没找到，就会报错。如果在安装时漏掉了勾选 \"Add Python 3.8 to PATH\"，那就要手动把 python.exe 所在的路径添加到 Path 中。</p>\n<p>如果您不知道怎么修改环境变量，建议把 Python 安装程序重新运行一遍，务必记得勾上 \"Add Python 3.8 to PATH\"。</p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>需要注意的是:</p>\n<ul>\n<li>\n<p>在 Windows 上运行 Python 时，请先启动命令行，然后运行 <code>python</code>。</p>\n</li>\n<li>\n<p>在 Mac 和 Linux 上运行 Python 时，请打开终端，然后运行 <code>python3</code>。</p>\n</li>\n</ul>\n</div>\n",
      "date_published": "2020-06-07T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Python"
      ]
    },
    {
      "title": "Python 解释器",
      "url": "https://harryxiong24.github.io/zh/python/interpreter.html",
      "id": "https://harryxiong24.github.io/zh/python/interpreter.html",
      "summary": "当我们编写 Python 代码时，我们得到的是一个包含 Python 代码的以 .py 为扩展名的文本文件。要运行代码，就需要 Python 解释器去执行 .py 文件。",
      "content_html": "<p>当我们编写 Python 代码时，我们得到的是一个包含 Python 代码的以 <code>.py</code> 为扩展名的文本文件。要运行代码，就需要 Python 解释器去执行 <code>.py</code> 文件。</p>\n<!-- more -->\n<p>由于整个 Python 语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写 Python 解释器来执行 Python 代码(当然难度很大)。事实上，确实存在多种 Python 解释器。</p>\n<h2> CPython</h2>\n<p>当我们从 Python 官方网站下载并安装好 Python 3.x 后，我们就直接获得了一个官方版本的解释器:CPython。这个解释器是用 C 语言开发的，所以叫 CPython。在命令行下运行 python 就是启动 CPython 解释器。</p>\n<p>CPython 是使用最广的 Python 解释器。教程的所有代码也都在 CPython 下执行。</p>\n<h2> IPython</h2>\n<p>IPython 是基于 CPython 之上的一个交互式解释器，也就是说，IPython 只是在交互方式上有所增强，但是执行 Python 代码的功能和 CPython 是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了辣鸡 IE。</p>\n<p>CPython 用 <code>&gt;&gt;&gt;</code> 作为提示符，而 IPython 用 <code>In [序号]:</code> 作为提示符。</p>\n<h2> PyPy</h2>\n<p>PyPy 是另一个 Python 解释器，它的目标是执行速度。PyPy 采用 <a href=\"https://zh.wikipedia.org/wiki/Just-in-time_compilation\" target=\"_blank\" rel=\"noopener noreferrer\">JIT</a> 技术，对 Python 代码进行动态编译(注意不是解释)，所以可以显著提高 Python 代码的执行速度。</p>\n<p>绝大部分 Python 代码都可以在 PyPy 下运行，但是 PyPy 和 CPython 有一些是不同的，这就导致相同的 Python 代码在两种解释器下执行可能会有不同的结果。如果您的代码要放到 PyPy 下执行，就需要了解 <a href=\"https://doc.pypy.org/en/latest/cpython_differences.html\" target=\"_blank\" rel=\"noopener noreferrer\">PyPy 和 CPython 的不同点</a>。</p>\n<h2> Jython</h2>\n<p>Jython 是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。</p>\n<h2> IronPython</h2>\n<p>IronPython 和 Jython 类似，只不过 IronPython 是运行在微软.Net 平台上的 Python 解释器，可以直接把 Python 代码编译成.Net 的字节码。</p>\n<h2> 小结</h2>\n<p>Python 的解释器很多，但使用最广泛的还是 CPython。如果要和 Java 或.Net 平台交互，最好的办法不是用 Jython 或 IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</p>\n<p>本教程的所有代码只确保在 CPython 3.x 版本下运行。请务必在本地安装 CPython(也就是从 Python 官方网站下载的安装程序)。</p>\n",
      "date_published": "2020-06-07T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Python"
      ]
    },
    {
      "title": "Python 简介",
      "url": "https://harryxiong24.github.io/zh/python/intro.html",
      "id": "https://harryxiong24.github.io/zh/python/intro.html",
      "summary": "本节将简单介绍 Python 的历史。",
      "content_html": "<p>本节将简单介绍 Python 的历史。</p>\n<!-- more -->\n<p>Python 是 Guido van Rossum(“龟叔”) 在 1989 年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。</p>\n<p>总的来说，这几种编程语言各有千秋。C 语言是可以用来编写操作系统的贴近硬件的语言，所以，C 语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而 Python 是用来编写应用程序的高级编程语言。</p>\n<p>当您用一种语言开始作真正的软件开发时，您除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助您加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让您能直接调用，比如，针对电子邮件协议的 SMTP 库，针对桌面环境的 GUI 库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。</p>\n<p>Python 就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池(batteries included)”。用 Python 开发，许多功能不必从零编写，直接使用现成的即可。</p>\n<p>除了内置的库外，Python 还有大量的第三方库，也就是别人开发的，供您直接使用的东西。当然，如果您开发的代码通过很好的封装，也可以作为第三方库给别人使用。</p>\n<p>许多大型网站就是用 Python 开发的，例如 YouTube、Instagram，还有国内的豆瓣。很多大公司，包括 Google、Yahoo 等，甚至 NASA(美国航空航天局)都大量地使用 Python。</p>\n<p>龟叔给 Python 的定位是“优雅”、“明确”、“简单”，所以 Python 程序看上去总是简单易懂，初学者学 Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。</p>\n<p>总的来说，Python 的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向您炫耀他写的晦涩难懂、动不动就几万行的代码，您可以尽情地嘲笑他。</p>\n<p>那 Python 适合开发哪些类型的应用呢？</p>\n<p>首选是网络应用，包括网站、后台服务等等；</p>\n<p>其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等；</p>\n<p>另外就是把其他语言开发的程序再包装起来，方便使用。</p>\n<p>最后说说 Python 的缺点。</p>\n<p>任何编程语言都有缺点，Python 也不例外。优点说过了，那 Python 有哪些缺点呢？</p>\n<p>第一个缺点就是运行速度慢，和 C 程序相比非常慢，因为 Python 是解释型语言，您的代码在执行时会一行一行地翻译成 CPU 能理解的机器码，这个翻译过程非常耗时，所以很慢。而 C 程序是运行前直接编译成 CPU 能执行的机器码，所以非常快。</p>\n<p>但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载 MP3 的网络应用程序，C 程序的运行时间需要 0.001 秒，而 Python 程序的运行时间需要 0.1 秒，慢了 100 倍，但由于网络更慢，需要等待 1 秒，您想，用户能感觉到 1.001 秒和 1.1 秒的区别吗？这就好比 F1 赛车和普通的出租车在北京三环路上行驶的道理一样，虽然 F1 赛车理论时速高达 400 公里，但由于三环路堵车的时速只有 20 公里，因此，作为乘客，您感觉的时速永远是 20 公里。</p>\n<p>第二个缺点就是代码不能加密，这点跟前端广泛使用的 JS 相同。如果要发布您的 Python 程序，实际上就是发布源代码，这一点跟 C 语言不同，C 语言不用发布源代码，只需要把编译后的机器码(也就是您在 Windows 上常见的 xxx.exe 文件)发布出去。要从机器码反推出 C 代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。</p>\n<p>这个缺点仅限于您要编写的软件需要卖给别人挣钱的时候。好消息是目前的互联网时代，靠卖软件授权的商业模式越来越少了，靠网站和移动应用卖服务的模式越来越多了，后一种模式不需要把源码给别人。</p>\n<p>再说了，现在如火如荼的开源运动和互联网自由开放的精神是一致的，互联网上有无数非常优秀的像 Linux 一样的开源代码，我们千万不要高估自己写的代码真的有非常大的“商业价值”。那些大公司的代码不愿意开放的更重要的原因是代码写得太烂了，一旦开源，就没人敢用他们的产品了。</p>\n",
      "date_published": "2020-06-07T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Python"
      ]
    },
    {
      "title": "Python",
      "url": "https://harryxiong24.github.io/zh/python/",
      "id": "https://harryxiong24.github.io/zh/python/",
      "summary": "优点: Python 是一种高级语言，它可以用更少的代码量完成相同工作。 缺点: Python 是一种脚本语言，它的执行效率不是很高。",
      "content_html": "<ul>\n<li>优点: Python 是一种高级语言，它可以用更少的代码量完成相同工作。</li>\n<li>缺点: Python 是一种脚本语言，它的执行效率不是很高。</li>\n</ul>\n<!-- more -->\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>本教程基于 Python3, Python2 已经过时停止维护多年，请不要使用学习。</p>\n</div>\n<h2> Python 简介</h2>\n<ul>\n<li>\n<p><a href=\"/zh/python/intro.html\" target=\"blank\">Python 介绍</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/install.html\" target=\"blank\">Python 安装</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/interpreter.html\" target=\"blank\">Python 解释器</a></p>\n</li>\n</ul>\n<h2> Python 快速入门</h2>\n<ul>\n<li>\n<p><a href=\"/zh/python/guide/write.html\" target=\"blank\">第一个 Python 程序</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/guide/io.html\" target=\"blank\">输入与输出</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/guide/basic.html\" target=\"blank\">基础语法</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/guide/string.html\" target=\"blank\">字符串</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/guide/listAndTuple.html\" target=\"blank\">List 和 Tuple</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/guide/condition.html\" target=\"blank\">条件判断</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/guide/loop.html\" target=\"blank\">循环</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/dictAndSet.html\" target=\"blank\">Dictionary 和 Set</a></p>\n</li>\n</ul>\n<h2> Python 函数</h2>\n<ul>\n<li>\n<p><a href=\"/zh/python/function/intro.html\" target=\"blank\">函数介绍</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/function/define.html\" target=\"blank\">函数定义</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/function/call.html\" target=\"blank\">函数调用</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/function/argument.html\" target=\"blank\">函数参数</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/function/recursive.html\" target=\"blank\">递归调用</a></p>\n</li>\n</ul>\n<h2> Python 高级语法</h2>\n<ul>\n<li>\n<p><a href=\"/zh/python/advance/slice.html\" target=\"blank\">切片</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/advance/iteration.html\" target=\"blank\">迭代</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/advance/list-comprehensions.html\" target=\"blank\">列表生成式</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/advance/generator.html\" target=\"blank\">生成器</a></p>\n</li>\n<li>\n<p><a href=\"/zh/python/advance/iterator.html\" target=\"blank\">迭代器</a></p>\n</li>\n</ul>\n<h2> 相关工具</h2>\n<ul>\n<li><a href=\"https://c.runoob.com/compile/9\" target=\"_blank\" rel=\"noopener noreferrer\">Python 在线运行器</a></li>\n</ul>\n",
      "date_published": "2020-06-07T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Python"
      ]
    },
    {
      "title": "VSCode 安装",
      "url": "https://harryxiong24.github.io/zh/vscode/install.html",
      "id": "https://harryxiong24.github.io/zh/vscode/install.html",
      "summary": "下载 在 官网下载地址 (https://code.visualstudio.com/Download) 或群内下载最新版 Win64User 安装包。 安装 双击安装包打开同意用户协议。 安装过程中，请务必钩上以下选项: 安装 VSCode 勾选 添加到目录上下文菜单、添加到文件上下文菜单、将 code 注册为受支持的文件编辑器、添加到 path。 ...",
      "content_html": "<h1> VSCode 安装</h1>\n<h2> 下载</h2>\n<p>在 <a href=\"https://code.visualstudio.com/Download\" target=\"_blank\" rel=\"noopener noreferrer\">官网下载地址</a> 或群内下载最新版 Win64User 安装包。</p>\n<h2> 安装</h2>\n<p>双击安装包打开同意用户协议。</p>\n<p>安装过程中，请务必钩上以下选项:</p>\n<p></p>\n<p>勾选 <strong>添加到目录上下文菜单</strong>、<strong>添加到文件上下文菜单</strong>、<strong>将 code 注册为受支持的文件编辑器</strong>、<strong>添加到 path</strong>。</p>\n<p>在 VSCode 初次启动后，若未提前安装 Git 可能会提示未找到 Git 软件，忽略即可；推荐立即执行简体中文扩展安装以保证界面语言为简体中文。</p>\n<h2> 更新频率</h2>\n<p>VS Code 每月发布一个具有新功能和重要错误修复的新版本。大多数平台都支持自动更新，并且会在新版本发布时提示您安装新版本。您还可以通过运行“帮助”&gt;“检查更新”来手动检查更新。</p>\n<h2> Mac 添加 “通过 Code 打开”</h2>\n<p>在 Mac 系统上，Finder 选中一个目录，右键菜单并没有 “通过 Code 打开” 这个操作。不过我们可以通过 Automator 自己添加这个操作。</p>\n<p>先运行 Automator，选择“服务”:</p>\n<p></p>\n<p>然后，执行以下操作:</p>\n<p></p>\n<ol>\n<li>\n<p>在右侧面板选择 “服务” 收到选定的 “文件夹”，位于 “Finder.app“，该选项是为了从 Finder 中接收一个文件夹；</p>\n</li>\n<li>\n<p>在左侧面板选择 ”实用工具“，然后找到 ”运行 Shell 脚本“，把它拽到右侧面板里；</p>\n</li>\n<li>\n<p>在右侧 ”运行 Shell 脚本“ 的面板里，选择 Shell ”/bin/bash“，传递输入“作为自变量”，然后修改 Shell 脚本如下:</p>\n</li>\n</ol>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>保存为 “Open With VSCode” 后，打开 Finder，选中一个文件夹，点击右键，“服务”，就可以看到 “Open With VSCode” 菜单:</p>\n<p></p>\n",
      "date_published": "2020-06-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "VS Code"
      ]
    },
    {
      "title": "VSCode",
      "url": "https://harryxiong24.github.io/zh/vscode/",
      "id": "https://harryxiong24.github.io/zh/vscode/",
      "summary": "简介 Visual Studio Code 是一个轻量级但功能强大的源代码编辑器，可在您的桌面上运行，并且可用于 Windows，macOS 和 Linux。 它具有对 JavaScript，TypeScript 和 Node.js 的内置支持，并具有丰富的其他语言 (例如 C ++，C＃，Java，Python，PHP，Go) 和运行时 (例如 .N...",
      "content_html": "<h1> VSCode</h1>\n<h2> 简介</h2>\n<p>Visual Studio Code 是一个轻量级但功能强大的源代码编辑器，可在您的桌面上运行，并且可用于 Windows，macOS 和 Linux。 它具有对 JavaScript，TypeScript 和 Node.js 的内置支持，并具有丰富的其他语言 (例如 C ++，C＃，Java，Python，PHP，Go) 和运行时 (例如 .NET 和 Unity) 扩展的生态系统。由微软出品，因其开源，可扩展和众多插件成为全球最受欢迎的代码编辑器。</p>\n<h2> 安装</h2>\n<ul>\n<li><a href=\"/zh/vscode/install.html\" target=\"blank\">查看详情</a></li>\n</ul>\n<h2> 运行 VSCode</h2>\n<ul>\n<li>\n<p>智能代码补全</p>\n<p>使用 IntelliSense 可以更智能地编写代码、变量，方法和导入模块的完成。</p>\n</li>\n<li>\n<p>热门扩展</p>\n<p>启用其他语言，主题，调试器，命令等。</p>\n</li>\n</ul>\n<h3> 关于 VSCode 界面</h3>\n<p>VSCode 最上方有一排菜单栏，其中有大量的快捷操作，对应的组合键会标于快捷操作旁。如果不能记忆快捷键可以到最上方的菜单栏处查看。</p>\n<p>最左侧是选项卡切换，从上至下依次是<a href=\"#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8\">资源管理器</a>、<a href=\"#%E6%90%9C%E7%B4%A2\">搜索</a>、<a href=\"#%E6%BA%90%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86\">源代码管理</a>、<a href=\"#%E8%B0%83%E8%AF%95\">调试</a>和<a href=\"#%E6%89%A9%E5%B1%95\">扩展</a>。</p>\n<p>最下方的一条是状态栏。从左到右依次是分支名称、同步状态、错误和警告个数、光标位置、缩进大小、编码格式、行尾序列、文件格式、反馈和通知。</p>\n<ul>\n<li>\n<p>资源管理器</p>\n<p>资源管理器是最常使用的界面，快捷键为 <code>Ctrl + Shift + E</code>。</p>\n</li>\n<li>\n<p>搜索</p>\n<p>搜索界面可以方便的对打开文件夹内的所有文本型文件进行关键字的搜索。搜索结果会详细的列出来，搜索内容支持正则表达式，快捷键为 <code>Ctrl + Shift + F</code>。</p>\n</li>\n<li>\n<p>源代码管理</p>\n<p>源代码管理提供快速暂存、提交并同步更改的功能，快捷键为 <code>Ctrl + Shift + G</code>。</p>\n<p>关于源代码相关功能的使用，请见 <a href=\"/zh/git/\" target=\"blank\">Git 使用说明</a>。</p>\n</li>\n<li>\n<p>调试</p>\n<p>在这里可以调试代码，快捷键为 <code>Ctrl + Shift + D</code>。(日后补充)</p>\n</li>\n<li>\n<p>扩展组件</p>\n<p>在商店中可以找到大量的扩展，快捷键为 <code>Ctrl + Shift + X</code>。尽量选择一些 star 数比较高的插件安装。安装插件后请仔细阅读说明文档以了解插件的用法。</p>\n</li>\n</ul>\n<h3> 强大的扩展内容</h3>\n<p>VSCode 扩展允许第三方添加对以下内容的支持:</p>\n<ul>\n<li>语言-C ++，C＃，Go，Java，Python</li>\n<li>工具-ESLint，JSHint，PowerShell</li>\n<li>调试器-Chrome，PHP XDebug。</li>\n<li>键盘映射-Vim，Sublime Text，IntelliJ，Emacs，Atom，Visual Studio，Eclipse</li>\n<li>扩展集成到 VS Code 的 UI，命令和任务运行系统中，因此您将发现通过 VS Code 的共享界面可以轻松使用不同的技术。</li>\n</ul>\n<p>扩展可以通过按 <code>F1</code> 或者 <code>Ctrl + Shift + P</code> 来打开命令行窗口，并输入 <code>ext install 扩展名称</code> 来进行安装</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>更多内容见<a href=\"/zh/vscode/vscodeExtension.html\" target=\"blank\">VSCode 推荐扩展</a></p>\n</div>\n<h2> 用 VSCode 打开文件和文件夹</h2>\n<p>VSCode 支持打开文件和文件夹。</p>\n<p>打开文件时请在文件图标上单击右键—选择“使用 VSCode 打开”；</p>\n<p>打开文件夹请双击打开文件夹，在空白处单击右键——选择“用 VSCode 打开”。</p>\n<h2> VSCode 快捷键</h2>\n<ul>\n<li><a href=\"/zh/vscode/shortcutKey.html\" target=\"blank\">点击此处</a></li>\n</ul>\n<h2> VSCode 设置</h2>\n<ul>\n<li><a href=\"/zh/vscode/vscodeSettings.html\" target=\"blank\">点击此处</a></li>\n</ul>\n<h2> VSCode 文档</h2>\n<ul>\n<li>\n<p><a href=\"https://code.visualstudio.com/docs\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></p>\n</li>\n<li>\n<p><a href=\"https://code.visualstudio.com/docs/getstarted/introvideos\" target=\"_blank\" rel=\"noopener noreferrer\">官方视频</a></p>\n</li>\n</ul>\n",
      "date_published": "2020-06-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "VS Code"
      ]
    },
    {
      "title": "VSCode 快捷键说明",
      "url": "https://harryxiong24.github.io/zh/vscode/shortcutKey.html",
      "id": "https://harryxiong24.github.io/zh/vscode/shortcutKey.html",
      "summary": "鼠标操作 在当前行的位置，鼠标三击，可以选中当前行。; 用鼠标单击文件的行号，可以选中当前行。; 在某个行号的位置，上下移动鼠标，可以选中多行。; 移动光标 「方向键」: 在单个字符之间移动光标; 「Ctrl + 左右方向键」: 在单词之间移动光标(很常用)。注: Win 快捷键是。; 快速选中 在任意位置单击放置光标，按住 shift 在第二个位置单...",
      "content_html": "<h1> VSCode 快捷键说明</h1>\n<h2> 鼠标操作</h2>\n<ul>\n<li>\n<p>在当前行的位置，鼠标三击，可以选中当前行。</p>\n</li>\n<li>\n<p>用鼠标单击文件的行号，可以选中当前行。</p>\n</li>\n<li>\n<p>在某个行号的位置，上下移动鼠标，可以选中多行。</p>\n</li>\n</ul>\n<h2> 移动光标</h2>\n<ul>\n<li>\n<p>「方向键」: 在<strong>单个字符</strong>之间移动光标</p>\n</li>\n<li>\n<p>「Ctrl + 左右方向键」: 在<strong>单词</strong>之间移动光标(很常用)。注: Win 快捷键是。</p>\n</li>\n</ul>\n<h2> 快速选中</h2>\n<p>在任意位置单击放置光标，按住 <code>shift</code> 在第二个位置单击，即可选中两光标位置间的所有文字。</p>\n<ul>\n<li>\n<p><code>Ctrl + Alt + ↑/↓</code>: 向方向键方向的相邻行放置一个光标；</p>\n</li>\n<li>\n<p><code>Alt + Click</code>: 放置辅助游标；</p>\n</li>\n<li>\n<p><code>Shift + Alt + ←/→</code>: 收缩/扩展选择；</p>\n</li>\n<li>\n<p><code>Shift + Alt</code> 同时拖动到对角: 列(框)选择；</p>\n</li>\n</ul>\n<h2> 删除</h2>\n<ul>\n<li>\n<p><code>Ctrl + Backspace</code>: 删除光标之前的一个单词</p>\n</li>\n<li>\n<p><code>Ctrl + delete</code>: 　删除光标之后的一个单词</p>\n</li>\n<li>\n<p><code>Ctrl + Shift + K</code>: 删除整行</p>\n</li>\n</ul>\n<h2> 移动文字</h2>\n<ul>\n<li>\n<p><code>Alt + ↑</code>: 光标所在行或选中的文字的所有行整体上移一行；</p>\n</li>\n<li>\n<p><code>Alt + ↓</code>: 光标所在行或选中文字的所有行整体下移一行</p>\n</li>\n</ul>\n<h2> 复制文字</h2>\n<ul>\n<li>\n<p><code>Alt + shift + ↑</code>: 光标所在行或选中的文字的所有行整体向下复制一行(如果选中了多行就是复制多行)；</p>\n</li>\n<li>\n<p><code>Alt + shift + ↓</code>: 光标所在行或选中文字的所有行整体向上复制一行(如果选中了多行就是复制多行)；</p>\n</li>\n<li>\n<p><code>Ctrl + D</code>: 选择光标处的单词，或下一次出现的当前选择；</p>\n</li>\n</ul>\n<h2> 代码操作</h2>\n<ul>\n<li>\n<p><code>Ctrl + /</code>: 添加单行注释</p>\n</li>\n<li>\n<p><code>Alt + shift + F</code>: 代码格式化</p>\n</li>\n<li>\n<p><code>Ctrl + U</code>: 将光标的移动回退到上一个位置、撤销光标的移动和选择</p>\n</li>\n<li>\n<p><code>Cmd + Enter</code>: 在当前行下面新增一行，然后跳至该行 (即使光标不在行尾，也能快速向下插入一行)</p>\n</li>\n<li>\n<p><code>Ctrl + P</code>: 在当前的项目工程里，<strong>全局</strong>搜索文件</p>\n</li>\n<li>\n<p><code>Ctrl + G</code>: 跳转到指定行</p>\n</li>\n<li>\n<p><code>Ctrl + shift + O</code>: 在当前文件的各种<strong>方法之间</strong>进行跳转</p>\n</li>\n</ul>\n<h3> 搜索</h3>\n<ul>\n<li>\n<p><code>Ctrl + F</code>: 查找，光标在搜索框里；</p>\n</li>\n<li>\n<p><code>F3</code>: 在当前文件中搜索，光标仍在编辑器里</p>\n</li>\n<li>\n<p><code>Ctrl + Shift +F</code>: 全局搜索</p>\n</li>\n<li>\n<p><code>Ctrl + H</code>: 替换。</p>\n</li>\n</ul>\n<h3> 多光标的使用</h3>\n<ol>\n<li>\n<p>按住 Alt 键，然后在页面中希望中现光标的位置点击鼠标。</p>\n</li>\n<li>\n<p>选中某个文本，然后反复按住快捷键 <code>Ctrl + D</code> 键， 即可将全文中与光标当前所在位置的词相同的词逐一加入选择。</p>\n</li>\n<li>\n<p>选中一堆文本后，按住<code>Alt + Shift + I</code> 键，既可在<strong>每一行的末尾</strong>都创建一个光标。</p>\n</li>\n</ol>\n<h3> 工作区快捷键</h3>\n<ul>\n<li>\n<p><code>Ctrl + B</code>: 显示/隐藏侧边栏</p>\n</li>\n<li>\n<p><code>Ctrl + \\</code>: 创建多个编辑器</p>\n</li>\n<li>\n<p><code>Ctrl + Pagedown/Pageup</code>: 在已经打开的文件之间进行<strong>切换</strong></p>\n</li>\n<li>\n<p><code>Ctrl+</code> ``: 打开终端</p>\n</li>\n</ul>\n<h2> 代码折叠</h2>\n<p><code>Ctrl + Shift + [</code>: 折叠光标处最内部的未折叠区域；</p>\n<p><code>Ctrl + Shift +]</code>: 展开光标处的折叠区域；</p>\n<p><code>Ctrl + K Ctrl + [</code>: 折叠光标处最内部的未折叠区域以及该区域内的所有区域；</p>\n<p><code>Ctrl + K Ctrl +]</code>: 展开光标处的区域以及该区域内的所有区域；</p>\n<p><code>Ctrl + K Ctrl + 0</code>: 折叠编辑器中的所有区域；</p>\n<p><code>Ctrl + K Ctrl + J</code>: 展开编辑器中的所有区域；</p>\n<p><code>Ctrl + K</code> <code>Ctrl</code> + <code>X</code>: 折叠级别<code>X</code>的所有区域，但当前光标位置的区域除外；</p>\n<p><code>Ctrl + K Ctrl + /</code>: 折叠以块注释标记开头的所有区域；</p>\n<h2> 其他 Windows 快捷键</h2>\n<p><code>Ctrl + X</code>: 剪切；</p>\n<p><code>Ctrl + C</code>: 复制；</p>\n<p><code>Ctrl + V</code>: 粘贴；</p>\n<p><code>Ctrl + A</code>: 全选；</p>\n<p><code>Ctrl + Z</code>: 撤销；</p>\n<p><code>Ctrl + Y</code>: 恢复；</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>更多请见</p>\n<ul>\n<li><a href=\"https://nenuyouth.com/Res/doc/private/software/vscode/vscodeKeyboardShortcutsWindows.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">VScode 快捷键介绍</a></li>\n</ul>\n</div>\n",
      "date_published": "2020-06-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "VS Code"
      ]
    },
    {
      "title": "VSCode 扩展使用说明",
      "url": "https://harryxiong24.github.io/zh/vscode/vscodeExtension.html",
      "id": "https://harryxiong24.github.io/zh/vscode/vscodeExtension.html",
      "summary": "以下是推荐的 VSCode 扩展: 语言包 Chinese (Simplified) Language Pack for Visual Studio Code VSCode 原生为英文，本插件为 VSCode 提供简体中文支持，会更改页面为简体中文 外观 Bracket Pair Colorizer 为 VSCode 显示彩虹括号，在码代码时帮助判断匹...",
      "content_html": "<h1> VSCode 扩展使用说明</h1>\n<p>以下是推荐的 VSCode 扩展:</p>\n<h2> 语言包</h2>\n<h3> Chinese (Simplified) Language Pack for Visual Studio Code</h3>\n<p>VSCode 原生为英文，本插件为 VSCode 提供简体中文支持，会更改页面为简体中文</p>\n<h2> 外观</h2>\n<h3> Bracket Pair Colorizer</h3>\n<p>为 VSCode 显示彩虹括号，在码代码时帮助判断匹配括号</p>\n<h3> indent-rainbow</h3>\n<p>为代码中的缩进上色，更容易判断缩进层数</p>\n<h3> Material Icon Theme</h3>\n<p>为 VSCode 文件图标应用安卓的 Material 主题</p>\n<h3> One Dark Pro</h3>\n<p>为添加一款类 Atom 的一款暗色风格主题，配色会比 VSCode 默认风格好看一些</p>\n<h3> TODO Highlight</h3>\n<p>高光显示特定注释，如 <code>TODO:</code> 等</p>\n<h2> 工具</h2>\n<h3> Bookmarks</h3>\n<p>在代码中添加书签并支持快速跳转</p>\n<h3> filesize</h3>\n<p>在 VSCode 底部状态栏显示文件大小</p>\n<h3> ProjectManager</h3>\n<p>快速打开特定项目或在多个项目之间切换</p>\n<h3> Settings Sync</h3>\n<p>可将本机的设置同步至 Github，实现配置的备份与跨机器同步</p>\n<h3> SVG Viewer</h3>\n<p>提供在 VSCode 直接打开 SVG 的快捷菜单与支持</p>\n<h2> 版本管理与多人协作</h2>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>VSCode 不包含 Git，请自行安装 Git 并添加到 path 以实现版本管理。</p>\n</div>\n<h3> Git History</h3>\n<p>提供 Git 历史查看，对比等高级功能</p>\n<h3> GitLens</h3>\n<p>在文件中提供 Git 版本增强功能，包括但不限于行历史、文件历史、分支查看、本地与远程库提交查看与对比分析等</p>\n<h3> Live Share</h3>\n<p>官方实时分享功能，可多人同时协作一份文件，也可做在线演示</p>\n<h3> Live Share Audio</h3>\n<p>官方实时语音通话，可在多人协作或演示中使用</p>\n<h2> 网页</h2>\n<h3> Ant Design Vue helper</h3>\n<p>为 Antd Vue 提供代码补全及提示</p>\n<h3> Beautify css/sass/scss/less</h3>\n<p>为 css 等层叠样式表提供格式化功能</p>\n<h3> Color Info</h3>\n<p>为 css 颜色详情显示更多信息</p>\n<h3> Debugger for Chrome</h3>\n<p>在 Chrome 中调试代码</p>\n<h3> ESLint</h3>\n<p>需要 <code>eslint</code> 模块，进行 JS、TS 等文件的的错误检查、格式化</p>\n<h3> IntelliSense for CSS class names in HTML</h3>\n<p>通过检索 link 的外部 css 提供自动补全 class，当使用 bootstrap 的时候超有用</p>\n<h3> Vetur</h3>\n<p>为 VSCode 添加 <code>.vue</code> 文件的支持</p>\n<h2> XML 与 JSON</h2>\n<h3> json organizer</h3>\n<p>提供 json 到 js object 的相互转换</p>\n<h3> json Tools</h3>\n<p>提供压缩与缩进 JSON</p>\n<h3> XML Tools</h3>\n<p>提供 XML 补全、格式化等</p>\n<h2> PHP</h2>\n<h3> PHP Debug</h3>\n<p>PHP 逐行调试，需要提前在 PHP 中配置好 XDebug</p>\n<h3> PHP Intelephense</h3>\n<p>提供 PHP 函数补全</p>\n<h3> phpcs</h3>\n<p>PHP 错误检查与修复</p>\n<h2> 编程</h2>\n<h3> C/C++</h3>\n<p>提供代码格式化、自动完成、逐行调试等功能等</p>\n<h3> Code Runner</h3>\n<p>提供多种编程语言的运行</p>\n<h2> Markdown</h2>\n<h3> Markdown All in One</h3>\n<p>提供快速添加 Markdown 标记的支持</p>\n<h3> Markdown Emoji</h3>\n<p>为 Markdown 添加表情支持</p>\n<h3> Markdown Preview Github Style</h3>\n<p>为 Markdown 预览应用 Github 风格</p>\n<h3> markdownlint</h3>\n<p>检查 Markdown 文法错误</p>\n<h2> 小程序</h2>\n<h3> minapp</h3>\n<p>提供微信小程序标签、属性的智能补全</p>\n<h2> Node</h2>\n<h3> Node.js Modules Intellisense</h3>\n<p>提供 nodeJS 模块智能提示</p>\n<h3> npm Intellisense</h3>\n<p>为 VSCode 添加 npm 模块导入补全</p>\n<h2> LaTeX</h2>\n<h3> LaTeX Workshop</h3>\n<p>LaTeX 插件，支持常见功能与编译</p>\n<h3> latex-formatter</h3>\n<p>提供 LaTeX 格式化</p>\n<h2> 其他</h2>\n<h3> language-stylus</h3>\n<p>stylus 格式化，高亮支持</p>\n<h3> YAML</h3>\n<p>提供 YAML 格式化，高亮支持</p>\n<h3> LeetCode</h3>\n<p>代码学习练习软件</p>\n",
      "date_published": "2020-06-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "VS Code"
      ]
    },
    {
      "title": "VSCode 推荐配置",
      "url": "https://harryxiong24.github.io/zh/vscode/vscodeSettings.html",
      "id": "https://harryxiong24.github.io/zh/vscode/vscodeSettings.html",
      "summary": "部分设置是这里 (vscodeExtension.md)的插件配置 将下面内容拷贝至 setting.json 以更改 VSCode 设置 用鼠标在对应属性值上悬停时，Vscode 会自动给出属性的说明。",
      "content_html": "<h1> VSCode 推荐配置</h1>\n<p>部分设置是<a href=\"/zh/vscode/vscodeExtension.html\" target=\"blank\">这里</a>的插件配置</p>\n<p>将下面内容拷贝至 setting.json 以更改 VSCode 设置</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>用鼠标在对应属性值上悬停时，Vscode 会自动给出属性的说明。</p>\n",
      "date_published": "2020-06-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "VS Code"
      ]
    },
    {
      "title": "VSCode 的简单介绍",
      "url": "https://harryxiong24.github.io/zh/vscode/vscodeSimple.html",
      "id": "https://harryxiong24.github.io/zh/vscode/vscodeSimple.html",
      "summary": "简介 这是一款微软的代码编辑器，因其开源，可扩展和众多插件成为全球最受欢迎的代码编辑器。 VSCode 的安装 在官网下载地址 (https://code.visualstudio.com/Download)下载最新版 Win64User 安装包，双击安装包打开同意用户协议，一直下一步即可。 在 VSCode 初次启动后，若未提前安装 Git 可能会提...",
      "content_html": "<h1> VSCode 的简单介绍</h1>\n<h2> 简介</h2>\n<p>这是一款微软的代码编辑器，因其开源，可扩展和众多插件成为全球最受欢迎的代码编辑器。</p>\n<h2> VSCode 的安装</h2>\n<p>在<a href=\"https://code.visualstudio.com/Download\" target=\"_blank\" rel=\"noopener noreferrer\">官网下载地址</a>下载最新版 Win64User 安装包，双击安装包打开同意用户协议，一直下一步即可。</p>\n<p>在 VSCode 初次启动后，若未提前安装 Git 可能会提示未找到 Git 软件，忽略即可；若提示安装简体中文扩展，请点击安装以保证界面语言为简体中文。</p>\n<h2> 关于 VSCode 界面</h2>\n<p>VSCode 上方有一排菜单栏，其中有大量的快捷操作，对应的组合键会标于快捷操作旁。如果不能记忆快捷键可以到最上方的菜单栏处查看。</p>\n<p>最左侧是选项卡切换，从上至下依次是<a href=\"#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8\">资源管理器</a>、搜索、源代码管理、调试和扩展。</p>\n<p>最下方的一条是状态栏。从左到右依次是分支名称、同步状态、错误和警告个数、光标位置、缩进大小、编码格式、行尾序列、文件格式、反馈(没用)和通知。</p>\n<h3> 资源管理器</h3>\n<p>资源管理器是最常使用的界面，快捷键为 <code>Ctrl + Shift + E</code>。</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>请先点击扩展，搜索 JSON，安装 <strong>JSON organizer</strong> 和 <strong>JSON Tools</strong>，并按照界面提示重新加载 VSCode</p>\n</div>\n<hr>\n<h2> 用 VSCode 打开文件和文件夹</h2>\n<p>VSCode 支持打开文件和文件夹。</p>\n<p>打开文件时请在文件图标上单击右键—选择使用 VSCode 打开；</p>\n<p>打开文件夹请双击打开文件夹，在空白处单击右键——选择用 VSCode 打开。</p>\n<h2> VSCode 快捷键</h2>\n<h3> 快速选中</h3>\n<p>在任意位置单击放置光标，按住 <code>shift</code> 在第二个位置单击，即可选中两光标位置间的所有文字。</p>\n<p><code>Ctrl + Alt + ↑/↓</code>: 向方向键方向的相邻行放置一个光标；</p>\n<h3> 移动文字</h3>\n<p><code>Alt + ↑</code>: 光标所在行或选中的文字的所有行整体上移一行；</p>\n<p><code>Alt + ↓</code>: 光标所在行或选中文字的所有行整体下移一行</p>\n<h3> 复制文字</h3>\n<p><code>Alt + shift + ↑</code>: 光标所在行或选中的文字的所有行整体向下复制一行(如果选中了多行就是复制多行)；</p>\n<p><code>Alt + shift + ↓</code>: 光标所在行或选中文字的所有行整体向上复制一行(如果选中了多行就是复制多行)；</p>\n<h3> 格式化代码</h3>\n<p><code>Alt + shift + F</code></p>\n<h3> 缩进显示 json: (由插件提供支持)</h3>\n<p><code>Ctrl + Alt + M</code> (在制作时使用，方便查看 json)</p>\n<h3> 其他 Windows 快捷键</h3>\n<p><code>Ctrl + X</code>: 剪切；</p>\n<p><code>Ctrl + C</code>: 复制；</p>\n<p><code>Ctrl + V</code>: 粘贴；</p>\n<p><code>Ctrl + A</code>: 全选；</p>\n<p><code>Ctrl + Z</code>: 撤销；</p>\n<p><code>Ctrl + Y</code>: 恢复；</p>\n<p><code>Ctrl + F</code>: 查找；</p>\n<p><code>Ctrl + H</code>: 替换。</p>\n",
      "date_published": "2020-06-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "VS Code"
      ]
    },
    {
      "title": "Apache",
      "url": "https://harryxiong24.github.io/zh/back-end/apache/apache.html",
      "id": "https://harryxiong24.github.io/zh/back-end/apache/apache.html",
      "summary": "Apache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译到服务器中。",
      "content_html": "<p>Apache 是世界使用排名第一的 Web 服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩充，将 Perl/Python 等解释器编译到服务器中。</p>\n<!-- more -->\n<h2> Apache 是什么</h2>\n<p>Apache HTTP Server (简称 Apache )是 Apache 软件基金会的一个开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩展，将 Perl/Python 等解释器编译到服务器中。</p>\n<p>Apache HTTP 服务器是一个模块化的服务器，源于 NCSAhttpd 服务器，经过多次修改，成为世界使用排名第一的 Web 服务器软件。\n它可以运行在几乎所有广泛使用的计算机平台上。</p>\n<h2> Apache 模块</h2>\n<p>Apache 通过引入各种模块来完成不同的功能。</p>\n<h2> Apache 官方文档</h2>\n<ul>\n<li><a href=\"https://httpd.apache.org/docs/2.4/zh-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">文档地址</a></li>\n</ul>\n<h2> Apache 配置</h2>\n<p>Apache 通过 conf 文件夹下的 httpd.conf 来配置。</p>\n<div class=\"language-apacheconf line-numbers-mode\" data-ext=\"apacheconf\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<h3> ServerRoot</h3>\n<p>指定服务器的根目录</p>\n</li>\n<li>\n<h3> Listen</h3>\n<p>指定服务器监听的 IP 与 port</p>\n</li>\n<li>\n<h3> LoadModule</h3>\n<p>加载指定的模块来使服务器调用</p>\n</li>\n<li>\n<h3> PHPIniDir</h3>\n<p>指定 PHP 目录</p>\n</li>\n<li>\n<h3> unixd_module</h3>\n<p>分配用户权限</p>\n</li>\n<li>\n<h3> ServerAdmin</h3>\n<p>服务器管理员</p>\n</li>\n<li>\n<h3> ServerName</h3>\n<p>服务器名称</p>\n</li>\n</ul>\n",
      "date_published": "2020-06-07T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "服务器"
      ]
    },
    {
      "title": "Express",
      "url": "https://harryxiong24.github.io/zh/back-end/express/express.html",
      "id": "https://harryxiong24.github.io/zh/back-end/express/express.html",
      "summary": "[[toc]] 1.引入express 热部署服务器 node.js热部署,修改后立刻重启服务器cnpm install -g supervisor,全局安装后运行supervisor app.js(假设Node.js程序主入口是app.js); 热部署第二种方法为cnpm install nodemon -g,全局安装后运行nodemon app.j...",
      "content_html": "<h1> Express</h1>\n\n<h2> 1.引入express</h2>\n<div class=\"language-text\" data-ext=\"text\"></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>热部署服务器</strong></p>\n<ul>\n<li>\n<p>node.js热部署,修改后立刻重启服务器<code>cnpm install -g supervisor</code>,全局安装后运行<code>supervisor app.js</code>(假设Node.js程序主入口是app.js)</p>\n</li>\n<li>\n<p>热部署第二种方法为<code>cnpm install nodemon -g</code>,全局安装后运行<code>nodemon app.js</code>(假设Node.js程序主入口是app.js)</p>\n</li>\n<li>\n<p>在使用项目前可以先初始化项目使用<code>npm init -y</code></p>\n</li>\n</ul>\n<h2> 2.request请求</h2>\n<ul>\n<li>\n<p><strong>app.get(路由,回调函数)</strong>,回调函数在符合指定路径并且是get请求时触发</p>\n</li>\n<li>\n<p><strong>app.post(路由,回调函数)</strong>,回调函数在符合指定路径并且是post请求时触发</p>\n</li>\n<li>\n<p><strong>app.use(路由,回调函数)</strong>,回调函数在符合指定路径并且不论请求方式是什么都会触发</p>\n</li>\n</ul>\n<div class=\"language-text\" data-ext=\"text\"></div><p><strong>获取post请求数据</strong></p>\n<p>express原生的post请求获取数据的方式很麻烦,所以推荐使用第三方的插件</p>\n<p>**注:**现在好像不需要这个现在这个插件就能使用,只需要设置<code>app.use(express.json())</code>就能获取到</p>\n<ul>\n<li>\n<p>formidable</p>\n<div class=\"language-text\" data-ext=\"text\"></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>body-parser</p>\n<div class=\"language-text\" data-ext=\"text\"></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>blueimp-md5</p>\n<div class=\"language-text\" data-ext=\"text\"></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>bcrypt</p>\n<div class=\"language-text\" data-ext=\"text\"></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<h2> 3.response回应</h2>\n<ul>\n<li>\n<p>**res.send(数据),<strong>作为结束响应的标志,该方法比元素的</strong>res.end()**方法更加强大,不只可以穿buffer数据和字符串,也可以直接传入对象和数组等值</p>\n</li>\n<li>\n<p>**res.sendFile(文件路径),**发送文件到客户端,参数是文件路径</p>\n</li>\n<li>\n<p>**res.json(json对象),**express封装过的方法,可以直接返回给前端一个json格式的对象字符串</p>\n</li>\n<li>\n<p>res.render(传入的模板页面,传入ejs页面的参数对象)</p>\n<p>,专门用来渲染</p>\n<p>views目录(这是必须的)</p>\n<p>下的ejs文件的方法</p>\n<p>在这里使用ejs模板引擎</p>\n<p>注:</p>\n<p>也可使用</p>\n<p><a href=\"http://aui.github.io/art-template/zh-cn/docs/syntax.html#%E6%A8%A1%E6%9D%BF%E7%BB%A7%E6%89%BF\" target=\"_blank\" rel=\"noopener noreferrer\">art-template模板引擎</a></p>\n<div class=\"language-text\" data-ext=\"text\"></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<h2> 4.cookie和session</h2>\n<h3> 4.1 cookie</h3>\n<p><strong>在路由的response中可以使用下面的cookie方法进行对cookie的设置</strong></p>\n<ul>\n<li>\n<p>res.cookie(name,value,[option]):</p>\n<p>设置Cookie</p>\n<p>opition包括:</p>\n<p>domain / expires / httpOnly / maxAge / path / secure / signed</p>\n<div class=\"language-text\" data-ext=\"text\"></div></li>\n<li>\n<p>res.clearCookie():</p>\n<p>清除Cookie</p>\n<div class=\"language-text\" data-ext=\"text\"></div></li>\n</ul>\n<p><strong>获取cookies信息</strong></p>\n<p><strong>在express中获取cookies的信息需要使用对应的中间件cookie-parser</strong></p>\n<div class=\"language-text\" data-ext=\"text\"></div><div class=\"language-text\" data-ext=\"text\"></div><h3> 4.2 session</h3>\n<p><strong>在express设置和获取session需要使用中间件express-session</strong></p>\n<div class=\"language-text\" data-ext=\"text\"></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>**注意:**默认session数据是内存存储的,服务器一旦重启就会丢失,真正的生产环境会吧session进行持久化存储</p>\n<h3> 4.3 token</h3>\n<p><strong>在express中同样可以设置token来获取本地的存储信息,需要使用中间件jsonwebtoken</strong></p>\n<div class=\"language-text\" data-ext=\"text\"></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 5.路由分离</h2>\n<ul>\n<li>\n<p>常规写法</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text\" data-ext=\"text\"></div></li>\n<li>\n<p>express的router写法(express推荐)</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text\" data-ext=\"text\"></div></li>\n</ul>\n<h2> 6.中间件</h2>\n<p>中间件的本质就是一个请求处理方法,我们把用户从请求到响应的整个过程分发到多个中间件中去处理,这样做的目的是提高代码的灵活性,动态可扩展的</p>\n<h3> 6.1 应用程序级别中间件</h3>\n<p><strong>中间件的处理顺序是从上到下依次处理,而且相同的请求路径中的参数属性一致,所以才说第三方中间件必须要写在所有路由请求前,因为这样就能用中间件的各种查询了</strong></p>\n<ul>\n<li>\n<p>万能匹配的中间件(不关心任何请求路径和请求方法),全部都能匹配</p>\n<p>注:</p>\n<p>第三方中间件常常就是这种万能匹配能够匹配到所有的路径</p>\n<div class=\"language-text\" data-ext=\"text\"></div></li>\n<li>\n<p>匹配所有以</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>开头的</p>\n<div class=\"language-text\" data-ext=\"text\"></div></li>\n</ul>\n<h3> 6.2 路由级别中间件</h3>\n<ul>\n<li>\n<p>get</p>\n<div class=\"language-text\" data-ext=\"text\"></div></li>\n<li>\n<p>post:</p>\n<div class=\"language-text\" data-ext=\"text\"></div></li>\n<li>\n<p>put:</p>\n<div class=\"language-text\" data-ext=\"text\"></div></li>\n<li>\n<p>delete:</p>\n<div class=\"language-text\" data-ext=\"text\"></div></li>\n</ul>\n<p>**注意:**路由的中间件也是有next的,如果不调用就不会执行后续中间件,但是因为路由一般都只进入一个中间件,所有一般没有写next参数,但是如果写两个相同的路由,就必须写next才会从前面一个路由进入后面一个路由</p>\n<h3> 6.3 错误处理中间件</h3>\n<p><strong>可以在所有的路最后写入一个错误处理中间件,只要遇到错误就会直接跳到这个错误处理中间中.不必每一个路由就要进行专门的错误处理</strong></p>\n<p>**注意:**只要向路由中的第三个形参传入值,就可以直接找到有四个参数的中间件</p>\n<div class=\"language-text\" data-ext=\"text\"></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当然，我们可以自定义错误处理的中间件，比如使用一个函数来进行包装（比如使用promise时）</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text\" data-ext=\"text\"></div><p><strong>当然，这样每次调用还是很麻烦，最后的方法是使用<code>express-async-errors</code>来帮忙处理异常。</strong></p>\n<div class=\"language-text\" data-ext=\"text\"></div>",
      "date_published": "2020-06-09T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Nodejs"
      ]
    },
    {
      "title": "Nginx",
      "url": "https://harryxiong24.github.io/zh/back-end/nginx/nginx.html",
      "id": "https://harryxiong24.github.io/zh/back-end/nginx/nginx.html",
      "summary": "Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。 其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。",
      "content_html": "<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。 其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。</p>\n<!-- more -->\n<h2> 启动，停止和重新加载配置</h2>\n<p>要启动 nginx，请运行可执行文件。 一旦启动 nginx，就可以通过使用 <code>-s</code> 参数调用可执行文件来对其进行控制。使用以下语法:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>其中 <code>signal</code> 可能是以下之一:</p>\n<ul>\n<li>stop - 快速关机</li>\n<li>quit — 正常关机</li>\n<li>reload — 重新加载配置文件</li>\n<li>reopen — 重新打开日志文件</li>\n</ul>\n<h2> 配置文件的结构</h2>\n<p>nginx 由受配置文件中指定的指令控制的模块组成。 指令分为简单指令和块指令。 一个简单的指令由名称和参数组成，这些名称和参数之间用空格分隔，并以分号(<code>;</code>)结尾。 块指令的结构与简单指令的结构相同，但是它不以分号结尾，而是带有一组用括号 (<code>{</code> 和 <code>}</code>) 括起来的附加指令。 如果一个块指令在括号内可以有其他指令，则称为 context (例如: <code>events</code>, <code>http</code>, <code>server</code> 和 <code>location</code>)。</p>\n<p>放置在任何 context 外部的配置文件中的指令都被视为在 main context 中。 <code>events</code> 和 <code>http</code> 指令位于 <code>main</code> context 中，<code>server</code> 位于 <code>http</code> 中, 并且 <code>location</code> 在 <code>server</code> 中</p>\n<p><code>#</code> 号后的其余行被视为注释。</p>\n<h2> 提供静态内容</h2>\n<p>Web 服务器的一项重要任务是分发文件(例如图像或静态 HTML 页面)。 您将实现一个示例，其中将根据请求从不同的本地目录提供文件: <code>/data/www</code> (可能包含 HTML 文件)和 <code>/data/images</code>(包含图像)。 这将需要编辑配置文件，并在带有两个位置块的 http 块内设置服务器块。</p>\n<p>首先，创建 <code>/data/www</code> 目录，并将包含任何文本内容的 index.html 文件放入其中，并创建 <code>/data/images</code> 目录并将一些图像放入其中。</p>\n<p>接下来，打开配置文件。 默认配置文件已经包含了服务器块的几个示例，大部分已被注释掉。 现在，注释掉所有这些块并启动一个新的服务器块:</p>\n<div class=\"language-nginx\" data-ext=\"nginx\"></div><p>通常，配置文件可以包括几个服务器块，这些服务器块通过它们侦听的端口和服务器名称来区分。 一旦 nginx 决定了哪个服务器处理请求，它就会根据服务器块内定义的 location 指令的参数测试请求标头中指定的 URI。</p>\n<p>将以下位置块添加到服务器块:</p>\n<div class=\"language-nginx\" data-ext=\"nginx\"></div><p>与请求中的 URI 相比，此位置块指定 “<code>/</code>” 前缀。 对于匹配的请求，URI 将被添加到 root 指令中指定的路径，即 <code>/data/www</code>，以形成本地文件系统上所请求文件的路径。 如果有多个匹配的位置块，nginx 将选择前缀最长的位置块。 上面的位置块提供了最短的前缀，长度为 1，因此，只有在所有其他位置块均未提供匹配项时，才会使用该块。</p>\n<p>接下来，添加第二个位置块:</p>\n<div class=\"language-nginx\" data-ext=\"nginx\"></div><p>这将匹配以 <code>/images/</code> 开头的请求(位置 <code>/</code> 也匹配此类请求，但前缀较短)。</p>\n<p>服务器块的最终配置应如下所示:</p>\n<div class=\"language-nginx\" data-ext=\"nginx\"></div><p>这已经是服务器的工作配置，可以在标准端口 <code>80</code> 上侦听，并且可以在本地计算机上的 <code>http://localhost/</code> 上访问。 响应以 <code>/images/</code> 开头的 URI 请求，服务器将从 <code>/data/images</code> 目录中发送文件。 例如，为响应 <code>http://localhost/images/example.png</code> 请求，nginx 将发送文件 <code>/data/images/example.png</code>。 如果该文件不存在，nginx 将发送一个注明 404 错误的响应。 URI 不以 <code>/images/</code> 开头的请求将被映射到 <code>/data/www</code> 目录。 例如，nginx 会响应 <code>http://localhost/some/example.html</code> 请求发送 <code>/data/www/some/example.html</code> 文件。</p>\n<p>要应用新配置，请启动 nginx(如果尚未启动)，或通过执行以下命令向 nginx 的主进程发送 <code>reload</code>信号:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>如果某些东西无法按预期工作，则可以尝试在目录 <code>/usr/local/nginx/logs</code> 或目录 <code>/var/log/nginx</code> 中的 access.log 和 error.log 文件中找出原因。。</p>\n<h2> 设置简单的代理服务器</h2>\n<p>nginx 的一种常用用法是将其设置为代理服务器，这意味着服务器可以接收请求，将请求传递给代理服务器，从请求中检索响应并将它们发送给客户端。</p>\n<p>我们将配置一个基本的代理服务器，该服务器为图像请求和本地目录中的文件提供服务，并将所有其他请求发送到代理服务器。 在此示例中，两个服务器都将在单个 nginx 实例上定义。</p>\n<p>首先，通过向 nginx 的配置文件中添加另一个 <code>server</code> 块来定义代理服务器，其内容如下:</p>\n<div class=\"language-nginx\" data-ext=\"nginx\"></div><p>这将是一个简单的服务器，它在端口 8080 上侦听 (以前，自从使用标准端口 80 以来，未指定 listen 指令) 并将所有请求映射到本地文件系统的 <code>/data/up1</code> 目录中。创建此目录，并将 <code>index.html</code> 文件放入其中。 请注意，根指令位于服务器上下文中。 当选择用于服务请求的位置块不包括自己的根指令时，将使用这种根指令。</p>\n<p>接下来，使用上一部分中的服务器配置并对其进行修改以使其成为代理服务器配置。 在第一个位置块中，将 <code>proxy_pass</code> 指令与参数中指定的代理服务器的协议，名称和端口放在一起 (在本例中为 <code>http://localhost:8080</code> ):</p>\n<div class=\"language-nginx\" data-ext=\"nginx\"></div><p>我们将修改第二个 location 块，该位置块当前将带有 <code>/images/</code> 前缀的请求映射到 <code>/data/images</code> 目录下的文件，以使其与具有典型文件扩展名的图像的请求相匹配。 修改后的位置块如下所示:</p>\n<div class=\"language-nginx\" data-ext=\"nginx\"></div><p>该参数是一个正则表达式，它匹配以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的所有 URI。 正则表达式应以 <code>~</code> 开头。 相应的请求将被映射到 <code>/ data/images</code> 目录。</p>\n<p>当 nginx 选择一个 <code>location</code> 块来服务请求时，它首先检查指定前缀的 <code>location</code> 指令，记住带有最长前缀的 <code>location</code>，然后检查正则表达式。 如果存在与正则表达式匹配的内容，nginx 会选择该 “<code>location</code>”，否则，它将选择之前记住的位置。</p>\n<p>代理服务器的最终配置如下所示:</p>\n<div class=\"language-nginx\" data-ext=\"nginx\"></div><p>该服务器将过滤以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的请求，并将它们映射到目录 <code>/data/images</code>(通过将 URI 添加到根指令的参数)，并将所有其他请求传递给上面配置的代理服务器。</p>\n<p>要应用新配置，请按照前面几节的说明将重载信号发送到 nginx。</p>\n<p>还有许多其他指令可用于进一步配置代理连接。</p>\n<h2> 设置 FastCGI 代理</h2>\n<p>nginx 可用于将请求路由到 FastCGI 服务器，该服务器运行使用各种框架和编程语言 (例如 PHP) 构建的应用程序。</p>\n<p>与 FastCGI 服务器一起使用的最基本的 Nginx 配置包括使用 <code>fastcgi_pass</code> 指令而不是 <code>proxy_pass</code> 指令和 <code>fastcgi_param</code> 指令来设置传递给 FastCGI 服务器的参数。 假设 FastCGI 服务器可以在 <code>localhost:9000</code> 上访问。 以上一节中的代理配置为基础，用 <code>fastcgi_pass</code> 指令替换 <code>proxy_pass</code> 指令，并将参数更改为 <code>localhost:9000</code>。 在 PHP 中， <code>SCRIPT_FILENAME</code> 参数用于确定脚本名称，而 <code>QUERY_STRING</code> 参数用于传递请求参数。 配置的结果为:</p>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这将设置一个服务器，该服务器将通过 FastCGI 协议将除静态图像请求以外的所有请求路由到运行在 <code>localhost:9000</code> 上的代理服务器。</p>\n<h2> 官方文档</h2>\n<ul>\n<li><a href=\"https://docs.nginx.com/nginx/admin-guide/\" target=\"_blank\" rel=\"noopener noreferrer\">点击此处</a></li>\n</ul>\n",
      "date_published": "2020-06-07T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "服务器"
      ]
    },
    {
      "title": "大后端学习路线",
      "url": "https://harryxiong24.github.io/zh/back-end/preface/",
      "id": "https://harryxiong24.github.io/zh/back-end/preface/",
      "summary": "展示一下大后端学习路线 路漫漫其修远兮, 不要害怕 backEnd !!backEnd (../img/operation.png)",
      "content_html": "<h1> 大后端学习路线</h1>\n<p>展示一下大后端学习路线</p>\n<p>路漫漫其修远兮, 不要害怕</p>\n<p></p>\n<p>!</p>\n",
      "date_published": "2020-06-05T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "Servlet & JSP",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/",
      "summary": "Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态Web内容。 狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将...",
      "content_html": "<h1> Servlet &amp; JSP</h1>\n<p>Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态Web内容。</p>\n<p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p>\n<p>最早支持Servlet标准的是JavaSoft的Java Web Server，此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。</p>\n",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "1.Servlet简介",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/s1.html",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/s1.html",
      "summary": "Servlet简介 1.1 认识Servlet Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 Java ...",
      "content_html": "<h2> Servlet简介</h2>\n<h3> 1.1 认识Servlet</h3>\n<p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>\n<p>使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p>\n<p>Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：</p>\n<ul>\n<li>性能明显更好。</li>\n<li>Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。</li>\n<li>Servlet 是独立于平台的，因为它们是用 Java 编写的。</li>\n<li>服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。</li>\n<li>Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。</li>\n</ul>\n<h3> 1.2 Servlet优势</h3>\n<p>Servlet 执行以下主要任务：</p>\n<ul>\n<li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li>\n<li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li>\n<li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li>\n<li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li>\n<li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li>\n</ul>\n<h3> 1.3 Servlet架构</h3>\n<p></p>\n",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "10.JSP",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/s10.html",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/s10.html",
      "summary": "JSP 10.1 JSP生命周期 理解JSP底层功能的关键就是去理解它们所遵守的生命周期。 JSP生命周期就是从创建到销毁的整个过程，类似于servlet生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。 以下是JSP生命周期中所走过的几个阶段： 编译阶段：; servlet容器编译servlet源文件，生成servlet类 初始...",
      "content_html": "<h2> JSP</h2>\n<h3> 10.1 JSP生命周期</h3>\n<p>理解JSP底层功能的关键就是去理解它们所遵守的生命周期。</p>\n<p>JSP生命周期就是从创建到销毁的整个过程，类似于servlet生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。</p>\n<p>以下是JSP生命周期中所走过的几个阶段：</p>\n<ul>\n<li>\n<p><strong>编译阶段：</strong></p>\n<p>servlet容器编译servlet源文件，生成servlet类</p>\n</li>\n<li>\n<p>初始化阶段：</p>\n<p>加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p>\n</li>\n<li>\n<p>执行阶段：</p>\n<p>调用与JSP对应的servlet实例的服务方法</p>\n</li>\n<li>\n<p>销毁阶段：</p>\n<p>调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p>\n</li>\n</ul>\n<p>很明显，JSP生命周期的四个主要阶段和servlet生命周期非常相似，下面给出图示：</p>\n<p></p>\n<h4> 10.1.1 JSP编译</h4>\n<p>当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。</p>\n<p>编译的过程包括三个步骤：</p>\n<ul>\n<li>解析JSP文件。</li>\n<li>将JSP文件转为servlet。</li>\n<li>编译servlet。</li>\n</ul>\n<h4> 10.1.2 JSP初始化</h4>\n<p>容器载入JSP文件后，它会在为请求提供任何服务前调用jspInit()方法。如果您需要执行自定义的JSP初始化任务，复写jspInit()方法就行了，就像下面这样：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><p>一般来讲程序只初始化一次，servlet也是如此。通常情况下您可以在jspInit()方法中初始化数据库连接、打开文件和创建查询表。</p>\n<h4> 10.1.3 JSP执行</h4>\n<p>这一阶段描述了JSP生命周期中一切与请求相关的交互行为，直到被销毁。</p>\n<p>当JSP网页完成初始化后，JSP引擎将会调用_jspService()方法。</p>\n<p>_jspService()方法需要一个HttpServletRequest对象和一个HttpServletResponse对象作为它的参数，就像下面这样：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><p>_jspService()方法在每个request中被调用一次并且负责产生与之相对应的response，并且它还负责产生所有7个HTTP方法的回应，比如GET、POST、DELETE等等。</p>\n<h4> 10.1.4 JSP清理</h4>\n<p>JSP生命周期的销毁阶段描述了当一个JSP网页从容器中被移除时所发生的一切。</p>\n<p>jspDestroy()方法在JSP中等价于servlet中的销毁方法。当您需要执行任何清理工作时复写jspDestroy()方法，比如释放数据库连接或者关闭文件夹等等。</p>\n<p>jspDestroy()方法的格式如下：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><h3> 10.2 JSP指令</h3>\n<h4> 10.2.1 指令</h4>\n<p>JSP指令用来设置整个JSP页面相关的属性，如网页的编码方式和脚本语言。</p>\n<p>语法格式如下：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>指令可以有很多个属性，它们以键值对的形式存在，并用逗号隔开。</p>\n<p>JSP中的三种指令标签：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>指令</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&lt;%@ page ... %&gt;</td>\n<td style=\"text-align:left\">定义网页依赖属性，比如脚本语言、error页面、缓存需求等等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;%@ include ... %&gt;</td>\n<td style=\"text-align:left\">包含其他文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;%@ taglib ... %&gt;</td>\n<td style=\"text-align:left\">引入标签库的定义</td>\n</tr>\n</tbody>\n</table>\n<h4> 10.2.2 Page指令</h4>\n<p>Page指令为容器提供当前页面的使用说明。一个JSP页面可以包含多个page指令。</p>\n<p>Page指令的语法格式：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>等价的XML格式：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p><strong>属性</strong></p>\n<p>下表列出与Page指令相关的属性：说</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>属性</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">buffer</td>\n<td style=\"text-align:left\">指定out对象使用缓冲区的大小</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">autoFlush</td>\n<td style=\"text-align:left\">控制out对象的 缓存区</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">contentType</td>\n<td style=\"text-align:left\">指定当前JSP页面的MIME类型和字符编码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">errorPage</td>\n<td style=\"text-align:left\">指定当JSP页面发生异常时需要转向的错误处理页面</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">isErrorPage</td>\n<td style=\"text-align:left\">指定当前页面是否可以作为另一个JSP页面的错误处理页面</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">extends</td>\n<td style=\"text-align:left\">指定servlet从哪一个类继承</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">import</td>\n<td style=\"text-align:left\">导入要使用的Java类</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">info</td>\n<td style=\"text-align:left\">定义JSP页面的描述信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">isThreadSafe</td>\n<td style=\"text-align:left\">指定对JSP页面的访问是否为线程安全</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">language</td>\n<td style=\"text-align:left\">定义JSP页面所用的脚本语言，默认是Java</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">session</td>\n<td style=\"text-align:left\">指定JSP页面是否使用session</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">isELIgnored</td>\n<td style=\"text-align:left\">指定是否执行EL表达式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">isScriptingEnabled</td>\n<td style=\"text-align:left\">确定脚本元素能否被使用</td>\n</tr>\n</tbody>\n</table>\n<h4> 10.2.3 Include指令</h4>\n<p>JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。</p>\n<p>Include指令的语法格式如下：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>Include指令中的文件名实际上是一个相对的URL。如果您没有给文件关联一个路径，JSP编译器默认在当前路径下寻找。</p>\n<p>等价的XML语法：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><h4> 10.2.4 Taglib指令</h4>\n<p>JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合。</p>\n<p>Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。</p>\n<p>Taglib指令的语法：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>uri属性确定标签库的位置，prefix属性指定标签库的前缀。</p>\n<p>等价的XML语法：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><h3> 10.3 JSP 动作元素</h3>\n<p>与JSP指令元素不同的是，JSP动作元素在请求处理阶段起作用。JSP动作元素是用XML语法写成的。</p>\n<p>利用JSP动作可以动态地插入文件、重用JavaBean组件、把用户重定向到另外的页面、为Java插件生成HTML代码。</p>\n<p>动作元素只有一种语法，它符合XML标准：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>动作元素基本上都是预定义的函数，JSP规范定义了一系列的标准动作，它用JSP作为前缀，可用的标准动作元素如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">语法</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">jsp:include</td>\n<td style=\"text-align:left\">在页面被请求的时候引入一个文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jsp:useBean</td>\n<td style=\"text-align:left\">寻找或者实例化一个JavaBean。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jsp:setProperty</td>\n<td style=\"text-align:left\">设置JavaBean的属性。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jsp:getProperty</td>\n<td style=\"text-align:left\">输出某个JavaBean的属性。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jsp:forward</td>\n<td style=\"text-align:left\">把请求转到一个新的页面。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jsp:plugin</td>\n<td style=\"text-align:left\">根据浏览器类型为Java插件生成OBJECT或EMBED标记。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jsp:element</td>\n<td style=\"text-align:left\">定义动态XML元素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jsp:attribute</td>\n<td style=\"text-align:left\">设置动态定义的XML元素属性。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jsp:body</td>\n<td style=\"text-align:left\">设置动态定义的XML元素内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jsp:text</td>\n<td style=\"text-align:left\">在JSP页面和文档中使用写入文本的模板</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h4> 10.3.1 常见的属性</h4>\n<p>所有的动作要素都有两个属性：id属性和scope属性。</p>\n<ul>\n<li>\n<p>id属性：</p>\n<p>id属性是动作元素的唯一标识，可以在JSP页面中引用。动作元素创建的id值可以通过PageContext来调用。</p>\n</li>\n<li>\n<p>scope属性：</p>\n<p>该属性用于识别动作元素的生命周期。 id属性和scope属性有直接关系，scope属性定义了相关联id对象的寿命。 scope属性有四个可能的值： (a) page, (b)request, (c)session, 和 (d) application。</p>\n</li>\n</ul>\n<hr>\n<h4> 10.3.2 <a href=\"jsp:include\">jsp:include</a>动作元素</h4>\n<p><a href=\"jsp:include\">jsp:include</a>动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>前面已经介绍过include指令，它是在JSP文件被转换成Servlet的时候引入文件，而这里的jsp:include动作不同，插入文件的时间是在页面被请求的时候。</p>\n<p>以下是include动作相关的属性列表。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">page</td>\n<td style=\"text-align:left\">包含在页面中的相对URL地址。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">flush</td>\n<td style=\"text-align:left\">布尔属性，定义在包含资源前是否刷新缓存区。</td>\n</tr>\n</tbody>\n</table>\n<h4> 10.3.3 <a href=\"jsp:useBean\">jsp:useBean</a>动作元素</h4>\n<p>jsp:useBean动作用来装载一个将在JSP页面中使用的JavaBean。</p>\n<p>这个功能非常有用，因为它使得我们既可以发挥Java组件重用的优势，同时也避免了损失JSP区别于Servlet的方便性。</p>\n<p>jsp:useBean动作最简单的语法为：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>在类载入后，我们既可以通过 jsp:setProperty 和 jsp:getProperty 动作来修改和检索bean的属性。</p>\n<p>以下是useBean动作相关的属性列表。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">class</td>\n<td style=\"text-align:left\">指定Bean的完整包名。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">type</td>\n<td style=\"text-align:left\">指定将引用该对象变量的类型。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">beanName</td>\n<td style=\"text-align:left\">通过 java.beans.Beans 的 instantiate() 方法指定Bean的名字。</td>\n</tr>\n</tbody>\n</table>\n<p>在给出具体实例前，让我们先来看下 jsp:setProperty 和 jsp:getProperty 动作元素：</p>\n<h4> 10.3.4 <a href=\"jsp:setProperty\">jsp:setProperty</a>动作元素</h4>\n<p>jsp:setProperty用来设置已经实例化的Bean对象的属性，有两种用法。首先，你可以在jsp:useBean元素的外面（后面）使用jsp:setProperty，如下所示：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>此时，不管jsp:useBean是找到了一个现有的Bean，还是新创建了一个Bean实例，jsp:setProperty都会执行。第二种用法是把jsp:setProperty放入jsp:useBean元素的内部，如下所示：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>此时，jsp:setProperty只有在新建Bean实例时才会执行，如果是使用现有实例则不执行jsp:setProperty。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">name</td>\n<td style=\"text-align:left\">name属性是必需的。它表示要设置属性的是哪个Bean。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">property</td>\n<td style=\"text-align:left\">property属性是必需的。它表示要设置哪个属性。有一个特殊用法：如果property的值是\"*\"，表示所有名字和Bean属性名字匹配的请求参数都将被传递给相应的属性set方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">value</td>\n<td style=\"text-align:left\">value 属性是可选的。该属性用来指定Bean属性的值。字符串数据会在目标类中通过标准的valueOf方法自动转换成数字、boolean、Boolean、 byte、Byte、char、Character。例如，boolean和Boolean类型的属性值（比如\"true\"）通过 Boolean.valueOf转换，int和Integer类型的属性值（比如\"42\"）通过Integer.valueOf转换。 　　value和param不能同时使用，但可以使用其中任意一个。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">param</td>\n<td style=\"text-align:left\">param 是可选的。它指定用哪个请求参数作为Bean属性的值。如果当前请求没有参数，则什么事情也不做，系统不会把null传递给Bean属性的set方法。因此，你可以让Bean自己提供默认属性值，只有当请求参数明确指定了新值时才修改默认属性值。</td>\n</tr>\n</tbody>\n</table>\n<h4> 10.3.5 <a href=\"jsp:getProperty\">jsp:getProperty</a>动作元素</h4>\n<p>jsp:getProperty动作提取指定Bean属性的值，转换成字符串，然后输出。语法格式如下：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>下表是与getProperty相关联的属性：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">name</td>\n<td style=\"text-align:left\">要检索的Bean属性名称。Bean必须已定义。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">property</td>\n<td style=\"text-align:left\">表示要提取Bean属性的值</td>\n</tr>\n</tbody>\n</table>\n<h4> 10.3.6 <a href=\"jsp:forward\">jsp:forward</a> 动作元素</h4>\n<p>jsp:forward动作把请求转到另外的页面。jsp:forward标记只有一个属性page。语法格式如下所示：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>以下是forward相关联的属性：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">page</td>\n<td style=\"text-align:left\">page属性包含的是一个相对URL。page的值既可以直接给出，也可以在请求的时候动态计算，可以是一个JSP页面或者一个 Java Servlet.</td>\n</tr>\n</tbody>\n</table>\n<h4> 10.3.7 <a href=\"jsp:plugin\">jsp:plugin</a>动作元素</h4>\n<p>jsp:plugin动作用来根据浏览器的类型，插入通过Java插件 运行Java Applet所必需的OBJECT或EMBED元素。</p>\n<p>如果需要的插件不存在，它会下载插件，然后执行Java组件。 Java组件可以是一个applet或一个JavaBean。</p>\n<p>plugin动作有多个对应HTML元素的属性用于格式化Java 组件。param元素可用于向Applet 或 Bean 传递参数。</p>\n<p>以下是使用plugin 动作元素的典型实例:</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>如果你有兴趣可以尝试使用applet来测试jsp:plugin动作元素，<code>&lt;fallback&gt;</code>元素是一个新元素，在组件出现故障的错误是发送给用户错误信息。</p>\n<hr>\n<h4> 10.3.8 <code>&lt;jsp:element&gt;</code> 、 <code>&lt;jsp:attribute&gt;</code>、 <code>&lt;jsp:body&gt;</code>动作元素</h4>\n<p><code>&lt;jsp:element&gt;</code> 、 <code>&lt;jsp:attribute&gt;</code>、 <code>&lt;jsp:body&gt;</code>动作元素动态定义XML元素。动态是非常重要的，这就意味着XML元素在编译时是动态生成的而非静态。</p>\n<p>以下实例动态定义了XML元素：</p>\n<div class=\"language-jsp line-numbers-mode\" data-ext=\"jsp\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行时生成HTML代码如下：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><h4> 10.3.9 <code>&lt;jsp:text&gt;</code>动作元素</h4>\n<p><code>&lt;jsp:text&gt;</code>动作元素允许在JSP页面和文档中使用写入文本的模板，语法格式如下：</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>以上文本模板不能包含其他元素，只能只能包含文本和EL表达式（注：EL表达式将在后续章节中介绍）。请注 意，在XML文件中，您不能使用表达式如 ${whatever &gt; 0}，因为&gt;符号是非法的。 你可以使用 ${whatever gt 0}表达式或者嵌入在一个CDATA部分的值。</p>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><p>如果你需要在 XHTML 中声明 DOCTYPE,必须使用到<code>&lt;jsp:text&gt;</code>动作元素，实例如下：</p>\n<div class=\"language-jsp line-numbers-mode\" data-ext=\"jsp\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>你可以对以上实例尝试使用 <code>&lt;jsp:text&gt;</code>及不使用该动作元素执行结果的区别。</p>\n<h3> 10.4 JSP 隐式对象</h3>\n<p>JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。</p>\n<p>JSP所支持的九大隐式对象：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>对象</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">request</td>\n<td style=\"text-align:left\"><strong>HttpServletRequest</strong>类的实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">response</td>\n<td style=\"text-align:left\"><strong>HttpServletResponse</strong>类的实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">out</td>\n<td style=\"text-align:left\"><strong>PrintWriter</strong>类的实例，用于把结果输出至网页上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">session</td>\n<td style=\"text-align:left\"><strong>HttpSession</strong>类的实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">application</td>\n<td style=\"text-align:left\"><strong>ServletContext</strong>类的实例，与应用上下文有关</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">config</td>\n<td style=\"text-align:left\"><strong>ServletConfig</strong>类的实例</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">pageContext</td>\n<td style=\"text-align:left\"><strong>PageContext</strong>类的实例，提供对JSP页面所有对象以及命名空间的访问</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">page</td>\n<td style=\"text-align:left\">类似于Java类中的this关键字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Exception</td>\n<td style=\"text-align:left\"><strong>Exception</strong>类的对象，代表发生错误的JSP页面中对应的异常对象</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h4> 10.4.1 request对象</h4>\n<p>request对象是javax.servlet.http.HttpServletRequest 类的实例。每当客户端请求一个JSP页面时，JSP引擎就会制造一个新的request对象来代表这个请求。</p>\n<p>request对象提供了一系列方法来获取HTTP头信息，cookies，HTTP方法等等。</p>\n<hr>\n<h4> 10.4.2 response对象</h4>\n<p>response对象是javax.servlet.http.HttpServletResponse类的实例。当服务器创建request对象时会同时创建用于响应这个客户端的response对象。</p>\n<p>response对象也定义了处理HTTP头模块的接口。通过这个对象，开发者们可以添加新的cookies，时间戳，HTTP状态码等等。</p>\n<hr>\n<h4> 10.4.3 out对象</h4>\n<p>out对象是 javax.servlet.jsp.JspWriter 类的实例，用来在response对象中写入内容。</p>\n<p>最初的JspWriter类对象根据页面是否有缓存来进行不同的实例化操作。可以在page指令中使用buffered='false'属性来轻松关闭缓存。</p>\n<p>JspWriter类包含了大部分java.io.PrintWriter类中的方法。不过，JspWriter新增了一些专为处理缓存而设计的方法。还有就是，JspWriter类会抛出IOExceptions异常，而PrintWriter不会。</p>\n<p>下表列出了我们将会用来输出boolean，char，int，double，Srtring，object等类型数据的重要方法：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>方法</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>out.print(dataType dt)</strong></td>\n<td style=\"text-align:left\">输出Type类型的值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>out.println(dataType dt)</strong></td>\n<td style=\"text-align:left\">输出Type类型的值然后换行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>out.flush()</strong></td>\n<td style=\"text-align:left\">刷新输出流</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h4> 10.4.4 session对象</h4>\n<p>session对象是 javax.servlet.http.HttpSession 类的实例。和Java Servlets中的session对象有一样的行为。</p>\n<p>session对象用来跟踪在各个客户端请求间的会话。</p>\n<hr>\n<h4> 10.4.5 application对象</h4>\n<p>application对象直接包装了servlet的ServletContext类的对象，是javax.servlet.ServletContext 类的实例。</p>\n<p>这个对象在JSP页面的整个生命周期中都代表着这个JSP页面。这个对象在JSP页面初始化时被创建，随着jspDestroy()方法的调用而被移除。</p>\n<p>通过向application中添加属性，则所有组成您web应用的JSP文件都能访问到这些属性。</p>\n<hr>\n<h4> 10.4.6 config对象</h4>\n<p>config对象是 javax.servlet.ServletConfig 类的实例，直接包装了servlet的ServletConfig类的对象。</p>\n<p>这个对象允许开发者访问Servlet或者JSP引擎的初始化参数，比如文件路径等。</p>\n<p>以下是config对象的使用方法，不是很重要，所以不常用：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><p>它返回包含在<code>&lt;servlet-name&gt;</code>元素中的servlet名字，注意，<code>&lt;servlet-name&gt;</code>元素在 WEB-INF\\web.xml 文件中定义。</p>\n<hr>\n<h4> 10.4.7 pageContext 对象</h4>\n<p>pageContext对象是javax.servlet.jsp.PageContext 类的实例，用来代表整个JSP页面。</p>\n<p>这个对象主要用来访问页面信息，同时过滤掉大部分实现细节。</p>\n<p>这个对象存储了request对象和response对象的引用。application对象，config对象，session对象，out对象可以通过访问这个对象的属性来导出。</p>\n<p>pageContext对象也包含了传给JSP页面的指令信息，包括缓存信息，ErrorPage URL,页面scope等。</p>\n<p>PageContext类定义了一些字段，包括PAGE_SCOPE，REQUEST_SCOPE，SESSION_SCOPE， APPLICATION_SCOPE。它也提供了40余种方法，有一半继承自javax.servlet.jsp.JspContext 类。</p>\n<p>其中一个重要的方法就是removeArribute()，它可接受一个或两个参数。比如，pageContext.removeArribute(\"attrName\")移除四个scope中相关属性，但是下面这种方法只移除特定scope中的相关属性：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><hr>\n<h4> 10.4.8 page 对象</h4>\n<p>这个对象就是页面实例的引用。它可以被看做是整个JSP页面的代表。</p>\n<p>page 对象就是this对象的同义词。</p>\n<hr>\n<h4> 10.4.9 exception 对象</h4>\n<p>exception 对象包装了从先前页面中抛出的异常信息。它通常被用来产生对出错条件的适当响应。</p>\n<h3> 10.5 EL语法</h3>\n<h4> 10.5.1 语法格式</h4>\n<p><strong>${ expression }</strong></p>\n<p>要在页面中输出，则可用${}</p>\n<p>{“Hello World”}</p>\n<h4> 10.5.2 EL隐含对象</h4>\n<p></p>\n<h3> 10.6 JSTL</h3>\n<h4> 10.6.1 引入</h4>\n<div class=\"language-jsp\" data-ext=\"jsp\"></div><h4> 10.6.2 常用标签</h4>\n<p><code>&lt;c:out&gt;</code>\t用于在JSP中显示数据，就像&lt;%= ... &gt;\n<code>&lt;c:set&gt;</code>\t用于保存数据\n<code>&lt;c:remove&gt;</code>\t用于删除数据\n<code>&lt;c:catch&gt;</code>\t用来处理产生错误的异常状况，并且将错误信息储存起来\n<code>&lt;c:if&gt;</code>\t与我们在一般程序中用的if一样\n<code>&lt;c:choose&gt;</code>\t本身只当做<code>&lt;c:when&gt;</code>和<code>&lt;c:otherwise&gt;</code>的父标签\n<code>&lt;c:when&gt;</code>\t<code>&lt;c:choose&gt;</code>的子标签，用来判断条件是否成立\n<code>&lt;c:otherwise&gt;</code>\t<code>&lt;c:choose&gt;</code>的子标签，接在<code>&lt;c:when&gt;</code>标签后，当<code>&lt;c:when&gt;</code>标签判断为false时被执行\n<code>&lt;c:import&gt;</code>\t检索一个绝对或相对 URL，然后将其内容暴露给页面\n<code>&lt;c:forEach&gt;</code>\t基础迭代标签，接受多种集合类型\n<code>&lt;c:forTokens&gt;</code>\t根据指定的分隔符来分隔内容并迭代输出\n<code>&lt;c:param&gt;</code>\t用来给包含或重定向的页面传递参数\n<code>&lt;c:redirect&gt;</code>\t重定向至一个新的URL.\n<code>&lt;c:url&gt;</code>\t使用可选的查询参数来创造一个URL</p>\n",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "11.JDBC",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/s11.html",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/s11.html",
      "summary": "JDBC 11.1 注册Driver类实现对象 加载实现了java.sql.Driver接口的类的实例对象 Class.forName(“驱动类的完整类名”); 用DriverManager类的registerDriver方法注册 加载驱动程序，不同的数据库系统有不同的加载代码： MySQL数据库： Class.forName(“com.mysql.j...",
      "content_html": "<h2> JDBC</h2>\n<h3> 11.1 注册Driver类实现对象</h3>\n<p>加载实现了java.sql.Driver接口的类的实例对象</p>\n<p>Class.forName(“驱动类的完整类名”);</p>\n<p>用DriverManager类的registerDriver方法注册</p>\n<p>加载驱动程序，不同的数据库系统有不同的加载代码：\nMySQL数据库：\nClass.forName(“com.mysql.jdbc.Driver\");\nClass.forName(\"org.gjt.mm.mysql.Driver\");</p>\n<p>MS SQL Server\nClass.forName(\"com.microsoft.jdbc.sqlserver.SQLServerDriver\")</p>\n<p>Oracle\nClass.forName(“oracle.jdbc.driver.OracleDriver”);</p>\n<p>DB2\nClass.forName(“com.ibm.db2.jdbc.app.DB2Driver”);</p>\n<p>Access(使用ODBC)\nClass.forName(\"sun.jdbc.odbc.JdbcOdbcDriver\") ;</p>\n<p>Derby\nClass.forName(\"org.apache.derby.jdbc.ClientDriver\")</p>\n<h3> 11.2 获取Connection连接对象</h3>\n<p>用DriverManager类的getConection方法获取\n方法需要三个参数：url、数据库访问用户名与密码\nurl具有相对固定的格式，获取后将返回Connection对象</p>\n<h3> 11.3 关闭Connection连接对象</h3>\n<p>Connection对象close方法，注意处理异常</p>\n<h3> 11.4 使用步骤</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "2.Servlet生命周期",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/s2.html",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/s2.html",
      "summary": "Servlet生命周期 Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 通过调用 init () 方法进行初始化。; Servlet 调用 service() 方法来处理客户端的请求。; Servlet 通过调用 destroy() 方法终止（结束）。; 最后，Servlet 是由 JV...",
      "content_html": "<h2> Servlet生命周期</h2>\n<p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p>\n<ul>\n<li>\n<p>Servlet 通过调用 <strong>init ()</strong> 方法进行初始化。</p>\n</li>\n<li>\n<p>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</p>\n</li>\n<li>\n<p>Servlet 通过调用 <strong>destroy()</strong> 方法终止（结束）。</p>\n</li>\n<li>\n<p>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</p>\n</li>\n</ul>\n<h3> 2.1 生命周期架构图</h3>\n<p>下图显示了一个典型的 Servlet 生命周期方案。</p>\n<ul>\n<li>第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。</li>\n<li>Servlet 容器在调用 service() 方法之前加载 Servlet。</li>\n<li>然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。</li>\n</ul>\n<p></p>\n<h3> 2.2 init() 方法</h3>\n<p>init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。</p>\n<p>Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。</p>\n<p>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。</p>\n<p><strong>init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。</strong></p>\n<p>init 方法的定义如下：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><h3> 2.3 service() 方法</h3>\n<p>service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p>\n<p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。</p>\n<p>下面是该方法的特征：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><p>service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重载 doGet() 或 doPost() 即可。</p>\n<p>doGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。</p>\n<h3> 2.4 doGet() 方法</h3>\n<p>GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。</p>\n<div class=\"language-java\" data-ext=\"java\"></div><h3> 2.5 doPost() 方法</h3>\n<p>POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。</p>\n<div class=\"language-java\" data-ext=\"java\"></div><h3> 2.6 destroy() 方法</h3>\n<p><strong><code>destroy()</code> 方法只会被调用一次，在 Servlet 生命周期结束时被调用</strong></p>\n<p>destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。</p>\n<p>在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示：</p>\n<div class=\"language-java\" data-ext=\"java\"></div>",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "3.表单提交数据",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/s3.html",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/s3.html",
      "summary": "表单提交数据 3.1 使用表单的 GET 方法实例 下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 Servlet HelloForm 来处理输入。 action：对应的Servlet名字 method：处理的方法名 name：对应表单组件的名字，用来Servlet识别 保存这个 HTML 到 hello.htm 文件...",
      "content_html": "<h2> 表单提交数据</h2>\n<h3> 3.1 使用表单的 GET 方法实例</h3>\n<p>下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 Servlet HelloForm 来处理输入。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>action：对应的Servlet名字</strong></p>\n<p><strong>method：处理的方法名</strong></p>\n<p><strong>name：对应表单组件的名字，用来Servlet识别</strong></p>\n<p>保存这个 HTML 到 hello.htm 文件中。当您访问 <code>http://localhost:8080/Hello.html</code> 时，下面是上面表单的实际输出。</p>\n<p></p>\n<p>尝试输入名字和姓氏，然后点击\"提交\"按钮，在您本机上查看输出结果。基于所提供的输入，它会产生与上一个实例类似的结果。</p>\n<h3> 3.2 使用表单的 POST 方法实例</h3>\n<p>让我们对上面的 Servlet 做小小的修改，以便它可以处理 GET 和 POST 方法。下面的 <strong>HelloForm.java</strong> Servlet 程序使用 GET 和 POST 方法处理由 Web 浏览器给出的输入。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在，编译部署上述的 Servlet，并使用带有 POST 方法的 Hello.htm 进行测试，如下所示：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面是上面表单的实际输出，尝试输入名字和姓氏，然后点击\"提交\"按钮，在您本机上查看输出结果。</p>\n<p></p>\n<p>基于所提供的输入，它会产生与上一个实例类似的结果。</p>\n<h3> 3.3 将复选框数据传递到 Servlet 程序</h3>\n<p>当需要选择一个以上的选项时，则使用复选框。</p>\n<p>下面是一个 HTML 代码实例 CheckBox.htm，一个带有两个复选框的表单。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这段代码的结果是下面的表单：</p>\n<p></p>\n<p>下面是 CheckBox.java Servlet 程序，处理 Web 浏览器给出的复选框输入。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的实例将显示下面的结果：</p>\n<p>读取复选框数据**数学标识：<strong>on</strong>物理标识：<strong>null</strong>化学标识：**on</p>\n<h3> 3.4 读取所有的表单参数</h3>\n<p>以下是通用的实例，使用 HttpServletRequest 的 <code>getParameterNames()</code> 方法读取所有可用的表单参数。该方法返回一个枚举，其中包含未指定顺序的参数名。</p>\n<p>一旦我们有一个枚举，我们可以以标准方式循环枚举，使用 <code>hasMoreElements()</code> 方法来确定何时停止，使用 <em>nextElement()</em> 方法来获取每个参数的名称。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在，通过下面的表单尝试上面的 Servlet：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在使用上面的表单调用 Servlet，将产生以下结果：</p>\n<p><strong>读取所有的表单数据</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>参数值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>maths</td>\n<td>on</td>\n</tr>\n<tr>\n<td>chemistry</td>\n<td>on</td>\n</tr>\n</tbody>\n</table>\n<p>您可以尝试使用上面的 Servlet 来读取其他的表单数据，比如文本框、单选按钮或下拉框等。</p>\n",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "4.请求与响应",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/s4.html",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/s4.html",
      "summary": "请求与响应 4.1 理解 img 4.2 Request HttpServletRequest对象方法 序号 方法 & 描述 :--- :----------------------------------------------------------- 1 Cookie[] getCookies() 返回一个数组，包含客户端发送该请求的所有的 Co...",
      "content_html": "<h2> 请求与响应</h2>\n<h3> 4.1 理解</h3>\n<p></p>\n<h3> 4.2 Request</h3>\n<p>HttpServletRequest对象方法</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">方法 &amp; 描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"><strong>Cookie[] getCookies()</strong> 返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\"><strong>Enumeration getAttributeNames()</strong> 返回一个枚举，包含提供给该请求可用的属性名称。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"><strong>Enumeration getHeaderNames()</strong> 返回一个枚举，包含在该请求中包含的所有的头名。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\"><strong>Enumeration getParameterNames()</strong> 返回一个 String 对象的枚举，包含在该请求中包含的参数的名称。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\"><strong>HttpSession getSession()</strong> 返回与该请求关联的当前 session 会话，或者如果请求没有 session 会话，则创建一个。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\"><strong>HttpSession getSession(boolean create)</strong> 返回与该请求关联的当前 HttpSession，或者如果没有当前会话，且创建是真的，则返回一个新的 session 会话。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\"><strong>Locale getLocale()</strong> 基于 Accept-Language 头，返回客户端接受内容的首选的区域设置。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\"><strong>Object getAttribute(String name)</strong> 以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\"><strong>ServletInputStream getInputStream()</strong> 使用 ServletInputStream，以二进制数据形式检索请求的主体。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\"><strong>String getAuthType()</strong> 返回用于保护 Servlet 的身份验证方案的名称，例如，\"BASIC\" 或 \"SSL\"，如果JSP没有受到保护则返回 null。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\"><strong>String getCharacterEncoding()</strong> 返回请求主体中使用的字符编码的名称。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">12</td>\n<td style=\"text-align:left\"><strong>String getContentType()</strong> 返回请求主体的 MIME 类型，如果不知道类型则返回 null。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">13</td>\n<td style=\"text-align:left\"><strong>String getContextPath()</strong> 返回指示请求上下文的请求 URI 部分。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">14</td>\n<td style=\"text-align:left\"><strong>String getHeader(String name)</strong> 以字符串形式返回指定的请求头的值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\"><strong>String getMethod()</strong> 返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\"><strong>String getParameter(String name)</strong> 以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">17</td>\n<td style=\"text-align:left\"><strong>String getPathInfo()</strong> 当请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">18</td>\n<td style=\"text-align:left\"><strong>String getProtocol()</strong> 返回请求协议的名称和版本。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">19</td>\n<td style=\"text-align:left\"><strong>String getQueryString()</strong> 返回包含在路径后的请求 URL 中的查询字符串。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">20</td>\n<td style=\"text-align:left\"><strong>String getRemoteAddr()</strong> 返回发送请求的客户端的互联网协议（IP）地址。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">21</td>\n<td style=\"text-align:left\"><strong>String getRemoteHost()</strong> 返回发送请求的客户端的完全限定名称。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">22</td>\n<td style=\"text-align:left\"><strong>String getRemoteUser()</strong> 如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">23</td>\n<td style=\"text-align:left\"><strong>String getRequestURI()</strong> 从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">24</td>\n<td style=\"text-align:left\"><strong>String getRequestedSessionId()</strong> 返回由客户端指定的 session 会话 ID。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">25</td>\n<td style=\"text-align:left\"><strong>String getServletPath()</strong> 返回调用 JSP 的请求的 URL 的一部分。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">26</td>\n<td style=\"text-align:left\"><strong>String[] getParameterValues(String name)</strong> 返回一个字符串对象的数组，包含所有给定的请求参数的值，如果参数不存在则返回 null。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">27</td>\n<td style=\"text-align:left\"><strong>boolean isSecure()</strong> 返回一个布尔值，指示请求是否使用安全通道，如 HTTPS。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">28</td>\n<td style=\"text-align:left\"><strong>int getContentLength()</strong> 以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">29</td>\n<td style=\"text-align:left\"><strong>int getIntHeader(String name)</strong> 返回指定的请求头的值为一个 int 值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">30</td>\n<td style=\"text-align:left\"><strong>int getServerPort()</strong> 返回接收到这个请求的端口号。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">31</td>\n<td style=\"text-align:left\"><strong>setCharacterEncoding()</strong> 设置被发送到服务端的响应的字符编码。例如，UTF-8。</td>\n</tr>\n</tbody>\n</table>\n<h3> 4.3 response</h3>\n<p><strong>HttpServletResponse对象方法</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">方法 &amp; 描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"><strong>String encodeRedirectURL(String url)</strong> 为 sendRedirect 方法中使用的指定的 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\"><strong>String encodeURL(String url)</strong> 对包含 session 会话 ID 的指定 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"><strong>boolean containsHeader(String name)</strong> 返回一个布尔值，指示是否已经设置已命名的响应报头。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\"><strong>boolean isCommitted()</strong> 返回一个布尔值，指示响应是否已经提交。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\"><strong>void addCookie(Cookie cookie)</strong> 把指定的 cookie 添加到响应。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\"><strong>void addDateHeader(String name, long date)</strong> 添加一个带有给定的名称和日期值的响应报头。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\"><strong>void addHeader(String name, String value)</strong> 添加一个带有给定的名称和值的响应报头。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\"><strong>void addIntHeader(String name, int value)</strong> 添加一个带有给定的名称和整数值的响应报头。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\"><strong>void flushBuffer()</strong> 强制任何在缓冲区中的内容被写入到客户端。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\"><strong>void reset()</strong> 清除缓冲区中存在的任何数据，包括状态码和头。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\"><strong>void resetBuffer()</strong> 清除响应中基础缓冲区的内容，不清除状态码和头。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">12</td>\n<td style=\"text-align:left\"><strong>void sendError(int sc)</strong> 使用指定的状态码发送错误响应到客户端，并清除缓冲区。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">13</td>\n<td style=\"text-align:left\"><strong>void sendError(int sc, String msg)</strong> 使用指定的状态发送错误响应到客户端。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">14</td>\n<td style=\"text-align:left\"><strong>void sendRedirect(String location)</strong> 使用指定的重定向位置 URL 发送临时重定向响应到客户端。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\"><strong>void setBufferSize(int size)</strong> 为响应主体设置首选的缓冲区大小。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\"><strong>void setCharacterEncoding(String charset)</strong> 设置被发送到客户端的响应的字符编码（MIME 字符集）例如，UTF-8。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">17</td>\n<td style=\"text-align:left\"><strong>void setContentLength(int len)</strong> 设置在 HTTP Servlet 响应中的内容主体的长度，该方法设置 HTTP Content-Length 头。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">18</td>\n<td style=\"text-align:left\"><strong>void setContentType(String type)</strong> 如果响应还未被提交，设置被发送到客户端的响应的内容类型。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">19</td>\n<td style=\"text-align:left\"><strong>void setDateHeader(String name, long date)</strong> 设置一个带有给定的名称和日期值的响应报头。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">20</td>\n<td style=\"text-align:left\"><strong>void setHeader(String name, String value)</strong> 设置一个带有给定的名称和值的响应报头。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">21</td>\n<td style=\"text-align:left\"><strong>void setIntHeader(String name, int value)</strong> 设置一个带有给定的名称和整数值的响应报头。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">22</td>\n<td style=\"text-align:left\"><strong>void setLocale(Locale loc)</strong> 如果响应还未被提交，设置响应的区域。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">23</td>\n<td style=\"text-align:left\"><strong>void setStatus(int sc)</strong> 为该响应设置状态码。</td>\n</tr>\n</tbody>\n</table>\n<h3> 4.4 http状态码</h3>\n<h4> 4.4.1 状态码</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">代码</th>\n<th style=\"text-align:left\">消息</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">100</td>\n<td style=\"text-align:left\">Continue</td>\n<td style=\"text-align:left\">只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">101</td>\n<td style=\"text-align:left\">Switching Protocols</td>\n<td style=\"text-align:left\">服务器切换协议。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">200</td>\n<td style=\"text-align:left\">OK</td>\n<td style=\"text-align:left\">请求成功。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">201</td>\n<td style=\"text-align:left\">Created</td>\n<td style=\"text-align:left\">该请求是完整的，并创建一个新的资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">202</td>\n<td style=\"text-align:left\">Accepted</td>\n<td style=\"text-align:left\">该请求被接受处理，但是该处理是不完整的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">203</td>\n<td style=\"text-align:left\">Non-authoritative Information</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">204</td>\n<td style=\"text-align:left\">No Content</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">205</td>\n<td style=\"text-align:left\">Reset Content</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">206</td>\n<td style=\"text-align:left\">Partial Content</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">300</td>\n<td style=\"text-align:left\">Multiple Choices</td>\n<td style=\"text-align:left\">链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">301</td>\n<td style=\"text-align:left\">Moved Permanently</td>\n<td style=\"text-align:left\">所请求的页面已经转移到一个新的 URL。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">302</td>\n<td style=\"text-align:left\">Found</td>\n<td style=\"text-align:left\">所请求的页面已经临时转移到一个新的 URL。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">303</td>\n<td style=\"text-align:left\">See Other</td>\n<td style=\"text-align:left\">所请求的页面可以在另一个不同的 URL 下被找到。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">304</td>\n<td style=\"text-align:left\">Not Modified</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">305</td>\n<td style=\"text-align:left\">Use Proxy</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">306</td>\n<td style=\"text-align:left\"><em>Unused</em></td>\n<td style=\"text-align:left\">在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">307</td>\n<td style=\"text-align:left\">Temporary Redirect</td>\n<td style=\"text-align:left\">所请求的页面已经临时转移到一个新的 URL。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">400</td>\n<td style=\"text-align:left\">Bad Request</td>\n<td style=\"text-align:left\">服务器不理解请求。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">401</td>\n<td style=\"text-align:left\">Unauthorized</td>\n<td style=\"text-align:left\">所请求的页面需要用户名和密码。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">402</td>\n<td style=\"text-align:left\">Payment Required</td>\n<td style=\"text-align:left\"><em>您还不能使用该代码。</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">403</td>\n<td style=\"text-align:left\">Forbidden</td>\n<td style=\"text-align:left\">禁止访问所请求的页面。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">404</td>\n<td style=\"text-align:left\">Not Found</td>\n<td style=\"text-align:left\">服务器无法找到所请求的页面。.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">405</td>\n<td style=\"text-align:left\">Method Not Allowed</td>\n<td style=\"text-align:left\">在请求中指定的方法是不允许的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">406</td>\n<td style=\"text-align:left\">Not Acceptable</td>\n<td style=\"text-align:left\">服务器只生成一个不被客户端接受的响应。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">407</td>\n<td style=\"text-align:left\">Proxy Authentication Required</td>\n<td style=\"text-align:left\">在请求送达之前，您必须使用代理服务器的验证。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">408</td>\n<td style=\"text-align:left\">Request Timeout</td>\n<td style=\"text-align:left\">请求需要的时间比服务器能够等待的时间长，超时。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">409</td>\n<td style=\"text-align:left\">Conflict</td>\n<td style=\"text-align:left\">请求因为冲突无法完成。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">410</td>\n<td style=\"text-align:left\">Gone</td>\n<td style=\"text-align:left\">所请求的页面不再可用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">411</td>\n<td style=\"text-align:left\">Length Required</td>\n<td style=\"text-align:left\">\"Content-Length\" 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">412</td>\n<td style=\"text-align:left\">Precondition Failed</td>\n<td style=\"text-align:left\">请求中给出的先决条件被服务器评估为 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">413</td>\n<td style=\"text-align:left\">Request Entity Too Large</td>\n<td style=\"text-align:left\">服务器不接受该请求，因为请求实体过大。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">414</td>\n<td style=\"text-align:left\">Request-url Too Long</td>\n<td style=\"text-align:left\">服务器不接受该请求，因为 URL 太长。当您转换一个 \"post\" 请求为一个带有长的查询信息的 \"get\" 请求时发生。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">415</td>\n<td style=\"text-align:left\">Unsupported Media Type</td>\n<td style=\"text-align:left\">服务器不接受该请求，因为媒体类型不被支持。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">417</td>\n<td style=\"text-align:left\">Expectation Failed</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">500</td>\n<td style=\"text-align:left\">Internal Server Error</td>\n<td style=\"text-align:left\">未完成的请求。服务器遇到了一个意外的情况。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">501</td>\n<td style=\"text-align:left\">Not Implemented</td>\n<td style=\"text-align:left\">未完成的请求。服务器不支持所需的功能。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">502</td>\n<td style=\"text-align:left\">Bad Gateway</td>\n<td style=\"text-align:left\">未完成的请求。服务器从上游服务器收到无效响应。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">503</td>\n<td style=\"text-align:left\">Service Unavailable</td>\n<td style=\"text-align:left\">未完成的请求。服务器暂时超载或死机。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">504</td>\n<td style=\"text-align:left\">Gateway Timeout</td>\n<td style=\"text-align:left\">网关超时。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">505</td>\n<td style=\"text-align:left\">HTTP Version Not Supported</td>\n<td style=\"text-align:left\">服务器不支持\"HTTP协议\"版本。</td>\n</tr>\n</tbody>\n</table>\n<h4> 4.4.2 设置 HTTP 状态代码的方法</h4>\n<p>下面的方法可用于在 Servlet 程序中设置 HTTP 状态码。这些方法通过 <em>HttpServletResponse</em> 对象可用。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">方法 &amp; 描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"><strong>public void setStatus ( int statusCode )</strong> 该方法设置一个任意的状态码。setStatus 方法接受一个 int（状态码）作为参数。如果您的反应包含了一个特殊的状态码和文档，请确保在使用 <em>PrintWriter</em> 实际返回任何内容之前调用 setStatus。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\"><strong>public void sendRedirect(String url)</strong> 该方法生成一个 302 响应，连同一个带有新文档 URL 的 <em>Location</em> 头。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"><strong>public void sendError(int code, String message)</strong> 该方法发送一个状态码（通常为 404），连同一个在 HTML 文档内部自动格式化并发送到客户端的短消息。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>HTTP 状态码实例</strong></p>\n<p>下面的例子把 407 错误代码发送到客户端浏览器，浏览器会显示 \"Need authentication!!!\" 消息。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在，调用上面的 Servlet 将显示以下结果：</p>\n<p>HTTP Status 407 - Need authentication!!!<strong>type</strong> Status report<strong>message</strong> Need authentication!!!<strong>description</strong> The client must first authenticate itself with the proxy (Need authentication!!!).Apache Tomcat/5.5.29</p>\n",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "5.文件上传",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/s5.html",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/s5.html",
      "summary": "文件上传 5.1 创建一个文件上传表单 下面的 HTML 代码创建了一个文件上传表单。以下几点需要注意： 表单 method属性应该设置为 POST 方法，不能使用 GET 方法。; 表单 enctype 属性应该设置为 multipart/form-data.（关键，必须设置）; 表单 action 属性应该设置为在后端服务器上处理文件上传的 Ser...",
      "content_html": "<h2> 文件上传</h2>\n<h3> 5.1 创建一个文件上传表单</h3>\n<p>下面的 HTML 代码创建了一个文件上传表单。以下几点需要注意：</p>\n<ul>\n<li><strong>表单 method属性应该设置为 POST 方法，不能使用 GET 方法。</strong></li>\n<li><strong>表单 enctype 属性应该设置为 multipart/form-data.（关键，必须设置）</strong></li>\n<li>表单 <strong>action</strong> 属性应该设置为在后端服务器上处理文件上传的 Servlet 文件。下面的实例使用了 <strong>FileUpload</strong> Servlet 来上传文件。</li>\n<li>上传单个文件，您应该使用单个带有属性 type=\"file\" 的 <code>&lt;input .../&gt;</code> 标签。为了允许多个文件上传，请包含多个 name 属性值不同的 input 标签。输入标签具有不同的名称属性的值。浏览器会为每个 input 标签关联一个浏览按钮。</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 5.2 编写后台 Servlet</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 5.3 Part API</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>方法</strong></th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">write(String fileName)</td>\n<td style=\"text-align:center\">将文件内容写入指定的磁盘位置</td>\n<td style=\"text-align:center\">void</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getSize()</td>\n<td style=\"text-align:center\">获取上传文件的大小</td>\n<td style=\"text-align:center\">long</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getName()</td>\n<td style=\"text-align:center\">获取file控件的name属性</td>\n<td style=\"text-align:center\">String</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getHeader(String name)</td>\n<td style=\"text-align:center\">获取指定请求头</td>\n<td style=\"text-align:center\">String</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getHeaderNames()</td>\n<td style=\"text-align:center\">获取所有请求头的名称</td>\n<td style=\"text-align:center\">String</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getHeaders(String name)</td>\n<td style=\"text-align:center\">获取指定header名称的集合数据</td>\n<td style=\"text-align:center\">Collection&lt; String &gt;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getContentType()</td>\n<td style=\"text-align:center\">获取文件MIME类型</td>\n<td style=\"text-align:center\">String</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getInputStream()</td>\n<td style=\"text-align:center\">获取输入流用于检索文件的内容</td>\n<td style=\"text-align:center\">InputStream</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">delete()</td>\n<td style=\"text-align:center\">删除Part数据和临时目录数据,默认会删除</td>\n<td style=\"text-align:center\">void</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getSubmittedFileName()</td>\n<td style=\"text-align:center\">获取上传文件名Servlet3.1 Tomcat8.0实现</td>\n<td style=\"text-align:center\">String</td>\n</tr>\n</tbody>\n</table>\n<p>结合 HttpServletRequest 对象和@MultipartConfig 注解来处理文件上传.\n<strong>指定缓存大小和临时目录</strong>\n@MutipartConfig 可以设置 相应参数限制条件，必须声明，否则会报错</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">概述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">location</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">指定上传文件的临时目录，默认为\"\",绝对路径</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">fileSizeThreshold</td>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">指定缓存大小,超过会先存入临时目录,默认0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maxFileSize</td>\n<td style=\"text-align:center\">long</td>\n<td style=\"text-align:center\">单个上传文件最大大小,默认是-1,表示没有限制，单位:bytes</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maxRequestSize</td>\n<td style=\"text-align:center\">long</td>\n<td style=\"text-align:center\">限制该multipart/form-data请求中数据的大小,默认是-1，表示没有限制，单位:bytes</td>\n</tr>\n</tbody>\n</table>\n<p>FileSize表示上传的单个文件的大小，RequestSize表示一次上传的总的数据量，所以可以在一个表单中一次上传多个文件。</p>\n",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "6.网页跳转与重定向",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/s6.html",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/s6.html",
      "summary": "网页跳转与重定向 6.1 跳转 request.getRequestDispatcher(\"你要跳转的页面\").forward(request, response) 1. 属于转发，也是服务器跳转，相当于方法调用，在执行当前文件的过程中转向执行目标文件，两个文件(当前文件和目标文件)属于同一次请求，前后页共用一个request，可以通过此来传递一些数据...",
      "content_html": "<h2> 网页跳转与重定向</h2>\n<h3> 6.1 跳转</h3>\n<p><code>request.getRequestDispatcher(\"你要跳转的页面\").forward(request, response)</code></p>\n<ol>\n<li>\n<p>属于转发，也是服务器跳转，相当于方法调用，在执行当前文件的过程中转向执行目标文件，<strong>两个文件(当前文件和目标文件)属于同一次请求，前后页共用一个request，可以通过此来传递一些数据或者session信息，request.setAttribute()和request.getAttribute()。</strong></p>\n</li>\n<li>\n<p>在前后两次执行后，地址栏不变，仍是当前文件的地址。</p>\n</li>\n<li>\n<p><strong>不能转向到本web应用之外的页面和网站，所以转向的速度要快。</strong></p>\n</li>\n<li>\n<p>URL中所包含的“/”表示应用程序(项目)的路径。</p>\n</li>\n</ol>\n<h3> 6.2 重定向</h3>\n<p>当文档移动到新的位置，我们需要向客户端发送这个新位置时，我们需要用到网页重定向。当然，也可能是为了负载均衡，或者只是为了简单的随机，这些情况都有可能用到网页重定向。</p>\n<p>重定向请求到另一个网页的最简单的方式是使用 response 对象的 <code>sendRedirect()</code> 方法。</p>\n<p>下面是该方法的定义： 将请求重定向到另一页的最简单的方法是，用方法的<code>sendRedirect()</code>的响应对象。以下是这种方法的定义：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><p>该方法把响应连同状态码和新的网页位置发送回浏览器。您也可以通过把 setStatus() 和 setHeader() 方法一起使用来达到同样的效果：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><p>注意：</p>\n<ol>\n<li>\n<p>是客户端跳转，相当于客户端向服务端发送请求之后，服务器返回一个响应，客户端接收到响应之后又向服务端发送一次请求，一共是2次请求，前后页不共用一个request，不能读取转向前通过request.setAttribute()设置的属性值。</p>\n</li>\n<li>\n<p>在前后两次执行后，地址栏发生改变，是目标文件的地址。</p>\n</li>\n<li>\n<p>可以转向到本web应用之外的页面和网站，所以转向的速度相对要慢。</p>\n</li>\n<li>\n<p>URL种所包含的\"/\"表示根目录的路径。</p>\n</li>\n</ol>\n<p>特殊的应用：对数据进行修改、删除、添加操作的时候，应该用response.sendRedirect()。如果是采用了request.getRequestDispatcher().forward(request,response)，那么操作前后的地址栏都不会发生改变，仍然是修改的控制器，如果此时再对当前页面刷新的话，就会重新发送一次请求对数据进行修改，这也就是有的人在刷新一次页面就增加一条数据的原因。</p>\n",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "7.会话管理",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/s7.html",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/s7.html",
      "summary": "会话管理 7.1 Cookie 7.1.1 Servlet Cookie 方法 以下是在 Servlet 中操作 Cookie 时可使用的有用的方法列表。 序号 方法 & 描述 :--- :----------------------------------------------------------- 1 public void setDomai...",
      "content_html": "<h2> 会话管理</h2>\n<h3> 7.1 Cookie</h3>\n<h4> 7.1.1 Servlet Cookie 方法</h4>\n<p>以下是在 Servlet 中操作 Cookie 时可使用的有用的方法列表。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">方法 &amp; 描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"><strong>public void setDomain(String pattern)</strong> 该方法设置 cookie 适用的域，例如 runoob.com。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\"><strong>public String getDomain()</strong> 该方法获取 cookie 适用的域，例如 runoob.com。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"><strong>public void setMaxAge(int expiry)</strong> 该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\"><strong>public int getMaxAge()</strong> 该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\"><strong>public String getName()</strong> 该方法返回 cookie 的名称。名称在创建后不能改变。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\"><strong>public void setValue(String newValue)</strong> 该方法设置与 cookie 关联的值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\"><strong>public String getValue()</strong> 该方法获取与 cookie 关联的值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\"><strong>public void setPath(String uri)</strong> 该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\"><strong>public String getPath()</strong> 该方法获取 cookie 适用的路径。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\"><strong>public void setSecure(boolean flag)</strong> 该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\"><strong>public void setComment(String purpose)</strong> 设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">12</td>\n<td style=\"text-align:left\"><strong>public String getComment()</strong> 获取 cookie 的注释，如果 cookie 没有注释则返回 null。</td>\n</tr>\n</tbody>\n</table>\n<h4> 7.1.2 通过 Servlet 设置 Cookie</h4>\n<p>通过 Servlet 设置 Cookie 包括三个步骤：</p>\n<p>**(1) 创建一个 Cookie 对象：**您可以调用带有 cookie 名称和 cookie 值的 Cookie 构造函数，cookie 名称和 cookie 值都是字符串。</p>\n<div class=\"language-java\" data-ext=\"java\"></div><p>请记住，无论是名字还是值，都不应该包含空格或以下任何字符：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><p>**(2) 设置最大生存周期：**您可以使用 setMaxAge 方法来指定 cookie 能够保持有效的时间（以秒为单位）。下面将设置一个最长有效期为 24 小时的 cookie。</p>\n<div class=\"language-java\" data-ext=\"java\"></div><p>**(3) 发送 Cookie 到 HTTP 响应头：**您可以使用 <strong>response.addCookie</strong> 来添加 HTTP 响应头中的 Cookie，如下所示：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><h4> 7.1.3 通过 Servlet 读取 Cookie</h4>\n<p>要读取 Cookie，您需要通过调用 <code>HttpServletRequest</code> 的 <code>getCookies()</code> 方法创建一个 <code>javax.servlet.http.Cookie</code>对象的数组。然后循环遍历数组，并使用 getName() 和 getValue() 方法来访问每个 cookie 和关联的值。</p>\n<p>一般通过循环来遍历cookie</p>\n<div class=\"language-java\" data-ext=\"java\"></div><h4> 7.1.4 通过 Servlet 删除 Cookie</h4>\n<p>删除 Cookie 是非常简单的。如果您想删除一个 cookie，那么您只需要按照以下三个步骤进行：</p>\n<ul>\n<li>读取一个现有的 cookie，并把它存储在 Cookie 对象中。</li>\n<li>使用 <strong>setMaxAge()</strong> 方法设置 cookie 的年龄为零，来删除现有的 cookie。</li>\n<li>把这个 cookie 添加到响应头。</li>\n</ul>\n<h3> 7.2 Session</h3>\n<h4> 7.2.1 Seeion对象及其主要方法</h4>\n<p>Servlet 提供了 HttpSession 接口，该接口提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。</p>\n<p>Servlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。</p>\n<p>您会通过调用 HttpServletRequest 的公共方法 <strong>getSession()</strong> 来获取 HttpSession 对象，如下所示：</p>\n<div class=\"language-java\" data-ext=\"java\"></div><p>你需要在向客户端发送任何文档内容之前调用 <em>request.getSession()</em>。下面总结了 HttpSession 对象中可用的几个重要的方法：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">方法 &amp; 描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"><strong>public Object getAttribute(String name)</strong> 该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\"><strong>public Enumeration getAttributeNames()</strong> 该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"><strong>public long getCreationTime()</strong> 该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\"><strong>public String getId()</strong> 该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\"><strong>public long getLastAccessedTime()</strong> 该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\"><strong>public int getMaxInactiveInterval()</strong> 该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\"><strong>public void invalidate()</strong> 该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\"><strong>public boolean isNew()</strong> 如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\"><strong>public void removeAttribute(String name)</strong> 该方法将从该 session 会话移除指定名称的对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\"><strong>public void setAttribute(String name, Object value)</strong> 该方法使用指定的名称绑定一个对象到该 session 会话。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\"><strong>public void setMaxInactiveInterval(int interval)</strong> 该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。</td>\n</tr>\n</tbody>\n</table>\n<h4> 7.2.2 创建或读取Session会话</h4>\n<div class=\"language-java\" data-ext=\"java\"></div><h4> 7.2.3 删除 Session 会话数据</h4>\n<p>当您完成了一个用户的 session 会话数据，您有以下几种选择：</p>\n<ul>\n<li>**移除一个特定的属性：**您可以调用 <em>public void removeAttribute(String name)</em> 方法来删除与特定的键相关联的值。</li>\n<li>**删除整个 session 会话：**您可以调用 <em>public void invalidate()</em> 方法来丢弃整个 session 会话。</li>\n<li>**设置 session 会话过期时间：**您可以调用 <em>public void setMaxInactiveInterval(int interval)</em> 方法来单独设置 session 会话超时。</li>\n<li>**注销用户：**如果使用的是支持 servlet 2.4 的服务器，您可以调用 <strong>logout</strong> 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。</li>\n<li>**web.xml 配置：**如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：</li>\n</ul>\n<div class=\"language-xml\" data-ext=\"xml\"></div><p>上面实例中的超时时间是以分钟为单位，将覆盖 Tomcat 中默认的 30 分钟超时时间。</p>\n<p>在一个 Servlet 中的 getMaxInactiveInterval() 方法会返回 session 会话的超时时间，以秒为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么 getMaxInactiveInterval() 会返回 900。</p>\n",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "8.ServletContext",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/s8.html",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/s8.html",
      "summary": "ServletContext 8.1 概念 抽象表示Servlet的上下文环境，即当前Web应用，一个JVM中的每个Web应用都只有一个ServletContext对象与之对应 启动一个Web应用时会创建一个ServletContext对象，关闭时也会销毁此对象 8.2 方法 setAttribute与getAttribute方法 ServletCon...",
      "content_html": "<h2> ServletContext</h2>\n<h3> 8.1 概念</h3>\n<p>抽象表示Servlet的上下文环境，即当前Web应用，一个JVM中的每个Web应用都只有一个ServletContext对象与之对应</p>\n<p>启动一个Web应用时会创建一个ServletContext对象，关闭时也会销毁此对象</p>\n<h3> 8.2 方法</h3>\n<table>\n<thead>\n<tr>\n<th>setAttribute与getAttribute方法</th>\n<th>ServletContext对象的生命周期等同于Web服务器正常工作周期，需要长期保存的属性可保存在ServletContext对象中</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>getRequestDispatcher</strong></td>\n<td><strong>路径参数必须以“/”作为开头，表示应用程序环境的根目录 （对比request对象的该方法</strong>）</td>\n</tr>\n<tr>\n<td><strong>getResourcePaths</strong></td>\n<td><strong>获取Web应用中的某个路径下有哪些文件，路径参数必须以“/”开始</strong></td>\n</tr>\n<tr>\n<td><strong>getResourceAsStream</strong></td>\n<td><strong>读取Web应用中的某个文件，文件路径参数必须以“/”开始</strong></td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "9.过滤器",
      "url": "https://harryxiong24.github.io/zh/back-end/servlet/s9.html",
      "id": "https://harryxiong24.github.io/zh/back-end/servlet/s9.html",
      "summary": "过滤器 9.1 概念 Servlet 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。 可以将一个或多个 Servlet 过滤器附加到一个 Servlet 或一组 Servlet。Servlet 过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。调用 Servlet 前调用所有附加的 Ser...",
      "content_html": "<h2> 过滤器</h2>\n<h3> 9.1 概念</h3>\n<p>Servlet 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。</p>\n<p>可以将一个或多个 Servlet 过滤器附加到一个 Servlet 或一组 Servlet。Servlet 过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。调用 Servlet 前调用所有附加的 Servlet 过滤器。</p>\n<p>Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：</p>\n<ul>\n<li>在客户端的请求访问后端资源之前，拦截这些请求。</li>\n<li>在服务器的响应发送回客户端之前，处理这些响应。</li>\n</ul>\n<p>根据规范建议的各种类型的过滤器：</p>\n<ul>\n<li>身份验证过滤器（Authentication Filters）。</li>\n<li>数据压缩过滤器（Data compression Filters）。</li>\n<li>加密过滤器（Encryption Filters）。</li>\n<li>触发资源访问事件过滤器。</li>\n<li>图像转换过滤器（Image Conversion Filters）。</li>\n<li>日志记录和审核过滤器（Logging and Auditing Filters）。</li>\n<li>MIME-TYPE 链过滤器（MIME-TYPE Chain Filters）。</li>\n<li>标记化过滤器（Tokenizing Filters）。</li>\n<li>XSL/T 过滤器（XSL/T Filters），转换 XML 内容。</li>\n</ul>\n<p>过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到您的应用程序的部署描述符中的 Servlet 名称或 URL 模式。</p>\n<p>当 Web 容器启动 Web 应用程序时，它会为您在部署描述符中声明的每一个过滤器创建一个实例。</p>\n<p>Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前。</p>\n<h3> 9.2 使用</h3>\n<p><strong>编写Filter</strong>\n编写java类实现Filter接口，并实现其doFilter方法。</p>\n<p><strong>设置Filter</strong>\n使用注解：@WebFilter\n在 web.xml 文件中使用<code>&lt;filter&gt;</code>和<code>&lt;filter-mapping&gt;</code>元素对编写的filter类进行注册，并设置它所能拦截的资源。</p>\n<h3> 9.3 Servlet 过滤器方法</h3>\n<p>过滤器是一个实现了 javax.servlet.Filter 接口的 Java 类。javax.servlet.Filter 接口定义了三个方法：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">方法 &amp; 描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"><strong>public void doFilter (ServletRequest, ServletResponse, FilterChain)</strong> 该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\"><strong>public void init(FilterConfig filterConfig)</strong> web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"><strong>public void destroy()</strong> Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2020-06-24T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 后台"
      ]
    },
    {
      "title": "1.序言",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/",
      "summary": "简介 本教程系统的归纳和总结了从 JavaScript 到 ECMAScript 的重难点以及高阶使用方法。 目录 1. 序言 2. 基础关注点 3. 数据类型的检验和转换 4. 错误处理机制 5. Array 6. String 7. Object 8. Class 9. Symbol 10. 解构赋值 11. 新增运算符 12. 异步编程 13. ...",
      "content_html": "<h1> JavaScript 和 ECMAScript 进阶教程</h1>\n<h2> 简介</h2>\n<p>本教程系统的归纳和总结了从 JavaScript 到 ECMAScript 的重难点以及高阶使用方法。</p>\n<h2> 目录</h2>\n<ol>\n<li>序言</li>\n<li>基础关注点</li>\n<li>数据类型的检验和转换</li>\n<li>错误处理机制</li>\n<li>Array</li>\n<li>String</li>\n<li>Object</li>\n<li>Class</li>\n<li>Symbol</li>\n<li>解构赋值</li>\n<li>新增运算符</li>\n<li>异步编程</li>\n<li>Set</li>\n<li>Map</li>\n<li>Iterator</li>\n<li>异步遍历器</li>\n<li>Proxy</li>\n<li>Reflect</li>\n<li>Module 模块化</li>\n<li>模块加载的实现</li>\n<li>DOM</li>\n<li>DOM 事件</li>\n<li>BOM</li>\n<li>编程风格</li>\n<li>正则表达式</li>\n<li>标准对象库</li>\n</ol>\n<h2> 说明</h2>\n<p>本教程不会涉及 JavaScript 和 ECMAScript 基础知识，比如 JavaScript 的基本语法，变量定义，基本类型使用等基础知识，所以本教程适合具备一定 JavaScript 和 ECMAScript 基础知识的读者浏览，初学者建议先从入门教程开始阅读。</p>\n<p>本教程即可作为教程，也可以作为文档查阅。</p>\n<p>持续更新中...</p>\n<h2> 参考与引用</h2>\n<ol>\n<li>\n<p><a href=\"https://262.ecma-international.org/6.0/\" target=\"_blank\" rel=\"noopener noreferrer\">ECMAScript® 2015 Language Specification</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript 教程 MDN版</a></p>\n</li>\n<li>\n<p><a href=\"https://wangdoc.com/javascript/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript 教程 网道版</a></p>\n</li>\n<li>\n<p><a href=\"https://wangdoc.com/es6/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 教程 网道版</a></p>\n</li>\n<li>\n<p><a href=\"https://nodejs.org/en/docs/\" target=\"_blank\" rel=\"noopener noreferrer\">Node</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/airbnb/javascript\" target=\"_blank\" rel=\"noopener noreferrer\">Airbnb JavaScript Style Guide</a></p>\n</li>\n</ol>\n<h2> License</h2>\n<p>Copyright © 2021 <a href=\"https://github.com/HarryXiong24\" target=\"_blank\" rel=\"noopener noreferrer\">Harry Xiong</a>.</p>\n<p>This project is <a href=\"https://github.com/HarryXiong24/JavaScript-ECMAScript-Advanced-Guidebook/blob/master/LICENSE\" target=\"_blank\" rel=\"noopener noreferrer\">MIT</a> licensed.</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "10.解构赋值",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses10.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses10.html",
      "summary": "数组的解构赋值 基本用法 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 ES6 允许写成下面这样。 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面...",
      "content_html": "<h1> 解构赋值</h1>\n<h2> 数组的解构赋值</h2>\n<h3> 基本用法</h3>\n<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>\n<p>以前，为变量赋值，只能直接指定值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>ES6 允许写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>\n<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果解构不成功，变量的值就等于<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p>\n<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面两个例子，都属于不完全解构，但是可以成功。</p>\n<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p>\n<p>对于 Set 结构，也可以使用数组的解构赋值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>fibs</code>是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p>\n<h3> 默认值</h3>\n<p>解构赋值允许指定默认值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p>\n<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面的代码其实等价于下面的代码。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面最后一个表达式之所以会报错，是因为<code>x</code>用<code>y</code>做默认值时，<code>y</code>还没有声明。</p>\n<h2> 对象的解构赋值</h2>\n<h3> 简介</h3>\n<p>解构不仅可以用于数组，还可以用于对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p>\n<p>如果解构失败，变量的值等于<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，等号右边的对象没有<code>foo</code>属性，所以变量<code>foo</code>取不到值，所以等于<code>undefined</code>。</p>\n<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的例一将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将<code>console.log</code>赋值到<code>log</code>变量。</p>\n<p>如果变量名与属性名不一致，必须写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>\n<p>与数组一样，解构也可以用于嵌套结构的对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面是另一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码有三次解构赋值，分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值。注意，最后一次对<code>line</code>属性的解构赋值之中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量。</p>\n<p>下面是嵌套赋值的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错。</p>\n<p>注意，对象的解构赋值可以取到继承的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>obj1</code>的原型对象是<code>obj2</code>。<code>foo</code>属性不是<code>obj1</code>自身的属性，而是继承自<code>obj2</code>的属性，解构赋值可以取到这个属性。</p>\n<h3> 默认值</h3>\n<p>对象的解构也可以指定默认值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，属性<code>x</code>等于<code>null</code>，因为<code>null</code>与<code>undefined</code>不严格相等，所以是个有效的赋值，导致默认值<code>3</code>不会生效。</p>\n<h3> 注意点</h3>\n<p><strong>（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的写法会报错，因为 JavaScript 引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p>\n<p><strong>（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p>\n<p><strong>（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code>。方括号这种写法，属于“属性名表达式”。</p>\n<h2> 字符串的解构赋值</h2>\n<p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 数值和布尔值的解构赋值</h2>\n<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>\n<p><strong>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 函数参数的解构赋值</h2>\n<p><strong>函数的参数也可以使用解构赋值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p>\n<p>下面是另一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>函数参数的解构也可以使用默认值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p>\n<p>注意，下面的写法会得到不一样的结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p>\n<p><code>undefined</code>就会触发函数参数的默认值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 圆括号问题</h2>\n<p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>\n<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>\n<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>\n<h3> 不能使用圆括号的情况</h3>\n<p>以下三种解构赋值不得使用圆括号。</p>\n<h4> 变量声明语句</h4>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p>\n<h4> 函数参数</h4>\n<p>函数参数也属于变量声明，因此不能带有圆括号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 赋值语句的模式</h4>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将整个模式放在圆括号之中，导致报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将一部分模式放在圆括号之中，导致报错。</p>\n<h3> 可以使用圆括号的情况</h3>\n<p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。</p>\n<h2> 用途</h2>\n<p>变量的解构赋值用途很多。</p>\n<h3> 交换变量的值</h3>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>\n<h3> 函数返回多个值</h3>\n<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 函数参数的定义</h3>\n<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 提取 JSON 数据</h3>\n<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码可以快速提取 JSON 数据的值。</p>\n<h3> 函数参数的默认值</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || 'default foo';</code>这样的语句。</p>\n<h3> 遍历 Map 结构</h3>\n<p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 输入模块的指定方法</h3>\n<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "11.新增运算符",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses11.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses11.html",
      "summary": "数组的扩展运算符 理解 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 更好的理解是，…args 就是把args中的数据一项一项取出来。 这里有一个例子可以很好的理解...args。 我们传入的参数是1, 2, 3，意味着...args的等于是1, 2, 3。又因为之前说过…args ...",
      "content_html": "<h1> 新增运算符</h1>\n<h2> 数组的扩展运算符</h2>\n<h3> 理解</h3>\n<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>更好的理解是，<code>…args</code> 就是把<code>args</code>中的数据一项一项取出来。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这里有一个例子可以很好的理解<code>...args</code>。</p>\n<p>我们传入的参数是<code>1, 2, 3</code>，意味着<code>...args</code>的等于是<code>1, 2, 3</code>。又因为之前说过<code>…args</code> 就是把<code>args</code>中的数据一项一项取出来，所以反推<code>args</code>的值就为 <code>[ 1, 2, 3 ]</code>。</p>\n<h3> 基本用法</h3>\n<p>该运算符主要用于函数调用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>\n<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>扩展运算符后面还可以放置表达式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。</p>\n<h3> 替代函数的 apply 方法</h3>\n<p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用<code>Math.max</code>函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用<code>Math.max</code>了。</p>\n<p>另一个例子是通过<code>push</code>函数，将一个数组添加到另一个数组的尾部。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的 ES5 写法中，<code>push</code>方法的参数不能是数组，所以只好通过<code>apply</code>方法变通使用<code>push</code>方法。有了扩展运算符，就可以直接将数组传入<code>push</code>方法。</p>\n<p>下面是另外一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 扩展运算符的应用</h3>\n<h4> 复制数组</h4>\n<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>a2</code>并不是<code>a1</code>的克隆，而是指向同一份数据的另一个指针。修改<code>a2</code>，会直接导致<code>a1</code>的变化。</p>\n<p>ES5 只能用变通方法来复制数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>a1</code>会返回原数组的克隆，再修改<code>a2</code>就不会对<code>a1</code>产生影响。</p>\n<p>扩展运算符提供了复制数组的简便写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的两种写法，<code>a2</code>都是<code>a1</code>的克隆。</p>\n<h4> 合并数组</h4>\n<p>扩展运算符提供了数组合并的新写法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>a3</code>和<code>a4</code>是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。</p>\n<h4> 与解构赋值结合</h4>\n<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是另外一些例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 字符串</h4>\n<p>扩展运算符还可以将字符串转为真正的数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果不用扩展运算符，字符串的<code>reverse</code>操作就不正确。</p>\n<h4> 实现了 Iterator 接口的对象</h4>\n<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>NodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了 Iterator 。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，先定义了<code>Number</code>对象的遍历器接口，扩展运算符将<code>5</code>自动转成<code>Number</code>实例以后，就会调用这个接口，就会返回自定义的结果。</p>\n<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组。</p>\n<h4> Map 和 Set 结构，Generator 函数</h4>\n<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<strong>变量<code>go</code>是一个 Generator 函数，执行后返回的是一个遍历器对象</strong>，<strong>对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组</strong>。</p>\n<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 对象的扩展运算符</h2>\n<p>之前已经介绍过扩展运算符（<code>...</code>）。ES2018 将这个运算符<a href=\"https://github.com/sebmarkbage/ecmascript-rest-spread\" target=\"_blank\" rel=\"noopener noreferrer\">引入</a>了对象。</p>\n<h3> 理解</h3>\n<p>可以与数组的扩展运算符有相同的理解，<code>…arg</code> 就是把<code>args</code>中的数据一项一项取出来。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这是一个对象拷贝的例子，可以很好的进行理解。</p>\n<p>首先打印变量<code>x</code>，结果是<code>{ a: 1, b: 2 }</code>，意味着<code>...x</code>可以看作是<code>a: 1, b: 2</code>，注意，这里和数组不同，这里是只是可以看作，因为属性脱离了对象并不能存在，所以打印<code>...x</code>，会立马报错。</p>\n<p>因此，在赋值的时候，我们需要在<code>...x</code>外面在包括一层<code>{}</code>，使得属性存在与对象之中。</p>\n<p>这看起来似乎没有意义，是多此一举，还不如直接：</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是一旦需要获得一个对象中的部分属性的时候，对象的扩展运算符就显得十分好用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的例子中，我们可以轻松的让变量<code>z</code>取到<code>{ a: 3, b: 4 }</code>这两个属性。</p>\n<p>否则我们需要这么写：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不论哪一种方法，都是很麻烦的。</p>\n<h3> 基本用法</h3>\n<p><strong>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果扩展运算符后面是一个空对象，则没有任何效果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果扩展运算符后面不是对象，则会自动将其转为对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，扩展运算符后面是整数<code>1</code>，会自动转为数值的包装对象<code>Number{1}</code>。由于该对象没有自身属性，所以返回一个空对象。</p>\n<p>下面的例子都是类似的道理。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>对象的扩展运算符等同于使用<code>Object.assign()</code>方法。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，写法一的<code>__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>\n<p>扩展运算符可以用于合并两个对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p>\n<p>这用来修改现有对象部分的属性就很方便了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>newVersion</code>对象自定义了<code>name</code>属性，其他属性全部复制自<code>previousVersion</code>对象。</p>\n<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，取值函数<code>get</code>在扩展<code>a</code>对象时会自动执行，导致报错。</p>\n<h3> 解构赋值中运用</h3>\n<p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p>\n<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>解构赋值必须是最后一个参数，否则会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p>\n<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p>\n<p><strong>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>o3</code>复制了<code>o2</code>，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性。</p>\n<p>下面是另一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，变量<code>x</code>是单纯的解构赋值，所以可以读取对象<code>o</code>继承的属性；变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值，只能读取对象<code>o</code>自身的属性，所以变量<code>z</code>可以赋值成功，变量<code>y</code>取不到值。</p>\n<p><strong>ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量<code>newObj</code>，如果写成下面这样会报错。</strong></p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>\n<h2> 链判断运算符</h2>\n<h3> 设计目的</h3>\n<p>编程中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取<code>message.body.user.firstName</code>，安全的写法是写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，<code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值。</p>\n<p>三元运算符<code>?:</code>也常用于判断对象是否存在。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，必须先判断<code>fooInput</code>是否存在，才能读取<code>fooInput.value</code>。</p>\n<p><strong>这样的层层判断非常麻烦，因此 <a href=\"https://github.com/tc39/proposal-optional-chaining\" target=\"_blank\" rel=\"noopener noreferrer\">ES2020</a> 引入了“链判断运算符”（optional chaining operator）<code>?.</code>，简化上面的写法。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p>\n<h3> 基本用法</h3>\n<p>下面是判断对象方法是否存在，如果存在就立即执行的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>iterator.return</code>如果有定义，就会调用该方法，否则<code>iterator.return</code>直接返回<code>undefined</code>，不再执行<code>?.</code>后面的部分。</p>\n<p>对于那些可能没有实现的方法，这个运算符尤其有用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，老式浏览器的表单可能没有<code>checkValidity</code>这个方法，这时<code>?.</code>运算符就会返回<code>undefined</code>，判断语句就变成了<code>undefined === false</code>，所以就会跳过下面的代码。</p>\n<p><strong>链判断运算符有三种用法：</strong></p>\n<ul>\n<li><strong><code>obj?.prop</code> // 对象属性</strong></li>\n<li><strong><code>obj?.[expr]</code> // 同上</strong></li>\n<li><strong><code>func?.(...args)</code> // 函数或对象方法的调用</strong></li>\n</ul>\n<p>下面是<code>obj?.[expr]</code>用法的一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，字符串的<code>match()</code>方法，如果没有发现匹配会返回<code>null</code>，如果发现匹配会返回一个数组，<code>?.</code>运算符起到了判断作用。</p>\n<p>下面是<code>?.</code>运算符常见形式，以及不使用该运算符时的等价形式。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，特别注意后两种形式，如果<code>a?.b()</code>里面的<code>a.b</code>不是函数，不可调用，那么<code>a?.b()</code>是会报错的。<code>a?.()</code>也是如此，如果<code>a</code>不是<code>null</code>或<code>undefined</code>，但也不是函数，那么<code>a?.()</code>会报错。</p>\n<h3> 注意点</h3>\n<p>使用这个运算符，有几个注意点：</p>\n<h4> 短路机制</h4>\n<p><code>?.</code>运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，那么<code>x</code>不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。</p>\n<h4> delete 运算符</h4>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，会直接返回<code>undefined</code>，而不会进行<code>delete</code>运算。</p>\n<h4> 括号的影响</h4>\n<p>如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>?.</code>对圆括号外部没有影响，不管<code>a</code>对象是否存在，圆括号后面的<code>.c</code>总是会执行。</p>\n<p><strong>一般来说，使用<code>?.</code>运算符的场合，不应该使用圆括号。</strong></p>\n<h4> 报错场合</h4>\n<p>以下写法是禁止的，会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 右侧不得为十进制数值</h4>\n<p>为了保证兼容以前的代码，允许<code>foo?.3:0</code>被解析成<code>foo ? .3 : 0</code>，因此规定如果<code>?.</code>后面紧跟一个十进制数字，那么<code>?.</code>不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。</p>\n<h2> Null 判断运算符</h2>\n<h3> 设计目的</h3>\n<p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。</p>\n<p><strong>为了避免这种情况，<a href=\"https://github.com/tc39/proposal-nullish-coalescing\" target=\"_blank\" rel=\"noopener noreferrer\">ES2020</a> 引入了一个新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，默认值只有在左侧属性值为<code>null</code>或<code>undefined</code>时，才会生效。</p>\n<h3> 基本用法</h3>\n<p>这个运算符的一个目的，就是跟链判断运算符<code>?.</code>配合使用，为<code>null</code>或<code>undefined</code>的值设置默认值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果<code>response.settings</code>是<code>null</code>或<code>undefined</code>，或者<code>response.settings.animationDuration</code>是<code>null</code>或<code>undefined</code>，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。</p>\n<p>这个运算符很适合判断函数参数是否赋值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码判断<code>props</code>参数的<code>enabled</code>属性是否赋值，基本等同于下面的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 优先级问题</h3>\n<p><strong><code>??</code>有一个运算优先级问题，它与<code>&amp;&amp;</code>和<code>||</code>的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面四个表达式都会报错，必须加入表明优先级的括号。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "12.异步编程",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses12.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses12.html",
      "summary": "异步编程存在的意义 JS是单线程模型 单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。 注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行...",
      "content_html": "<h1> 异步编程</h1>\n<h2> 异步编程存在的意义</h2>\n<h3> JS是单线程模型</h3>\n<p>单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p>\n<p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p>\n<p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>\n<p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p>\n<p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p>\n<p>单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。</p>\n<p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>\n<h3> 同步任务和异步任务</h3>\n<p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p>\n<p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p>\n<p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p>\n<p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p>\n<h3> 任务队列和事件循环</h3>\n<p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>\n<p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p>\n<p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p>\n<p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。<a href=\"https://en.wikipedia.org/wiki/Event_loop\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a>的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p>\n<h4> 浏览器中的Event Loop</h4>\n<p><code>Javascript</code> 有一个 <code>main thread</code> 主线程和 <code>call-stack</code> 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>\n<h4> JS调用栈</h4>\n<p>JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p>\n<h4> 宏任务与微任务</h4>\n<p>在<code>JavaScript</code>中，任务被分为两种，一种宏任务（<code>MacroTask</code>）也叫<code>Task</code>，一种叫微任务（<code>MicroTask</code>）。</p>\n<p><strong>MicroTask(宏任务)</strong></p>\n<p><code>script</code>全部代码、****<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（浏览器暂时不支持，只有IE10支持，具体可见<code>MDN</code>）、<code>I/O</code>、<code>UI Rendering</code>。</p>\n<p><strong>MicroTask(微任务)</strong></p>\n<p><code>Process.nextTick（Node独有）</code>、<code>Promise</code>、<code>Object.observe(废弃)</code>、<code>MutationObserver</code></p>\n<p><strong>两者的区别</strong></p>\n<p>它们的区别在于，宏任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的输出结果是<code>321</code>。这说明<code>then</code>的回调函数的执行时间，早于<code>setTimeout(fn, 0)</code>。因为<code>then</code>是本轮事件循环执行，<code>setTimeout(fn, 0)</code>在下一轮事件循环开始时执行。</p>\n<h4> Event Loop 全过程图解</h4>\n<p></p>\n<h2> 控制异步操作的本质</h2>\n<p>要想深入的理解Promise、Generator、async对于异步操作的封装，我们就有必要来了解一下异步操作模式的本质。</p>\n<p>我们通常有以下几种控制异步操作的方法(也可以理解成控制异步操作的原理)：</p>\n<h3> 回调函数</h3>\n<p>回调函数是异步操作最基本的方法。</p>\n<p>下面是两个函数<code>f1</code>和<code>f2</code>，编程的意图是<code>f2</code>必须等到<code>f1</code>执行完成，才能执行。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的问题在于，如果<code>f1</code>是异步操作，<code>f2</code>会立即执行，不会等到<code>f1</code>结束再执行。</p>\n<p>这时，可以考虑改写<code>f1</code>，把<code>f2</code>写成<code>f1</code>的回调函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度<a href=\"https://en.wikipedia.org/wiki/Coupling_(computer_programming)\" target=\"_blank\" rel=\"noopener noreferrer\">耦合</a>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p>\n<h3> 事件监听</h3>\n<p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>\n<p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的 jQuery 的<a href=\"https://api.jquery.com/on/\" target=\"_blank\" rel=\"noopener noreferrer\">写法</a>）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面这行代码的意思是，当<code>f1</code>发生<code>done</code>事件，就执行<code>f2</code>。然后，对<code>f1</code>进行改写：</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>f1.trigger('done')</code>表示，执行完成后，立即触发<code>done</code>事件，从而开始执行<code>f2</code>。</p>\n<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<a href=\"https://en.wikipedia.org/wiki/Decoupling\" target=\"_blank\" rel=\"noopener noreferrer\">去耦合</a>”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p>\n<h3> 发布/订阅</h3>\n<p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a href=\"https://en.wikipedia.org/wiki/Publish-subscribe_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">发布/订阅模式</a>”（publish-subscribe pattern），又称“<a href=\"https://en.wikipedia.org/wiki/Observer_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">观察者模式</a>”（observer pattern）。</p>\n<p>这个模式有多种<a href=\"https://msdn.microsoft.com/en-us/magazine/hh201955.aspx\" target=\"_blank\" rel=\"noopener noreferrer\">实现</a>，下面采用的是 Ben Alman 的 <a href=\"https://gist.github.com/661855\" target=\"_blank\" rel=\"noopener noreferrer\">Tiny Pub/Sub</a>，这是 jQuery 的一个插件。</p>\n<p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>然后，<code>f1</code>进行如下改写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>jQuery.publish('done')</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p>\n<p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>\n<h2> 异步操作的流程控制</h2>\n<p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>async</code>函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。</p>\n<p>如果有六个这样的异步任务，需要全部完成后，才能执行最后的<code>final</code>函数。请问应该如何安排操作流程？</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p>\n<h3> 串行执行</h3>\n<p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，函数<code>series</code>就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行<code>final</code>函数。<code>items</code>数组保存每一个异步任务的参数，<code>results</code>数组保存每一个异步任务的运行结果。</p>\n<p>注意，上面的写法需要六秒，才能完成整个脚本。</p>\n<h3> 并行执行</h3>\n<p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行<code>final</code>函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>forEach</code>方法会同时发起六个异步任务，等到它们全部完成以后，才会执行<code>final</code>函数。</p>\n<p>相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p>\n<h3> 并行与串行的结合</h3>\n<p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行<code>n</code>个异步任务，这样就避免了过分占用系统资源。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，最多只能同时运行两个异步任务。变量<code>running</code>记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于<code>0</code>，就表示所有任务都执行完了，这时就执行<code>final</code>函数。</p>\n<p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节<code>limit</code>变量，达到效率和资源的最佳平衡。</p>\n<h2> Promise 对象</h2>\n<h3> Promise 存在的意义</h3>\n<p>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个<code>then</code>方法，用来指定下一步的回调函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>f1</code>的异步操作执行完成，就会执行<code>f2</code>。</p>\n<p>传统的写法可能需要把<code>f2</code>作为回调函数传入<code>f1</code>，比如写成<code>f1(f2)</code>，异步操作完成后，在<code>f1</code>内部调用<code>f2</code>。Promise 使得<code>f1</code>和<code>f2</code>变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的<code>Promise</code>实例的生成格式，做了简化，真正的语法请参照下文。</p>\n<p>总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。</p>\n<h3> Promise 的概念</h3>\n<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>\n<p><code>Promise</code>对象有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>\n<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<h3> Promise 对象的状态</h3>\n<p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p>\n<ul>\n<li>异步操作未完成（pending）</li>\n<li>异步操作成功（fulfilled）</li>\n<li>异步操作失败（rejected）</li>\n</ul>\n<p>上面三种状态里面，<code>fulfilled</code>和<code>rejected</code>合在一起称为<code>resolved</code>（已定型）。</p>\n<p>这三种的状态的变化途径只有两种。</p>\n<ul>\n<li>从“未完成”到“成功”</li>\n<li>从“未完成”到“失败”</li>\n</ul>\n<p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p>\n<p>因此，Promise 的最终结果只有两种。</p>\n<ul>\n<li>异步操作成功，Promise 实例传回一个值（value），状态变为<code>fulfilled</code>。</li>\n<li>异步操作失败，Promise 实例抛出一个错误（error），状态变为<code>rejected</code>。</li>\n</ul>\n<h3> Promise 构造函数</h3>\n<p>JavaScript 提供原生的<code>Promise</code>构造函数，用来生成 Promise 实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p>\n<h4> resolve和reject</h4>\n<p><code>resolve</code>函数的作用是，将<code>Promise</code>实例的状态从“未完成”变为“成功”（即从<code>pending</code>变为<code>fulfilled</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。<code>reject</code>函数的作用是，将<code>Promise</code>实例的状态从“未完成”变为“失败”（即从<code>pending</code>变为<code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n<p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>timeout(100)</code>返回一个 Promise 实例。100毫秒以后，该实例的状态会变为<code>fulfilled</code>。</p>\n<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>\n<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>），但是此时<code>p1</code>的状为<code>pending</code>，所以既不会触发<code>then</code>里面的<code>resolve</code>方法(这个<code>then</code>方法中省略了<code>reject</code>)，也不会触发<code>catch</code>。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p>\n<h4> 注意点1</h4>\n<p><strong>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>\n<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 注意点2</h4>\n<p><strong>Promise 新建后就会立即执行</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>\n<h3> Promise 实例方法</h3>\n<h4> Promise.prototype.then()</h4>\n<h5> 基本使用</h5>\n<p>Promise 实例的<code>then</code>方法，用来添加回调函数。</p>\n<p><code>then</code>方法可以接受两个回调函数，第一个是异步操作成功时（变为<code>fulfilled</code>状态）的回调函数，第二个是异步操作失败（变为<code>rejected</code>）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。</p>\n<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>\n<p>还需要特别注意，<code>then</code> 方法里面的<code>resolve()</code>函数有返回值，返回值会传入下一个<code>then</code>方法当成参数使用，默认的返回值为<code>undefined</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>p1</code>和<code>p2</code>都是Promise 实例，它们的<code>then</code>方法绑定两个回调函数：成功时的回调函数<code>console.log</code>，失败时的回调函数<code>console.error</code>（可以省略）。<code>p1</code>的状态变为成功，<code>p2</code>的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。</p>\n<p><code>then</code>方法可以链式使用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>p1</code>后面有四个<code>then</code>，意味依次有四个回调函数。只要前一步的状态变为<code>fulfilled</code>，就会依次执行紧跟在后面的回调函数。</p>\n<p>最后一个<code>then</code>方法，回调函数是<code>console.log</code>和<code>console.error</code>，用法上有一点重要的区别。<code>console.log</code>只显示<code>step3</code>的返回值，而<code>console.error</code>可以显示<code>p1</code>、<code>step1</code>、<code>step2</code>、<code>step3</code>之中任意一个发生的错误。举例来说，如果<code>step1</code>的状态变为<code>rejected</code>，那么<code>step2</code>和<code>step3</code>都不会执行了（因为它们是<code>resolved</code>的回调函数）。Promise 开始寻找，接下来第一个为<code>rejected</code>的回调函数，在上面代码中是<code>console.error</code>。<strong>这就是说，Promise 对象的报错具有传递性。</strong></p>\n<h5> then() 用法辨析</h5>\n<p>Promise 的用法，简单说就是一句话：使用<code>then</code>方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了便于讲解，下面这四种写法都再用<code>then</code>方法接一个回调函数<code>f3</code>。写法一的<code>f3</code>回调函数的参数，是<code>f2</code>函数的运行结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>写法二的<code>f3</code>回调函数的参数是<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>写法三的<code>f3</code>回调函数的参数，是<code>f2</code>函数返回的函数的运行结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>写法四与写法一只有一个差别，那就是<code>f2</code>会接收到<code>f1()</code>返回的结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Promise.prototype.catch()</h4>\n<p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。</p>\n<h5> 注意点1</h5>\n<p><strong>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>\n<h5> 注意点2</h5>\n<p><strong>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p>\n<h5> 注意点3</h5>\n<p><strong>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p>\n<p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p>\n<p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p>\n<p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p>\n<p>再看下面的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>\n<p><strong>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p>\n<h5> 注意点4</h5>\n<p><strong><code>catch()</code>方法之中，还能再抛出错误。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>\n<h4> Promise.prototype.finally()</h4>\n<p>**<code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。**该方法是 ES2018 引入标准的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>\n<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</strong></p>\n<p><strong><code>finally</code>本质上是<code>then</code>方法的特例。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>\n<p>它的实现也很简单。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p>\n<p><strong>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Promise 静态方法</h3>\n<h4> Promise.resolve()</h4>\n<p><strong>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p>\n<p><strong><code>Promise.resolve()</code>等价于下面的写法。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>Promise.resolve()</code>方法的参数分成四种情况。</strong></p>\n<p><strong>（1）参数是一个 Promise 实例</strong></p>\n<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>\n<p><strong>（2）参数是一个<code>thenable</code>对象</strong></p>\n<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p>\n<p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p>\n<p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p>\n<p><strong>（4）不带有任何参数</strong></p>\n<p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>\n<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p>\n<p><strong>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log('one')</code>则是立即执行，因此最先输出。</p>\n<h4> Promise.reject()</h4>\n<p><strong><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>\n<p><strong><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>\n<h4> Promise.try()</h4>\n<h5> 需求原理</h5>\n<p>实际开发中，经常遇到一种情况：<strong>不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它</strong>。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p>\n<p>那么有没有一种方法，<strong>让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢</strong>？回答是可以的，并且还有两种写法。</p>\n<p><strong>第一种写法是用<code>async</code>函数来写。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>第二种写法是使用<code>new Promise()</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p>\n<h5> 实现</h5>\n<p>鉴于这是一个很常见的需求，所以现在有一个<a href=\"https://github.com/ljharb/proposal-promise-try\" target=\"_blank\" rel=\"noopener noreferrer\">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href=\"http://bluebirdjs.com/docs/api/promise.try.html\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Bluebird</code></a>、<a href=\"https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Q</code></a>和<a href=\"https://github.com/cujojs/when/blob/master/docs/api.md#whentry\" target=\"_blank\" rel=\"noopener noreferrer\"><code>when</code></a>，早就提供了这个方法。</p>\n<p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href=\"http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/\" target=\"_blank\" rel=\"noopener noreferrer\">许多好处</a>，其中一点就是可以更好地管理异常。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>\n<h4> Promise.all()</h4>\n<p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>\n<p><strong><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</strong></p>\n<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>\n<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>\n<p>下面是一个具体的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<p>下面是另一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p>\n<p><strong>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p>\n<p><strong>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> Promise.race()</h4>\n<p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>\n<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>\n<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>\n<h4> Promise.allSettled()</h4>\n<p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href=\"https://github.com/tc39/proposal-promise-allSettled\" target=\"_blank\" rel=\"noopener noreferrer\">ES2020</a> 引入。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p>\n<p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的两个 Promise 实例。每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。<code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</p>\n<p>下面是返回值用法的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code>方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了。</p>\n<h4> Promise.any()</h4>\n<p>ES2021 引入了<a href=\"https://github.com/tc39/proposal-promise-any\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>\n<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p>\n<p><code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Promise 作为微任务</h3>\n<p>Promise 的回调函数属于异步任务，会在同步任务之后执行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码会先输出2，再输出1。因为<code>console.log(2)</code>是同步任务，而<code>then</code>的回调函数属于异步任务，一定晚于同步任务执行。</p>\n<p>但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的输出结果是<code>321</code>。这说明<code>then</code>的回调函数的执行时间，早于<code>setTimeout(fn, 0)</code>。因为<code>then</code>是本轮事件循环执行，<code>setTimeout(fn, 0)</code>在下一轮事件循环开始时执行。</p>\n<h3> 总结</h3>\n<p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p>\n<p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。</p>\n<p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆<code>then</code>，必须自己在<code>then</code>的回调函数里面理清逻辑。</p>\n<h2> Generator 函数</h2>\n<h3> 概念</h3>\n<h4> 基础理解</h4>\n<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本节详细介绍 Generator 函数的语法和 API。</p>\n<p>Generator 函数有多种理解角度。<strong>语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</strong></p>\n<p>执行 Generator 函数会返回一个遍历器对象，也就是说，**Generator 函数除了状态机，还是一个遍历器对象生成函数。**返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>\n<p><strong>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p>\n<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。</p>\n<p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码一共调用了四次<code>next</code>方法。</p>\n<p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>\n<p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>\n<p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p>\n<p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p>\n<h4> 注意点</h4>\n<p><strong>记住，有多少个<code>next()</code>，就执行了多少个<code>yield</code>。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码我们可以看出，只要执行了<code>res.next()</code>，就意味着会执行一次<code>yield</code>及其以上部分(即第一个<code>yield</code>上面的代码段或者两个<code>yield</code>之间的代码段)。</p>\n<h4> 总结</h4>\n<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p>\n<p>ES6 没有规定，<code>function</code>关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在<code>function</code>关键字后面。本书也采用这种写法。</p>\n<h3> yield 表达式</h3>\n<h4> 基本用法</h4>\n<p><strong>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</strong></p>\n<p><strong>遍历器对象的<code>next</code>方法的运行逻辑如下：</strong></p>\n<p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p>\n<p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p>\n<p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p>\n<p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</p>\n<p>需要注意的是，<code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>yield</code>后面的表达式<code>123 + 456</code>，不会立即求值，只会在<code>next</code>方法将指针移到这一句时，才会求值。</p>\n<p><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）<code>return</code>语句，但是可以执行多次（或者说多个）<code>yield</code>表达式。正常函数只能返回一个值，因为只能执行一次<code>return</code>；Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。</p>\n<h4> 作为暂缓执行函数</h4>\n<p><strong>Generator 函数可以不用<code>yield</code>表达式，这时就变成了一个单纯的暂缓执行函数。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>f</code>如果是普通函数，在为变量<code>generator</code>赋值时就会执行。但是，函数<code>f</code>是一个 Generator 函数，就变成只有调用<code>next</code>方法时，函数<code>f</code>才会执行。</p>\n<h4> 注意点</h4>\n<p><strong><code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码在一个普通函数中使用<code>yield</code>表达式，结果产生一个句法错误。</p>\n<p>下面是另外一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码也会产生句法错误，因为<code>forEach</code>方法的参数是一个普通函数，但是在里面使用了<code>yield</code>表达式（这个函数里面还使用了<code>yield*</code>表达式，详细介绍见后文）。一种修改方法是改用<code>for</code>循环。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，<code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号里面。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 与 Iterator 接口的关系</h3>\n<p><strong>任意一个对象的<code>Symbol.iterator</code>方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</strong></p>\n<p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 Iterator 接口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，Generator 函数赋值给<code>Symbol.iterator</code>属性，从而使得<code>myIterable</code>对象具有了 Iterator 接口，可以被<code>...</code>运算符遍历了。</p>\n<p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有<code>Symbol.iterator</code>属性，执行后返回自身。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>gen</code>是一个 Generator 函数，调用它会生成一个遍历器对象<code>g</code>。它的<code>Symbol.iterator</code>属性，也是一个遍历器对象生成函数，执行后返回它自己。</p>\n<h3> for...of 循环</h3>\n<h4> 基本使用</h4>\n<p><strong><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码使用<code>for...of</code>循环，依次显示 5 个<code>yield</code>表达式的值。</p>\n<p><strong>这里需要注意，一旦<code>next</code>方法的返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止，且不包含该返回对象，所以上面代码的<code>return</code>语句返回的<code>6</code>，不包括在<code>for...of</code>循环之中。</strong></p>\n<p>下面是一个利用 Generator 函数和<code>for...of</code>循环，实现斐波那契数列的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面代码可见，使用<code>for...of</code>语句时不需要使用<code>next</code>方法。</p>\n<h5> 给原生对象加上遍历器接口</h5>\n<p><strong>利用<code>for...of</code>循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用<code>for...of</code>循环，通过 Generator 函数为它加上这个接口，就可以用了。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，对象<code>jane</code>原生不具备 Iterator 接口，无法用<code>for...of</code>遍历。这时，我们通过 Generator 函数<code>objectEntries</code>为它加上遍历器接口，就可以用<code>for...of</code>遍历了。</p>\n<p><strong>加上遍历器接口的另一种写法是，将 Generator 函数加到对象的<code>Symbol.iterator</code>属性上面。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Generator 实例方法</h3>\n<h4> next 方法及其参数</h4>\n<p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码先定义了一个可以无限运行的 Generator 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。</p>\n<p><strong>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过<code>next</code>方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</strong></p>\n<p>再看一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，第二次运行<code>next</code>方法的时候不带参数，导致 y 的值等于<code>2 * undefined</code>（即<code>NaN</code>），除以 3 以后还是<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>Next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p>\n<p>如果向<code>next</code>方法提供参数，返回结果就完全不一样了。上面代码第一次调用<code>b</code>的<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</p>\n<p><strong>注意，由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。V8 引擎直接忽略第一次使用<code>next</code>方法时的参数，只有从第二次使用<code>next</code>方法开始，参数才是有效的。从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数。</strong></p>\n<p>再看一个通过<code>next</code>方法的参数，向 Generator 函数内部输入值的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码是一个很直观的例子，每次通过<code>next</code>方法向 Generator 函数输入值，然后打印出来。</p>\n<p>如果想要第一次调用<code>next</code>方法时，就能够输入值，可以在 Generator 函数外面再包一层。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，Generator 函数如果不用<code>wrapper</code>先包一层，是无法第一次调用<code>next</code>方法，就输入参数的。</p>\n<h4> Generator.prototype.throw()</h4>\n<h5> 基本使用</h5>\n<p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，遍历器对象<code>i</code>连续抛出两个错误。第一个错误被 Generator 函数体内的<code>catch</code>语句捕获。<code>i</code>第二次抛出错误，由于 Generator 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的<code>catch</code>语句捕获。</p>\n<p><strong><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 注意点1</h5>\n<p>不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。上面代码的错误，是用遍历器对象的<code>throw</code>方法抛出的，而不是用<code>throw</code>命令抛出的。后者只能被函数体外的<code>catch</code>语句捕获。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码之所以只捕获了<code>a</code>，是因为函数体外的<code>catch</code>语句块，捕获了抛出的<code>a</code>错误以后，就不会再继续<code>try</code>代码块里面剩余的语句了。</p>\n<h5> 注意点2</h5>\n<p><strong>如果 Generator 函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，Generator 函数<code>g</code>内部没有部署<code>try...catch</code>代码块，所以抛出的错误直接被外部<code>catch</code>代码块捕获。</p>\n<p><strong>如果 Generator 函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>g.throw</code>抛出错误以后，没有任何<code>try...catch</code>代码块可以捕获这个错误，导致程序报错，中断执行。</p>\n<h6> 注意点3</h6>\n<p><strong><code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>g.throw(1)</code>执行时，<code>next</code>方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行<code>next</code>方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时<code>throw</code>方法抛错只可能抛出在函数外部。</p>\n<h5> 注意点4</h5>\n<p><strong><code>throw</code>方法被捕获以后，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次<code>next</code>方法。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>g.throw</code>方法被捕获以后，自动执行了一次<code>next</code>方法，所以会打印<code>b</code>。另外，也可以看到，只要 Generator 函数内部部署了<code>try...catch</code>代码块，那么遍历器的<code>throw</code>方法抛出的错误，不影响下一次遍历。</p>\n<p><strong><code>throw</code>命令与<code>g.throw</code>方法是无关的，两者互不影响。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>throw</code>命令抛出的错误不会影响到遍历器的状态，所以两次执行<code>next</code>方法，都进行了正确的操作。</p>\n<p>这种函数体内捕获错误的机制，大大方便了对错误的处理。多个<code>yield</code>表达式，可以只用一个<code>try...catch</code>代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次<code>catch</code>语句就可以了。</p>\n<h5> 注意点5</h5>\n<p><strong>Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的<code>catch</code>捕获。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，第二个<code>next</code>方法向函数体内传入一个参数 42，数值是没有<code>toUpperCase</code>方法的，所以会抛出一个 TypeError 错误，被函数体外的<code>catch</code>捕获。</p>\n<p>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用<code>next</code>方法，将返回一个<code>value</code>属性等于<code>undefined</code>、<code>done</code>属性等于<code>true</code>的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码一共三次运行<code>next</code>方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。</p>\n<h4> Generator.prototype.return()</h4>\n<p>Generator 函数返回的遍历器对象，还有一个<code>return()</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，遍历器对象<code>g</code>调用<code>return()</code>方法后，返回值的<code>value</code>属性就是<code>return()</code>方法的参数<code>foo</code>。并且，Generator 函数的遍历就终止了，返回值的<code>done</code>属性为<code>true</code>，以后再调用<code>next()</code>方法，<code>done</code>属性总是返回<code>true</code>。</p>\n<p>如果<code>return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果 Generator 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值。</p>\n<h4> next()、throw()、return() 的共同点</h4>\n<p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p>\n<p><code>next()</code>是将<code>yield</code>表达式替换成一个值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，第二个<code>next(1)</code>方法就相当于将<code>yield</code>表达式替换成一个值<code>1</code>。如果<code>next</code>方法没有参数，就相当于替换成<code>undefined</code>。</p>\n<p><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>return()</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> yield* 表达式</h3>\n<h4> 基本使用</h4>\n<p>如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>foo</code>和<code>bar</code>都是 Generator 函数，在<code>bar</code>里面调用<code>foo</code>，就需要手动遍历<code>foo</code>。如果有多个 Generator 函数嵌套，写起来就非常麻烦。</p>\n<p>ES6 提供了<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再来看一个对比的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面例子中，<code>outer2</code>使用了<code>yield*</code>，<code>outer1</code>没使用。结果就是，<code>outer1</code>返回一个遍历器对象，<code>outer2</code>返回该遍历器对象的内部值。</p>\n<h4> 原理</h4>\n<p>从语法角度看，如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在<code>yield</code>表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为<code>yield*</code>表达式。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>delegatingIterator</code>是代理者，<code>delegatedIterator</code>是被代理者。由于<code>yield* delegatedIterator</code>语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。</p>\n<p><strong><code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），等同于在 Generator 函数内部，部署一个<code>for...of</code>循环。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码说明，<code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），不过是<code>for...of</code>的一种简写形式，完全可以用后者替代前者。反之，在有<code>return</code>语句时，则需要用<code>var value = yield* iterator</code>的形式获取<code>return</code>语句的值。</p>\n<p><strong>如果<code>yield*</code>后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>yield</code>命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。</p>\n<h4> 应用</h4>\n<p>实际上，任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>yield</code>表达式返回整个字符串，<code>yield*</code>语句返回单个字符。因为字符串具有 Iterator 接口，所以被<code>yield*</code>遍历。</p>\n<p>如果被代理的 Generator 函数有<code>return</code>语句，那么就可以向代理它的 Generator 函数返回数据。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码在第四次调用<code>next</code>方法的时候，屏幕上会有输出，这是因为函数<code>foo</code>的<code>return</code>语句，向函数<code>bar</code>提供了返回值。</p>\n<p>再看一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，存在两次遍历。第一次是扩展运算符遍历函数<code>logReturned</code>返回的遍历器对象，第二次是<code>yield*</code>语句遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。所以，最后的数据表达式得到的值等于<code>[ 'a', 'b' ]</code>。但是，函数<code>genFuncWithReturn</code>的<code>return</code>语句的返回值<code>The result</code>，会返回给函数<code>logReturned</code>内部的<code>result</code>变量，因此会有终端输出。</p>\n<p><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由于扩展运算符<code>...</code>默认调用 Iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是一个稍微复杂的例子，使用<code>yield*</code>语句遍历完全二叉树。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Generator 函数作为对象属性</h3>\n<p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>myGeneratorMethod</code>属性前面有一个星号，表示这个属性是一个 Generator 函数。</p>\n<p>它的完整形式如下，与上面的写法是等价的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Generator 函数的 this</h3>\n<h4> 概念</h4>\n<p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的<code>prototype</code>对象上的方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码表明，Generator 函数<code>g</code>返回的遍历器<code>obj</code>，是<code>g</code>的实例，而且继承了<code>g.prototype</code>。但是，如果把<code>g</code>当作普通的构造函数，并不会生效，因为<code>g</code>返回的总是遍历器对象，而不是<code>this</code>对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，Generator 函数<code>g</code>在<code>this</code>对象上面添加了一个属性<code>a</code>，但是<code>obj</code>对象拿不到这个属性。</p>\n<p>Generator 函数也不能跟<code>new</code>命令一起用，会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>new</code>命令跟构造函数<code>F</code>一起使用，结果报错，因为<code>F</code>不是构造函数。</p>\n<h4> 思考</h4>\n<p>那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用<code>next</code>方法，又可以获得正常的<code>this</code>？</p>\n<p>下面是一个变通方法。首先，生成一个空对象，使用<code>call</code>方法绑定 Generator 函数内部的<code>this</code>。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，首先是<code>F</code>内部的<code>this</code>对象绑定<code>obj</code>对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次<code>next</code>方法（因为<code>F</code>内部有两个<code>yield</code>表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在<code>obj</code>对象上了，因此<code>obj</code>对象也就成了<code>F</code>的实例。</p>\n<p>上面代码中，执行的是遍历器对象<code>f</code>，但是生成的对象实例是<code>obj</code>，有没有办法将这两个对象统一呢？</p>\n<p>一个办法就是将<code>obj</code>换成<code>F.prototype</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再将<code>F</code>改成构造函数，就可以对它执行<code>new</code>命令了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 利用Generator实现一些机制</h3>\n<h4> 状态机</h4>\n<p>Generator 是实现状态机的最佳结构。比如，下面的<code>clock</code>函数就是一个状态机。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>clock</code>函数一共有两种状态（<code>Tick</code>和<code>Tock</code>），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量<code>ticking</code>，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p>\n<h4> 协程</h4>\n<p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p>\n<p><strong>（1）协程与子例程的差异</strong></p>\n<p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>\n<p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p>\n<p><strong>（2）协程与普通线程的差异</strong></p>\n<p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>\n<p>由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p>\n<p>Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>\n<p>如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用<code>yield</code>表达式交换控制权。</p>\n<h4> 上下文</h4>\n<p>JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。</p>\n<p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</p>\n<p>Generator 函数不是这样，它执行产生的上下文环境，一旦遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，第一次执行<code>g.next()</code>时，Generator 函数<code>gen</code>的上下文会加入堆栈，即开始运行<code>gen</code>内部的代码。等遇到<code>yield 1</code>时，<code>gen</code>上下文退出堆栈，内部状态冻结。第二次执行<code>g.next()</code>时，<code>gen</code>上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p>\n<h3> Generator应用</h3>\n<p>Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。</p>\n<h4> 异步操作的同步化表达</h4>\n<p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在<code>yield</code>表达式里面，等到调用<code>next</code>方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<code>yield</code>表达式下面，反正要等到调用<code>next</code>方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面（<code>showLoadingScreen</code>），并且异步加载数据（<code>loadUIDataAsynchronously</code>）。等到数据加载完成，再一次使用<code>next</code>方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p>\n<p>Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的<code>main</code>函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个<code>yield</code>，它几乎与同步操作的写法完全一样。注意，<code>makeAjaxCall</code>函数中的<code>next</code>方法，必须加上<code>response</code>参数，因为<code>yield</code>表达式，本身是没有值的，总是等于<code>undefined</code>。</p>\n<p>下面是另一个例子，通过 Generator 函数逐行读取文本文件。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码打开文本文件，使用<code>yield</code>表达式可以手动逐行读取文件。</p>\n<h4> 控制流管理</h4>\n<p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>采用 Promise 改写上面的代码。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后，使用一个函数，按次序自动执行所有步骤。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。</p>\n<p>下面，利用<code>for...of</code>循环会自动依次执行<code>yield</code>命令的特性，提供一种更一般的控制流管理的方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，数组<code>steps</code>封装了一个任务的多个步骤，Generator 函数<code>iterateSteps</code>则是依次为这些步骤加上<code>yield</code>命令。</p>\n<p>将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，数组<code>jobs</code>封装了一个项目的多个任务，Generator 函数<code>iterateJobs</code>则是依次为这些任务加上<code>yield*</code>命令。</p>\n<p>最后，就可以用<code>for...of</code>循环一次性依次执行所有任务的所有步骤。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。</p>\n<p><code>for...of</code>的本质是一个<code>while</code>循环，所以上面的代码实质上执行的是下面的逻辑。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 部署 Iterator 接口</h4>\n<p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码中，<code>myObj</code>是一个普通对象，通过<code>iterEntries</code>函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署<code>next</code>方法。</p>\n<p>下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 作为数据结构</h4>\n<p>Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的函数，可以用一模一样的<code>for...of</code>循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。</p>\n<h3> Generator 改进异步编程</h3>\n<h4> 传统方法</h4>\n<p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p>\n<ul>\n<li>回调函数</li>\n<li>事件监听</li>\n<li>发布/订阅</li>\n<li>Promise 对象</li>\n</ul>\n<p>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。</p>\n<h4> 基本概念</h4>\n<h5> 异步</h5>\n<p>所谓\"异步\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>\n<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>\n<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>\n<h5> 回调函数</h5>\n<p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字<code>callback</code>，直译过来就是\"重新调用\"。</p>\n<p>读取文件进行处理，是这样写的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p>\n<p>一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象<code>err</code>（如果没有错误，该参数就是<code>null</code>）？</p>\n<p>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</p>\n<h5> Promise</h5>\n<p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取<code>A</code>文件之后，再读取<code>B</code>文件，代码如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为\"回调函数地狱\"（callback hell）。</p>\n<p>Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，我使用了<code>fs-readfile-promise</code>模块，它的作用就是返回一个 Promise 版本的<code>readFile</code>函数。Promise 提供<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。</p>\n<p>可以看到，Promise 的写法只是回调函数的改进，使用<code>then</code>方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>\n<p>Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆<code>then</code>，原来的语义变得很不清楚。</p>\n<p>那么，有没有更好的写法呢？</p>\n<h4> 协程</h4>\n<p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做\"协程\"（coroutine），意思是多个线程互相协作，完成异步任务。</p>\n<p><strong>协程有点像函数，又有点像线程。它的运行流程大致如下。</strong></p>\n<ul>\n<li><strong>第一步，协程<code>A</code>开始执行。</strong></li>\n<li><strong>第二步，协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code>。</strong></li>\n<li><strong>第三步，（一段时间后）协程<code>B</code>交还执行权。</strong></li>\n<li><strong>第四步，协程<code>A</code>恢复执行。</strong></li>\n</ul>\n<p>上面流程的协程<code>A</code>，就是异步任务，因为它分成两段（或多段）执行。</p>\n<p>举例来说，读取文件的协程写法如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线。</p>\n<p>协程遇到<code>yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除<code>yield</code>命令，简直一模一样。</p>\n<h4> Generator 函数实现协程</h4>\n<p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>\n<p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code>yield</code>语句注明。Generator 函数的执行方法如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）<code>g</code>。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针<code>g</code>的<code>next</code>方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的<code>yield</code>语句，上例是执行到<code>x + 2</code>为止。</p>\n<p>换言之，<code>next</code>方法的作用是分阶段执行<code>Generator</code>函数。每次调用<code>next</code>方法，会返回一个对象，表示当前阶段的信息（<code>value</code>属性和<code>done</code>属性）。<code>value</code>属性是<code>yield</code>语句后面表达式的值，表示当前阶段的值；<code>done</code>属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p>\n<h4> Generator 函数的数据交换和错误处理</h4>\n<p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p>\n<p><code>next</code>返回值的 value 属性，是 Generator 函数向外输出数据；<code>next</code>方法还可以接受参数，向 Generator 函数体内输入数据。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，第一个<code>next</code>方法的<code>value</code>属性，返回表达式<code>x + 2</code>的值<code>3</code>。第二个<code>next</code>方法带有参数<code>2</code>，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量<code>y</code>接收。因此，这一步的<code>value</code>属性，返回的就是<code>2</code>（变量<code>y</code>的值）。</p>\n<p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的最后一行，Generator 函数体外，使用指针对象的<code>throw</code>方法抛出的错误，可以被函数体内的<code>try...catch</code>代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>\n<h4> 异步任务的封装</h4>\n<p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了<code>yield</code>命令。</p>\n<p>执行这段代码的方法如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用<code>next</code>方法（第二行），执行异步任务的第一阶段。由于<code>Fetch</code>模块返回的是一个 Promise 对象，因此要用<code>then</code>方法调用下一个<code>next</code>方法。</p>\n<p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>\n<h3> Thunk 函数</h3>\n<p>Thunk 函数是自动执行 Generator 函数的一种方法。</p>\n<h4> 参数的求值策略</h4>\n<p>Thunk 函数早在上个世纪 60 年代就诞生了。</p>\n<p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是\"求值策略\"，即函数的参数到底应该何时求值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码先定义函数<code>f</code>，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？</p>\n<p>一种意见是\"传值调用\"（call by value），即在进入函数体之前，就计算<code>x + 5</code>的值（等于 6），再将这个值传入函数<code>f</code>。C 语言就采用这种策略。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一种意见是“传名调用”（call by name），即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>传值调用和传名调用，哪一种比较好？</p>\n<p>回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>f</code>的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于\"传名调用\"，即只在执行时求值。</p>\n<h4> Thunk 函数的含义</h4>\n<p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，函数 f 的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。</p>\n<p>这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。</p>\n<h4> JavaScript 语言的 Thunk 函数</h4>\n<p>JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>fs</code>模块的<code>readFile</code>方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。</p>\n<p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用上面的转换器，生成<code>fs.readFile</code>的 Thunk 函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是另一个完整的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Thunkify 模块</h4>\n<p>生产环境的转换器，建议使用 Thunkify 模块。</p>\n<p>首先是安装。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>使用方式如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>Thunkify 的源码与上一节那个简单的转换器非常像。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出一行结果。</p>\n<h4> Generator 函数的流程管理</h4>\n<p>你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。</p>\n<p>Generator 函数可以自动执行。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，Generator 函数<code>gen</code>会自动执行完所有步骤。</p>\n<p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>yield</code>命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。</p>\n<p>这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，变量<code>g</code>是 Generator 函数的内部指针，表示目前执行到哪一步。<code>next</code>方法负责将指针移动到下一步，并返回该步的信息（<code>value</code>属性和<code>done</code>属性）。</p>\n<p>仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入<code>next</code>方法的<code>value</code>属性。这使得我们可以用递归来自动完成这个过程。</p>\n<h4> Thunk 函数的自动流程管理</h4>\n<p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的<code>run</code>函数，就是一个 Generator 函数的自动执行器。内部的<code>next</code>函数就是 Thunk 的回调函数。<code>next</code>函数先将指针移到 Generator 函数的下一步（<code>gen.next</code>方法），然后判断 Generator 函数是否结束（<code>result.done</code>属性），如果没结束，就将<code>next</code>函数再传入 Thunk 函数（<code>result.value</code>属性），否则就直接退出。</p>\n<p>有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入<code>run</code>函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在<code>yield</code>命令后面的必须是 Thunk 函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>\n<p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>\n<h3> co 模块</h3>\n<h4> 基本用法</h4>\n<p><a href=\"https://github.com/tj/co\" target=\"_blank\" rel=\"noopener noreferrer\">co 模块</a>是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。</p>\n<p>下面是一个 Generator 函数，用于依次读取两个文件。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>co 模块可以让你不用编写 Generator 函数的执行器。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，Generator 函数只要传入<code>co</code>函数，就会自动执行。</p>\n<p><code>co</code>函数返回一个<code>Promise</code>对象，因此可以用<code>then</code>方法添加回调函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。</p>\n<h4> co 模块的原理</h4>\n<p>为什么 co 可以自动执行 Generator 函数？</p>\n<p>前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>\n<p>两种方法可以做到这一点。</p>\n<p>（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p>\n<p>（2）Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</p>\n<p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的<code>yield</code>命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。</p>\n<p>上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。</p>\n<h4> 基于 Promise 对象的自动执行</h4>\n<p>还是沿用上面的例子。首先，把<code>fs</code>模块的<code>readFile</code>方法包装成一个 Promise 对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后，手动执行上面的 Generator 函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>手动执行其实就是用<code>then</code>方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，只要 Generator 函数还没执行到最后一步，<code>next</code>函数就调用自身，以此实现自动执行。</p>\n<h4> co 模块的源码</h4>\n<p>co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p>\n<p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>在返回的 Promise 对象里面，co 先检查参数<code>gen</code>是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为<code>resolved</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>接着，co 将 Generator 函数的内部指针对象的<code>next</code>方法，包装成<code>onFulfilled</code>函数。这主要是为了能够捕捉抛出的错误。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后，就是关键的<code>next</code>函数，它会反复调用自身。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>next</code>函数的内部代码，一共只有四行命令。</p>\n<p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p>\n<p>第二行，确保每一步的返回值，是 Promise 对象。</p>\n<p>第三行，使用<code>then</code>方法，为返回值加上回调函数，然后通过<code>onFulfilled</code>函数再次调用<code>next</code>函数。</p>\n<p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为<code>rejected</code>，从而终止执行。</p>\n<h4> 处理并发的异步操作</h4>\n<p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>\n<p>这时，要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面是另一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码允许并发三个<code>somethingAsync</code>异步操作，等到它们全部完成，才会进行下一步。</p>\n<h4> 实例：处理 Stream</h4>\n<p>Node 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件。</p>\n<ul>\n<li><code>data</code>事件：下一块数据块已经准备好了。</li>\n<li><code>end</code>事件：整个“数据流”处理完了。</li>\n<li><code>error</code>事件：发生错误。</li>\n</ul>\n<p>使用<code>Promise.race()</code>函数，可以判断这三个事件之中哪一个最先发生，只有当<code>data</code>事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个<code>while</code>循环，完成所有数据的读取。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用<code>stream.once</code>方法，在<code>data</code>、<code>end</code>、<code>error</code>三个事件上添加一次性回调函数。变量<code>res</code>只有在<code>data</code>事件发生时才有值，然后累加每个数据块之中<code>valjean</code>这个词出现的次数。</p>\n<h2> async 函数</h2>\n<h3> 本质</h3>\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>\n<p><strong><code>async</code>函数对 Generator 函数的改进，体现在以下四点:</strong></p>\n<p>（1）内置执行器。</p>\n<p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p>\n<p>（2）更好的语义。</p>\n<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>\n<p>（3）更广的适用性。</p>\n<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>\n<p>（4）返回值是 Promise。</p>\n<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>\n<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>\n<h3> 基本用法</h3>\n<p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n<p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p>\n<p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>async 函数有多种使用形式。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 语法详解</h3>\n<p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p>\n<h4> 返回 Promise 对象</h4>\n<p><code>async</code>函数返回一个 Promise 对象。</p>\n<p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p>\n<p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Promise 对象的状态变化</h4>\n<p>**<code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。**也就是说，<strong>只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</strong></p>\n<p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p>\n<h4> await 命令</h4>\n<p><strong>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p>\n<p><strong>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p>\n<p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p>\n<p><strong>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p>\n<p><strong>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 错误处理</h4>\n<p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p>\n<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p>\n<h4> 使用注意点</h4>\n<p><strong>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>\n<p><strong>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一种方法是使用数组的<code>reduce()</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，<code>reduce()</code>方法的第一个参数是<code>async</code>函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用<code>await</code>等待它操作结束。另外，<code>reduce()</code>方法返回的是<code>docs</code>数组最后一个成员的<code>async</code>函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上<code>await</code>。</p>\n<p>上面的<code>reduce()</code>的参数函数里面没有<code>return</code>语句，原因是这个函数的主要目的是<code>db.post()</code>操作，不是返回值。而且<code>async</code>函数不管有没有<code>return</code>语句，总是返回一个 Promise 对象，所以这里的<code>return</code>是不必要的。</p>\n<p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>第四点，async 函数可以保留运行堆栈。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p>\n<p>现在将这个例子改成<code>async</code>函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p>\n<h3> async 函数的实现原理</h3>\n<p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p>\n<p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 与其他异步处理方法的比较</h3>\n<p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p>\n<p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>\n<p>首先是 Promise 的写法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p>\n<p>接着是 Generator 函数的写法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p>\n<p>最后是 async 函数的写法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p>\n<h3> 顶层 await</h3>\n<p>根据语法规格，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，<code>await</code>命令独立使用，没有放在 async 函数里面，就会报错。</p>\n<p>目前，有一个<a href=\"https://github.com/tc39/proposal-top-level-await\" target=\"_blank\" rel=\"noopener noreferrer\">语法提案</a>，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。这个提案的目的，是借用<code>await</code>解决模块异步加载的问题。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p>\n<p>上面的代码也可以写成立即执行函数的形式。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>下面是加载这个模块的写法。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，<code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code>。</p>\n<p>目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。</p>\n<p>下面是加载这个模块的新的写法。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p>\n<p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的<code>usage.js</code>又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。</p>\n<p>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值。</p>\n<p>加载这个模块的写法如下。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p>\n<p>这时，模块的加载会等待依赖模块（上例是<code>awaiting.js</code>）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p>\n<p>注意，顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</p>\n<p>下面是顶层<code>await</code>的一些使用场景。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，如果加载多个包含顶层<code>await</code>命令的模块，加载命令是同步执行的。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码有三个模块，最后的<code>z.js</code>加载<code>x.js</code>和<code>y.js</code>，打印结果是<code>X1</code>、<code>Y</code>、<code>X2</code>、<code>Z</code>。这说明，<code>z.js</code>并没有等待<code>x.js</code>加载完成，再去加载<code>y.js</code>。</p>\n<p>顶层的<code>await</code>命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "13.Set",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses13.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses13.html",
      "summary": "概念 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 基本语法 构造函数 Set本身是一个构造函数，用来生成 Set 数据结构。 上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。 Set函数可以接受一个数组（或者具有 Iterable 接口的其他数据结构）作为参数，用...",
      "content_html": "<h1> Set</h1>\n<h2> 概念</h2>\n<p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<h2> 基本语法</h2>\n<h3> 构造函数</h3>\n<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p>\n<p><code>Set</code>函数可以接受一个数组（<strong>或者具有 Iterable 接口的其他数据结构</strong>）作为参数，用来初始化。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>\n<h3> 注意点</h3>\n<p><strong>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>\"5\"</code>是两个不同的值。</strong></p>\n<p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码向 Set 实例添加了两次<code>NaN</code>，但是只会加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等的。</p>\n<p>另外，两个对象总是不相等的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>\n<h2> 实例的属性和方法</h2>\n<p>Set 结构的实例有以下属性。</p>\n<ul>\n<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>\n<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>\n</ul>\n<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>\n<ul>\n<li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li>\n<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>\n<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>\n<li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li>\n</ul>\n<p>上面这些属性和方法的实例如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Set 与 Array 的相互转化</h2>\n<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这就提供了去除数组重复成员的另一种方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>而将数组转化成 Set，只需要使用 Set 的 构造函数即可。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码也展示了一种去除数组重复成员的方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的方法也可以用于，去除字符串里面的重复字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 遍历操作</h2>\n<h3> 概述</h3>\n<p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>\n<ul>\n<li><code>Set.prototype.keys()</code>：返回键名的遍历器</li>\n<li><code>Set.prototype.values()</code>：返回键值的遍历器</li>\n<li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li>\n<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li>\n</ul>\n<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>\n<h3> keys()&amp;values()&amp;entries()</h3>\n<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> forEach()</h3>\n<p><strong>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>\n<p><strong>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</strong></p>\n<h3> 遍历的应用</h3>\n<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p>\n<h2> WeakSet</h2>\n<h3> 含义</h3>\n<p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>\n<p><strong>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象。</strong></p>\n<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>\n<p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为<code>0</code>，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>\n<p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p>\n<p>这些特点同样适用于本章后面要介绍的 WeakMap 结构。</p>\n<h3> 语法</h3>\n<p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为 WeakSet 构造函数的参数，<code>a</code>的成员会自动成为 WeakSet 的成员。</p>\n<p>注意，是<code>a</code>数组的成员成为 WeakSet 的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，数组<code>b</code>的成员不是对象，加入 WeakSet 就会报错。</p>\n<p>WeakSet 结构有以下三个方法。</p>\n<ul>\n<li><strong>WeakSet.prototype.add(value)</strong>：向 WeakSet 实例添加一个新成员。</li>\n<li><strong>WeakSet.prototype.delete(value)</strong>：清除 WeakSet 实例的指定成员。</li>\n<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>\n</ul>\n<p>下面是一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p>\n<p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<p>下面是 WeakSet 的另一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用 WeakSet 的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "14.Map",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses14.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses14.html",
      "summary": "概念 JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 上面代码原意是将一个 DOM 节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。 为了解决这个问题，ES6 ...",
      "content_html": "<h1> Map</h1>\n<h2> 概念</h2>\n<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p>\n<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>\n<h2> 基本用法</h2>\n<h3> 构造函数</h3>\n<p><strong>作为构造函数，Map 也可以接受一个数组作为参数。</strong></p>\n<p><strong>该数组的成员是一个个表示键值对的数组。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>\n<p><strong><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p>\n<h3> 注意点</h3>\n<p><strong>如果对同一个键多次赋值，后面的值将覆盖前面的值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p>\n<p><strong>如果读取一个未知的键，则返回<code>undefined</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>\n<p><strong>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p>\n<h3> 键的本质</h3>\n<p><strong>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</strong></p>\n<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 实例的属性和操作方法</h2>\n<p>Map 结构的实例有以下属性和操作方法。</p>\n<h3> size 属性</h3>\n<p><code>size</code>属性返回 Map 结构的成员总数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Map.prototype.set(key, value)</h3>\n<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Map.prototype.get(key)</h3>\n<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Map.prototype.has(key)</h3>\n<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Map.prototype.delete(key)</h3>\n<p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Map.prototype.clear()</h3>\n<p><code>clear</code>方法清除所有成员，没有返回值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 遍历方法</h2>\n<h3> 概述</h3>\n<p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>\n<ul>\n<li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li>\n<li><code>Map.prototype.values()</code>：返回键值的遍历器。</li>\n<li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li>\n<li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li>\n</ul>\n<p><strong>需要特别注意的是，Map 的遍历顺序就是插入顺序。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>\n<h3> 遍历的应用</h3>\n<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 与其他数据结构的互相转换</h2>\n<h3> Map 转为数组</h3>\n<p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 数组 转为 Map</h3>\n<p>将数组传入 Map 构造函数，就可以转为 Map。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Map 转为对象</h3>\n<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>\n<h3> 对象转为 Map</h3>\n<p>对象转为 Map 可以通过<code>Object.entries()</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>此外，也可以自己实现一个转换函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Map 转为 JSON</h3>\n<p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> JSON 转为 Map</h3>\n<p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> WeakMap</h2>\n<h3> 含义</h3>\n<p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p>\n<p>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p>\n<p>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p>\n<p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p>\n<p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p>\n<p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>\n<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p>\n<p>也就是说，上面的 DOM 节点对象的引用计数是<code>1</code>，而不是<code>2</code>。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p>\n<p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>\n<p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在 WeakMap 外部消除了<code>obj</code>的引用，WeakMap 内部的引用依然存在。</p>\n<h3> WeakMap 的语法</h3>\n<p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> WeakMap 的示例</h3>\n<p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p>\n<p>贺师俊老师<a href=\"https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104\" target=\"_blank\" rel=\"noopener noreferrer\">提示</a>，如果引用所指向的值占用特别多的内存，就可以通过 Node 的<code>process.memoryUsage</code>方法看出来。根据这个思路，网友<a href=\"https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925\" target=\"_blank\" rel=\"noopener noreferrer\">vtxf</a>补充了下面的例子。</p>\n<p>首先，打开 Node 命令行。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p>\n<p>然后，执行下面的代码。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。</p>\n<p>Chrome 浏览器的 Dev Tools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收（garbage collect）。这个按钮也能用来观察 WeakMap 里面的引用是否消失。</p>\n<h3> WeakMap 的用途</h3>\n<p>前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>document.getElementById('logo')</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>\n<p>WeakMap 的另一个用处是部署私有属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Countdown</code>类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "15.Iterator",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses15.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses15.html",
      "summary": "设计目的 JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和`Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是这样一种机...",
      "content_html": "<h1> Iterator</h1>\n<h2> 设计目的</h2>\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。<strong>这样就需要一种统一的接口机制，来处理所有不同的数据结构。</strong></p>\n<p>遍历器（Iterator）就是这样一种机制。它是一种接口，<strong>为各种不同的数据结构提供统一的访问机制</strong>。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>\n<p>Iterator 的作用有三个：</p>\n<ol>\n<li>为各种数据结构，提供一个统一的、简便的访问接口</li>\n<li>使得数据结构的成员能够按某种次序排列；</li>\n<li>ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</li>\n</ol>\n<h2> Iterator 遍历过程</h2>\n<p>Iterator 的遍历过程是这样的。</p>\n<p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>\n<p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p>\n<p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p>\n<p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p>\n<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>\n<p>下面是一个模拟<code>next</code>方法返回值的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>['a', 'b']</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p>\n<h2> next 方法</h2>\n<p><strong>指针对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</strong></p>\n<p><strong><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法</strong></p>\n<p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p>\n<p>对于遍历器对象来说，<code>done: false</code>和<code>value: undefined</code>属性都是可以省略的，因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的例子中，遍历器生成函数<code>idMaker</code>，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p>\n<p>如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和<code>next</code>方法返回值的规格可以描述如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 默认 Iterator 接口</h2>\n<h3> 基本概念</h3>\n<p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>\n<p><strong>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</strong></p>\n<p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，<strong>一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）</strong>。</p>\n<p><strong><code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</strong></p>\n<p>至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，对象<code>obj</code>是可遍历的（iterable），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p>\n<h3> 具备 Iterator 接口的数据类型</h3>\n<p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>\n<p>原生具备 Iterator 接口的数据结构如下。</p>\n<ul>\n<li>Array</li>\n<li>Map</li>\n<li>Set</li>\n<li>String</li>\n<li>TypedArray</li>\n<li>函数的 arguments 对象</li>\n<li>NodeList 对象</li>\n</ul>\n<p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p>\n<p><strong>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</strong></p>\n<h3> 对象与 Iterator</h3>\n<p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。</p>\n<p><strong>本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。</strong></p>\n<p>不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p>\n<p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码是一个类部署 Iterator 接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象。</p>\n<h3> 为对象添加 Iterator 接口</h3>\n<p>下面是另一个为对象添加 Iterator 接口的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署 Iterator 接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的 Iterator 接口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>NodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性，可以看到没有任何影响。</p>\n<p>下面是另一个类似数组的对象调用数组的<code>Symbol.iterator</code>方法的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，普通对象部署数组的<code>Symbol.iterator</code>方法，并无效果。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面是通过遍历器实现指针结构的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法，调用该方法会返回遍历器对象<code>iterator</code>，调用该对象的<code>next</code>方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p>\n<h3> 注意点</h3>\n<p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，因此报错。</p>\n<p>有了遍历器接口，数据结构就可以用<code>for...of</code>循环遍历（详见下文），也可以使用<code>while</code>循环遍历。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>ITERABLE</code>代表某种可遍历的数据结构，<code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法），都检查一下返回值的<code>done</code>属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（<code>next</code>方法），不断循环。</p>\n<h2> 调用 Iterator 接口的场合</h2>\n<p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p>\n<h3> 解构赋值</h3>\n<p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 扩展运算符</h3>\n<p>扩展运算符（...）也会调用默认的 Iterator 接口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的扩展运算符内部就调用 Iterator 接口。</p>\n<p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> yield*</h3>\n<p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 其他场合</h3>\n<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子：</p>\n<ul>\n<li>for...of</li>\n<li>Array.from()</li>\n<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([['a',1],['b',2]])</code>）</li>\n<li>Promise.all()</li>\n<li>Promise.race()</li>\n</ul>\n<h2> 字符串的 Iterator 接口</h2>\n<p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。</p>\n<p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改遍历器行为的目的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，字符串 str 的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（<code>...</code>）返回的值变成了<code>bye</code>，而字符串本身还是<code>hi</code>。</p>\n<h2> Iterator 接口与 Generator 函数</h2>\n<p><code>Symbol.iterator()</code>方法的最简单实现，还是使用需要 Generator 函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Symbol.iterator()</code>方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。</p>\n<h2> 遍历器对象的 return()，throw()</h2>\n<p>遍历器对象除了具有<code>next()</code>方法，还可以具有<code>return()</code>方法和<code>throw()</code>方法。如果你自己写遍历器对象生成函数，那么<code>next()</code>方法是必须部署的，<code>return()</code>方法和<code>throw()</code>方法是否部署是可选的。</p>\n<p><code>return()</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return()</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return()</code>方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next()</code>方法，还部署了<code>return()</code>方法。下面的两种情况，都会触发执行<code>return()</code>方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，情况一输出文件的第一行以后，就会执行<code>return()</code>方法，关闭这个文件；情况二会在执行<code>return()</code>方法关闭文件之后，再抛出错误。</p>\n<p>注意，<code>return()</code>方法必须返回一个对象，这是 Generator 语法决定的。</p>\n<p><code>throw()</code>方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。</p>\n<h2> 添加与修改 Iterator 接口</h2>\n<h3> 直接实现</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用Generator</h3>\n<p>这是比较推荐的写法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> for...of 循环</h2>\n<p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p>\n<p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p>\n<p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM 的 NodeList 对象）、后文的 Generator 对象，以及字符串。</p>\n<h3> 数组</h3>\n<p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性，结果<code>obj</code>的<code>for...of</code>循环，产生了与<code>arr</code>完全一样的结果。</p>\n<p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法（参见《数组的扩展》一章）。</p>\n<p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p>\n<h3> Set 和 Map 结构</h3>\n<p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用<code>for...of</code>循环。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 计算生成的数据结构</h3>\n<p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p>\n<ul>\n<li><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用<code>entries</code>方法。</li>\n<li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li>\n<li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li>\n</ul>\n<p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 类似数组的对象</h3>\n<p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList 对象、<code>arguments</code>对象的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 对象</h3>\n<p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p>\n<p>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一个方法是使用 Generator 函数将对象重新包装一下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 各种遍历语法的比较</h2>\n<p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是<code>for</code>循环。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</strong></p>\n<p><code>for...in</code>循环可以遍历数组的键名。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>for...in</code>循环有几个缺点：</strong></p>\n<ul>\n<li>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li>\n<li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li>\n<li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li>\n</ul>\n<p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</p>\n<p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><ul>\n<li>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</li>\n<li>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</li>\n<li>提供了遍历所有数据结构的统一操作接口。</li>\n</ul>\n<p>下面是一个使用 break 语句，跳出<code>for...of</code>循环的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "16.异步遍历器",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses16.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses16.html",
      "summary": "同步遍历器的问题 Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法返回的对象的结构是{value, done}，其中value表示当前的数据的值，done是一个布尔值，表示遍历是否结束。 上面代码中，变量it是一个遍历器（iterator）。每次调用it....",
      "content_html": "<h1> 异步遍历器</h1>\n<h2> 同步遍历器的问题</h2>\n<p>Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，变量<code>it</code>是一个遍历器（iterator）。每次调用<code>it.next()</code>方法，就返回一个对象，表示当前遍历位置的信息。</p>\n<p><strong>这里隐含着一个规定，<code>it.next()</code>方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行<code>it.next()</code>方法，就必须同步地得到<code>value</code>和<code>done</code>这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>上面代码中，<code>next()</code>方法返回的是一个 Promise 对象，这样就不行，不符合 Iterator 协议，只要代码里面包含异步操作都不行。也就是说，Iterator 协议里面<code>next()</code>方法只能包含同步操作。</strong></p>\n<p>目前的解决方法是，将异步操作包装成 Thunk 函数或者 Promise 对象，即<code>next()</code>方法返回值的<code>value</code>属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而<code>done</code>属性则还是同步产生的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>value</code>属性的返回值是一个 Promise 对象，用来放置异步操作。但是这样写很麻烦，不太符合直觉，语义也比较绕。</p>\n<p>ES2018 <a href=\"https://github.com/tc39/proposal-async-iteration\" target=\"_blank\" rel=\"noopener noreferrer\">引入</a>了“异步遍历器”（Async Iterator），为异步操作提供原生的遍历器接口，即<code>value</code>和<code>done</code>这两个属性都是异步产生。</p>\n<h2> 异步遍历的接口</h2>\n<p>异步遍历器的最大的语法特点，就是调用遍历器的<code>next</code>方法，返回的是一个 Promise 对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>asyncIterator</code>是一个异步遍历器，调用<code>next</code>方法以后，返回一个 Promise 对象。因此，可以使用<code>then</code>方法指定，这个 Promise 对象的状态变为<code>resolve</code>以后的回调函数。回调函数的参数，则是一个具有<code>value</code>和<code>done</code>两个属性的对象，这个跟同步遍历器是一样的。</p>\n<p>我们知道，一个对象的同步遍历器的接口，部署在<code>Symbol.iterator</code>属性上面。同样地，对象的异步遍历器接口，部署在<code>Symbol.asyncIterator</code>属性上面。不管是什么样的对象，只要它的<code>Symbol.asyncIterator</code>属性有值，就表示应该对它进行异步遍历。</p>\n<p>下面是一个异步遍历器的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象<code>resolve</code>了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。</p>\n<p>由于异步遍历器的<code>next</code>方法，返回的是一个 Promise 对象。因此，可以把它放在<code>await</code>命令后面。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>next</code>方法用<code>await</code>处理以后，就不必使用<code>then</code>方法了。整个流程已经很接近同步处理了。</p>\n<p>注意，异步遍历器的<code>next</code>方法是可以连续调用的，不必等到上一步产生的 Promise 对象<code>resolve</code>以后再调用。这种情况下，<code>next</code>方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的<code>next</code>方法放在<code>Promise.all</code>方法里面。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一种用法是一次性调用所有的<code>next</code>方法，然后<code>await</code>最后一步操作。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> for await...of</h2>\n<p>前面介绍过，<code>for...of</code>循环用于遍历同步的 Iterator 接口。新引入的<code>for await...of</code>循环，则是用于遍历异步的 Iterator 接口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>createAsyncIterable()</code>返回一个拥有异步遍历器接口的对象，<code>for...of</code>循环自动调用这个对象的异步遍历器的<code>next</code>方法，会得到一个 Promise 对象。<code>await</code>用来处理这个 Promise 对象，一旦<code>resolve</code>，就把得到的值（<code>x</code>）传入<code>for...of</code>的循环体。</p>\n<p><code>for await...of</code>循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>req</code>是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用<code>for await...of</code>循环以后，代码会非常简洁。</p>\n<p>如果<code>next</code>方法返回的 Promise 对象被<code>reject</code>，<code>for await...of</code>就会报错，要用<code>try...catch</code>捕捉。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>for await...of</code>循环也可以用于同步遍历器。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>Node v10 支持异步遍历器，Stream 就部署了这个接口。下面是读取文件的传统写法与异步遍历器写法的差异。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 异步 Generator 函数</h2>\n<p>就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。</p>\n<p>在语法上，异步 Generator 函数就是<code>async</code>函数与 Generator 函数的结合。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>gen</code>是一个异步 Generator 函数，执行后返回一个异步 Iterator 对象。对该对象调用<code>next</code>方法，返回一个 Promise 对象。</p>\n<p>异步遍历器的设计目的之一，就是 Generator 函数处理同步操作和异步操作时，能够使用同一套接口。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>map</code>是一个 Generator 函数，第一个参数是可遍历对象<code>iterable</code>，第二个参数是一个回调函数<code>func</code>。<code>map</code>的作用是将<code>iterable</code>每一步返回的值，使用<code>func</code>进行处理。上面有两个版本的<code>map</code>，前一个处理同步遍历器，后一个处理异步遍历器，可以看到两个版本的写法基本上是一致的。</p>\n<p>下面是另一个异步 Generator 函数的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，异步操作前面使用<code>await</code>关键字标明，即<code>await</code>后面的操作，应该返回 Promise 对象。凡是使用<code>yield</code>关键字的地方，就是<code>next</code>方法停下来的地方，它后面的表达式的值（即<code>await file.readLine()</code>的值），会作为<code>next()</code>返回对象的<code>value</code>属性，这一点是与同步 Generator 函数一致的。</p>\n<p>异步 Generator 函数内部，能够同时使用<code>await</code>和<code>yield</code>命令。可以这样理解，<code>await</code>命令用于将外部操作产生的值输入函数内部，<code>yield</code>命令用于将函数内部的值输出。</p>\n<p>上面代码定义的异步 Generator 函数的用法如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>异步 Generator 函数可以与<code>for await...of</code>循环结合起来使用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>异步 Generator 函数的返回值是一个异步 Iterator，即每次调用它的<code>next</code>方法，会返回一个 Promise 对象，也就是说，跟在<code>yield</code>命令后面的，应该是一个 Promise 对象。如果像上面那个例子那样，<code>yield</code>命令后面是一个字符串，会被自动包装成一个 Promise 对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>ag</code>是<code>asyncGenerator</code>函数返回的异步遍历器对象。调用<code>ag.next()</code>以后，上面代码的执行顺序如下。</p>\n<ol>\n<li><code>ag.next()</code>立刻返回一个 Promise 对象。</li>\n<li><code>asyncGenerator</code>函数开始执行，打印出<code>Start</code>。</li>\n<li><code>await</code>命令返回一个 Promise 对象，<code>asyncGenerator</code>函数停在这里。</li>\n<li>A 处变成 fulfilled 状态，产生的值放入<code>result</code>变量，<code>asyncGenerator</code>函数继续往下执行。</li>\n<li>函数在 B 处的<code>yield</code>暂停执行，一旦<code>yield</code>命令取到值，<code>ag.next()</code>返回的那个 Promise 对象变成 fulfilled 状态。</li>\n<li><code>ag.next()</code>后面的<code>then</code>方法指定的回调函数开始执行。该回调函数的参数是一个对象<code>{value, done}</code>，其中<code>value</code>的值是<code>yield</code>命令后面的那个表达式的值，<code>done</code>的值是<code>false</code>。</li>\n</ol>\n<p>A 和 B 两行的作用类似于下面的代码。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果异步 Generator 函数抛出错误，会导致 Promise 对象的状态变为<code>reject</code>，然后抛出的错误被<code>catch</code>方法捕获。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步 Iterator 对象。可以这样理解，async 函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过<code>for await...of</code>执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，异步 Generator 函数产生的异步遍历器，会通过<code>while</code>循环自动执行，每当<code>await iterator.next()</code>完成，就会进入下一轮循环。一旦<code>done</code>属性变为<code>true</code>，就会跳出循环，异步遍历器执行结束。</p>\n<p>下面是这个自动执行器的一个使用实例。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>异步 Generator 函数出现以后，JavaScript 就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。基本上，如果是一系列按照顺序执行的异步操作（比如读取文件，然后写入新内容，再存入硬盘），可以使用 async 函数；如果是一系列产生相同数据结构的异步操作（比如一行一行读取文件），可以使用异步 Generator 函数。</p>\n<p>异步 Generator 函数也可以通过<code>next</code>方法的参数，接收外部传入的数据。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>openFile</code>是一个异步 Generator 函数。<code>next</code>方法的参数，向该函数内部的操作传入数据。每次<code>next</code>方法都是同步执行的，最后的<code>await</code>命令用于等待整个写入操作结束。</p>\n<p>最后，同步的数据结构，也可以使用异步 Generator 函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，由于没有异步操作，所以也就没有使用<code>await</code>关键字。</p>\n<h2> yield* 语句</h2>\n<p><code>yield*</code>语句也可以跟一个异步遍历器。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>gen2</code>函数里面的<code>result</code>变量，最后的值是<code>2</code>。</p>\n<p>与同步 Generator 函数一样，<code>for await...of</code>循环会展开<code>yield*</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "17.Proxy",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses17.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses17.html",
      "summary": "设计意义 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示...",
      "content_html": "<h1> Proxy</h1>\n<h2> 设计意义</h2>\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>\n<h2> 基本使用</h2>\n<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>\n<p><strong>注意，Proxy不仅可以拦截对象，也可以拦截数组、函数（因为它们本质上也是对象）。</strong></p>\n<p>下面是另一个拦截读取属性行为的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。</p>\n<p>第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象。</p>\n<p>第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。</p>\n<p>比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p>\n<p><strong>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</strong></p>\n<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p>\n<p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>Proxy 实例也可以作为其他对象的原型对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>\n<p>同一个拦截器函数，可以设置拦截多个操作。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>\n<h2> Proxy 实例的方法</h2>\n<h3> 概述</h3>\n<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>\n<ul>\n<li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy['foo']</code>。</li>\n<li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy['foo'] = v</code>，返回一个布尔值。</li>\n<li><strong>has(target, propKey)</strong>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>\n<li><strong>deleteProperty(target, propKey)</strong>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>\n<li><strong>ownKeys(target)</strong>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>\n<li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>\n<li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>\n<li><strong>preventExtensions(target)</strong>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>\n<li><strong>getPrototypeOf(target)</strong>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>\n<li><strong>isExtensible(target)</strong>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>\n<li><strong>setPrototypeOf(target, proto)</strong>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>\n<li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>\n<li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>\n</ul>\n<p>下面是上面这些拦截方法的详细介绍。</p>\n<h3> get()</h3>\n<p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p>\n<p><code>get</code>方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p>\n<p><code>get</code>方法可以继承。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p>\n<p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以<code>receiver</code>指向<code>proxy</code>对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，<code>receiver</code>就指向<code>d</code>，代表原始的读操作所在的那个对象。</p>\n<p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>应用</strong></p>\n<p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p>\n<p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p>\n<p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种 DOM 节点的通用函数<code>dom</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> set()</h3>\n<p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p>\n<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p>\n<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>\n<p>下面是<code>set</code>方法第四个参数的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，设置<code>myObj.foo</code>属性的值时，<code>myObj</code>并没有<code>foo</code>属性，因此引擎会到<code>myObj</code>的原型链去找<code>foo</code>属性。<code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例，设置它的<code>foo</code>属性会触发<code>set</code>方法。这时，第四个参数<code>receiver</code>就指向原始赋值行为所在的对象<code>myObj</code>。</p>\n<p>注意，如果目标对象自身的某个属性不可写，那么<code>set</code>方法将不起作用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>obj.foo</code>属性不可写，Proxy 对这个属性的<code>set</code>代理将不会生效。</p>\n<p>注意，<code>set</code>代理应当返回一个布尔值。严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，严格模式下，<code>set</code>代理返回<code>false</code>或者<code>undefined</code>，都会报错。</p>\n<h3> apply()</h3>\n<p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p>\n<p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p>\n<p>下面是另外一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p>\n<p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> has()</h3>\n<p><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p>\n<p><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p>\n<p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p>\n<p>如果原对象不可配置或者禁止扩展，这时<code>has()</code>拦截会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has()</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p>\n<p>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p>\n<p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>has()</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p>\n<h3> construct()</h3>\n<p><code>construct()</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>construct()</code>方法可以接受三个参数。</p>\n<ul>\n<li><code>target</code>：目标对象。</li>\n<li><code>args</code>：构造函数的参数数组。</li>\n<li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>construct()</code>方法返回的必须是一个对象，否则会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另外，由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，拦截的目标对象不是一个函数，而是一个对象（<code>new Proxy()</code>的第一个参数），导致报错。</p>\n<p>注意，<code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> deleteProperty()</h3>\n<p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p>\n<p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</p>\n<h3> defineProperty()</h3>\n<p><code>defineProperty()</code>方法拦截了<code>Object.defineProperty()</code>操作。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>defineProperty()</code>方法内部没有任何操作，只返回<code>false</code>，导致添加新属性总是无效。注意，这里的<code>false</code>只是用来提示操作失败，本身并不能阻止添加新属性。</p>\n<p>注意，如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</p>\n<h3> getOwnPropertyDescriptor()</h3>\n<p><code>getOwnPropertyDescriptor()</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p>\n<h3> getPrototypeOf()</h3>\n<p><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p>\n<ul>\n<li><code>Object.prototype.__proto__</code></li>\n<li><code>Object.prototype.isPrototypeOf()</code></li>\n<li><code>Object.getPrototypeOf()</code></li>\n<li><code>Reflect.getPrototypeOf()</code></li>\n<li><code>instanceof</code></li>\n</ul>\n<p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p>\n<p>注意，<code>getPrototypeOf()</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象。</p>\n<h3> isExtensible()</h3>\n<p><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p>\n<p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p>\n<p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> ownKeys()</h3>\n<p><code>ownKeys()</code>方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>\n<ul>\n<li><code>Object.getOwnPropertyNames()</code></li>\n<li><code>Object.getOwnPropertySymbols()</code></li>\n<li><code>Object.keys()</code></li>\n<li><code>for...in</code>循环</li>\n</ul>\n<p>下面是拦截<code>Object.keys()</code>的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p>\n<p>下面的例子是拦截第一个字符为下划线的属性名。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>方法自动过滤，不会返回。</p>\n<ul>\n<li>目标对象上不存在的属性</li>\n<li>属性名为 Symbol 值</li>\n<li>不可遍历（<code>enumerable</code>）的属性</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>ownKeys()</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for('secret')</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p>\n<p><code>ownKeys()</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>for...in</code>循环也受到<code>ownKeys()</code>方法的拦截。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>ownkeys()</code>指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p>\n<p><code>ownKeys()</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>ownKeys()</code>方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p>\n<p>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys()</code>方法返回，否则报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys()</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p>\n<p>另外，如果目标对象是不可扩展的（non-extensible），这时<code>ownKeys()</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>obj</code>对象是不可扩展的，这时<code>ownKeys()</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p>\n<h3> preventExtensions()</h3>\n<p><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p>\n<p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>proxy.preventExtensions()</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p>\n<p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> setPrototypeOf()</h3>\n<p><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</p>\n<p>下面是一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p>\n<p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p>\n<h2> Proxy.revocable()</h2>\n<p><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p>\n<p><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>\n<h2> this 问题</h2>\n<p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p>\n<p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p>\n<p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p>\n<h2> 应用实例</h2>\n<h3> 使用 Proxy 实现观察者模式</h3>\n<p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，数据对象<code>person</code>是观察目标，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p>\n<p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</p>\n<h3> Web 服务的客户端</h3>\n<p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "18.Reflect",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses18.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses18.html",
      "summary": "设计目的 Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个： （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和`Reflect对象上部署，未来的新方法将只部署...",
      "content_html": "<h1> Reflect</h1>\n<h2> 设计目的</h2>\n<p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个：</p>\n<p>（1） **将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。**现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>\n<p>（2） **修改某些<code>Object</code>方法的返回结果，让其变得更合理。**比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>（3） **让<code>Object</code>操作都变成函数行为。**某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>（4）**<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。**这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p>\n<p>下面是另一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>\n<p>有了<code>Reflect</code>对象以后，很多操作会更易读。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 静态方法</h2>\n<h3> 概述</h3>\n<p><code>Reflect</code>对象一共有 13 个静态方法。</p>\n<ul>\n<li>Reflect.apply(target, thisArg, args)</li>\n<li>Reflect.construct(target, args)</li>\n<li>Reflect.get(target, name, receiver)</li>\n<li>Reflect.set(target, name, value, receiver)</li>\n<li>Reflect.defineProperty(target, name, desc)</li>\n<li>Reflect.deleteProperty(target, name)</li>\n<li>Reflect.has(target, name)</li>\n<li>Reflect.ownKeys(target)</li>\n<li>Reflect.isExtensible(target)</li>\n<li>Reflect.preventExtensions(target)</li>\n<li>Reflect.getOwnPropertyDescriptor(target, name)</li>\n<li>Reflect.getPrototypeOf(target)</li>\n<li>Reflect.setPrototypeOf(target, prototype)</li>\n</ul>\n<p>上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。</p>\n<h3> Reflect.get(target, name, receiver)</h3>\n<p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Reflect.set(target, name, value, receiver)</h3>\n<p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了<code>receiver</code>，那么<code>Reflect.set</code>会触发<code>Proxy.defineProperty</code>拦截。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Proxy.set</code>拦截里面使用了<code>Reflect.set</code>，而且传入了<code>receiver</code>，导致触发<code>Proxy.defineProperty</code>拦截。这是因为<code>Proxy.set</code>的<code>receiver</code>参数总是指向当前的 <code>Proxy</code>实例（即上例的<code>obj</code>），而<code>Reflect.set</code>一旦传入<code>receiver</code>，就会将属性赋值到<code>receiver</code>上面（即<code>obj</code>），导致触发<code>defineProperty</code>拦截。如果<code>Reflect.set</code>没有传入<code>receiver</code>，那么就不会触发<code>defineProperty</code>拦截。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Reflect.has(obj, name)</h3>\n<p><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p>\n<h3> Reflect.deleteProperty(obj, name)</h3>\n<p><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p>\n<p>如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错。</p>\n<h3> Reflect.construct(target, args)</h3>\n<p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果<code>Reflect.construct()</code>方法的第一个参数不是函数，会报错。</p>\n<h3> Reflect.getPrototypeOf(obj)</h3>\n<p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果参数不是对象，<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Reflect.setPrototypeOf(obj, newProto)</h3>\n<p><code>Reflect.setPrototypeOf</code>方法用于设置目标对象的原型（prototype），对应<code>Object.setPrototypeOf(obj, newProto)</code>方法。它返回一个布尔值，表示是否设置成功。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeOf</code>方法返回<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果第一个参数不是对象，<code>Object.setPrototypeOf</code>会返回第一个参数本身，而<code>Reflect.setPrototypeOf</code>会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果第一个参数是<code>undefined</code>或<code>null</code>，<code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code>都会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Reflect.apply(func, thisArg, args)</h3>\n<p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p>\n<p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Reflect.defineProperty(target, propertyKey, attributes)</h3>\n<p><code>Reflect.defineProperty</code>方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code>Reflect.defineProperty</code>代替它。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果<code>Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(1, 'foo')</code>。</p>\n<p>这个方法可以与<code>Proxy.defineProperty</code>配合使用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Proxy.defineProperty</code>对属性赋值设置了拦截，然后使用<code>Reflect.defineProperty</code>完成了赋值。</p>\n<h3> Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3>\n<p><code>Reflect.getOwnPropertyDescriptor</code>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Reflect.getOwnPropertyDescriptor</code>和<code>Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor(1, 'foo')</code>不报错，返回<code>undefined</code>，而<code>Reflect.getOwnPropertyDescriptor(1, 'foo')</code>会抛出错误，表示参数非法。</p>\n<h3> Reflect.isExtensible (target)</h3>\n<p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Reflect.preventExtensions(target)</h3>\n<p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果参数不是对象，<code>Object.preventExtensions</code>在 ES5 环境报错，在 ES6 环境返回传入的参数，而<code>Reflect.preventExtensions</code>会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Reflect.ownKeys (target)</h3>\n<p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果<code>Reflect.ownKeys()</code>方法的第一个参数不是对象，会报错。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "19.Module模块化",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses19.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses19.html",
      "summary": "设计原因 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍...",
      "content_html": "<h1> Module 模块化</h1>\n<h2> 设计原因</h2>\n<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\n<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>\n<p>**ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。**CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>\n<p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>\n<p><strong>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</strong></p>\n<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p>\n<ul>\n<li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>\n<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li>\n<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>\n</ul>\n<h2> 严格模式</h2>\n<p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>\"use strict\";</code>。</p>\n<p>严格模式主要有以下限制。</p>\n<ul>\n<li>变量必须声明后再使用</li>\n<li>函数的参数不能有同名属性，否则报错</li>\n<li>不能使用<code>with</code>语句</li>\n<li>不能对只读属性赋值，否则报错</li>\n<li>不能使用前缀 0 表示八进制数，否则报错</li>\n<li>不能删除不可删除的属性，否则报错</li>\n<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>\n<li><code>eval</code>不会在它的外层作用域引入变量</li>\n<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>\n<li><code>arguments</code>不会自动反映函数参数的变化</li>\n<li>不能使用<code>arguments.callee</code></li>\n<li>不能使用<code>arguments.caller</code></li>\n<li>禁止<code>this</code>指向全局对象</li>\n<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>\n<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>\n</ul>\n<p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。</p>\n<p>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</p>\n<h2> 基本命令</h2>\n<p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>\n<h3> export 命令</h3>\n<h4> 可以导出的内容</h4>\n<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。<strong>如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p>\n<p><code>export</code>的写法，除了像上面这样，还有另外一种。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>\n<p><strong><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码对外输出一个函数<code>multiply</code>。</p>\n<h4> 模块重命名</h4>\n<p><strong>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p>\n<h4> 注意点</h4>\n<p><strong>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量<code>m</code>，还是直接输出 1。<code>1</code>只是一个值，不是接口。正确的写法是下面这样。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值<code>1</code>。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p>\n<p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p>\n<p><strong>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。</strong></p>\n<p>**最后，<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。**这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>export</code>语句放在函数之中，结果报错。</p>\n<h3> import 命令</h3>\n<h4> 基本用法</h4>\n<p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p>\n<p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 导入模块只读性</h4>\n<p><strong><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。</p>\n<p><strong>但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>a</code>的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，<strong>建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</strong></p>\n<p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p>\n<h4> 导入模块提升</h4>\n<p><strong>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<strong><code>import</code>命令是编译阶段执行的，在代码运行之前</strong>。</p>\n<h4> 注意点</h4>\n<p><strong>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p>\n<h4> 加载所有模块</h4>\n<p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p>\n<p>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码加载了两次<code>lodash</code>，但是只会执行一次。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，虽然<code>foo</code>和<code>bar</code>在两个语句中加载，但是它们对应的是同一个<code>my_module</code>模块。也就是说，<code>import</code>语句是 Singleton 模式。</p>\n<p><strong>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 跨模块常量</h2>\n<p>本书介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>使用的时候，直接加载<code>index.js</code>就可以了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 模块的整体加载</h2>\n<p><strong>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</strong></p>\n<p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>现在，加载这个模块。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> export default</h2>\n<h4> 基本使用</h4>\n<p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>\n<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p>\n<p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p>\n<p><code>export default</code>命令用在非匿名函数前，也是可以的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p>\n<p>下面比较一下默认输出和正常输出。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</p>\n<h4> 唯一性</h4>\n<p><strong><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</strong></p>\n<h4> 本质</h4>\n<p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p>\n<p>同样地，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</p>\n<p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>对应上面代码的<code>export</code>语句如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p>\n<p><code>export default</code>也可以用来输出类。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> export 与 import 的复合写法</h2>\n<p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code>。</p>\n<p>模块的接口改名和整体输出，也可以采用这种写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>默认接口的写法如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>具名接口改为默认接口的写法如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>同样地，默认接口也可以改名为具名接口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>ES2020 之前，有一种<code>import</code>语句，没有对应的复合写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><a href=\"https://github.com/tc39/proposal-export-ns-from\" target=\"_blank\" rel=\"noopener noreferrer\">ES2020</a>补上了这个写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 模块的继承</h2>\n<p>模块之间也可以继承。</p>\n<p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p>\n<p>这时，也可以将<code>circle</code>的属性或方法，改名后再输出。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p>\n<p>加载上面模块的写法如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p>\n<h2> import()</h2>\n<h3> 简介</h3>\n<p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（<code>import</code>命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中（比如，在<code>if</code>代码块之中，或在函数之中）。</p>\n<p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的语句就是动态加载，<code>require</code>到底加载哪一个模块，只有运行时才知道。<code>import</code>命令做不到这一点。</p>\n<p><a href=\"https://github.com/tc39/proposal-dynamic-import\" target=\"_blank\" rel=\"noopener noreferrer\">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p>\n<p><strong><code>import()</code>返回一个 Promise 对象。下面是一个例子。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p>\n<h3> 适用场合</h3>\n<p>下面是<code>import()</code>的一些适用场合。</p>\n<p><strong>（1）按需加载</strong></p>\n<p><code>import()</code>可以在需要的时候，再加载某个模块。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p>\n<p><strong>（2）条件加载</strong></p>\n<p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。</p>\n<p><strong>（3）动态的模块路径</strong></p>\n<p><code>import()</code>允许模块路径动态生成。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，根据函数<code>f</code>的返回结果，加载不同的模块。</p>\n<h3> 注意点</h3>\n<p><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p>\n<p>如果模块有<code>default</code>输出接口，可以用参数直接获得。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码也可以使用具名输入的形式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果想同时加载多个模块，可以采用下面的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>import()</code>也可以用在 async 函数之中。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "2.基础关注点",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses2.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses2.html",
      "summary": "几个概念 语句 JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。 这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。 1 + 3叫做表达式（expression），指一个为了得到返...",
      "content_html": "<h1> 基础关注点</h1>\n<h2> 几个概念</h2>\n<h3> 语句</h3>\n<p>JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。</p>\n<p><strong>语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这条语句先用<code>var</code>命令，声明了变量<code>a</code>，然后将<code>1 + 3</code>的运算结果赋值给变量<code>a</code>。</p>\n<p><code>1 + 3</code>叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。</p>\n<p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码就表示3个空语句。</p>\n<p><strong>表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义。</p>\n<h3> 区块</h3>\n<p>如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的原意可能是下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是，实际效果却是下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>因此，建议总是使用大括号表示区块。</p>\n<p>另外，区块起首的大括号的位置，有许多不同的写法。最流行的有两种，一种是起首的大括号另起一行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一种是起首的大括号跟在关键字的后面。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>一般来说，这两种写法都可以接受。但是，JavaScript 要使用后一种，因为 JavaScript 会自动添加句末的分号，导致一些难以察觉的错误。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的代码的原意，是要返回一个对象，但实际上返回的是<code>undefined</code>，因为 JavaScript 自动在<code>return</code>语句后面添加了分号。为了避免这一类错误，需要写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>因此，表示区块起首的大括号，不要另起一行。</p>\n<h3> 圆括号</h3>\n<p>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>建议可以用空格，区分这两种不同的括号。</p>\n<blockquote>\n<ol>\n<li>表示函数调用时，函数名与左括号之间没有空格。</li>\n<li>表示函数定义时，函数名与左括号之间没有空格。</li>\n<li>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。</li>\n</ol>\n</blockquote>\n<p>按照上面的规则，下面的写法都是不规范的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的最后一行是一个匿名函数，<code>function</code>是语法关键字，不是函数名，所以与左括号之间应该要有一个空格。</p>\n<p>圆括号（<code>()</code>）也可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，由于使用了圆括号，加法会先于乘法执行。</p>\n<p>运算符的优先级别十分繁杂，且都是硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。</p>\n<p>顺便说一下，圆括号不是运算符，而是一种语法结构。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。</p>\n<p>注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的第二行，如果圆括号具有求值作用，那么就会变成<code>1 = 2</code>，这是会报错了。但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值。</p>\n<p>这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数放在圆括号之中会返回函数本身，圆括号跟在函数后面则是调用函数。</p>\n<p><strong>圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。</strong></p>\n<h3> 行尾的分号</h3>\n<p>分号表示一条语句的结束。JavaScript 允许省略行尾的分号。事实上，确实有一些开发者行尾从来不写分号。但是，由于下面要讨论的原因，建议还是不要省略这个分号。</p>\n<h4> 不使用分号的情况</h4>\n<p>首先，以下三种情况，语法规定本来就不需要在结尾添加分号。</p>\n<p><strong>（1）for 和 while 循环</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>do...while</code>循环是有分号的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）分支语句：if，switch，try</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（3）函数的声明语句</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，函数表达式仍然要使用分号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>以上三种情况，如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句。</p>\n<h4> 分号的自动添加</h4>\n<p>除了上一节的三种情况，所有语句都应该使用分号。但是，如果没有使用分号，大多数情况下，JavaScript 会自动添加。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种语法特性被称为“分号的自动添加”（Automatic Semicolon Insertion，简称 ASI）。</p>\n<p>因此，有人提倡省略句尾的分号。麻烦的是，如果下一行的开始可以与本行的结尾连在一起解释，JavaScript 就不会自动添加分号。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码都会多行放在一起解释，不会每一行自动添加分号。这些例子还是比较容易看出来的，但是下面这个例子就不那么容易看出来了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是更多不会自动添加分号的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>只有下一行的开始与本行的结尾，无法放在一起解释，JavaScript 引擎才会自动添加分号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另外，如果一行的起首是“自增”（<code>++</code>）或“自减”（<code>--</code>）运算符，则它们的前面会自动添加分号。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码之所以会得到<code>1 2 0</code>的结果，原因是自增和自减运算符前，自动加上了分号。上面的代码实际上等同于下面的形式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果<code>continue</code>、<code>break</code>、<code>return</code>和<code>throw</code>这四个语句后面，直接跟换行符，则会自动添加分号。这意味着，如果<code>return</code>语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。</p>\n<p>不应该省略结尾的分号，还有一个原因。有些 JavaScript 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果。</p>\n<p>另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。</p>\n<h2> eval 命令</h2>\n<h3> 基本用法</h3>\n<p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将字符串当作语句运行，生成了变量<code>a</code>。</p>\n<p>如果参数字符串无法当作语句运行，那么就会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>放在<code>eval</code>中的字符串，应该有独自存在的意义，不能用来与<code>eval</code>以外的命令配合使用。举例来说，下面的代码将会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码会报错，因为<code>return</code>不能单独使用，必须在函数中使用。</p>\n<p>如果<code>eval</code>的参数不是字符串，那么会原样返回。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>eval</code>没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>eval</code>命令修改了外部变量<code>a</code>的值。由于这个原因，<code>eval</code>有安全风险。</p>\n<p>为了防止这种风险，JavaScript 规定，如果使用严格模式，<code>eval</code>内部声明的变量，不会影响到外部作用域。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>f</code>内部是严格模式，这时<code>eval</code>内部声明的<code>foo</code>变量，就不会影响到外部。</p>\n<p>不过，即使在严格模式下，<code>eval</code>依然可以读写当前作用域的变量。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，严格模式下，<code>eval</code>内部还是改写了外部变量，可见安全风险依然存在。</p>\n<p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，<code>eval</code>最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法。</p>\n<h3> eval 的别名调用</h3>\n<p>前面说过<code>eval</code>不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是<code>eval</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，变量<code>m</code>是<code>eval</code>的别名。静态代码分析阶段，引擎分辨不出<code>m('var x = 1')</code>执行的是<code>eval</code>命令。</p>\n<p>为了保证<code>eval</code>的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行<code>eval</code>，<code>eval</code>内部一律是全局作用域。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>eval</code>是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的<code>a</code>为全局变量。这样的话，引擎就能确认<code>e()</code>不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。</p>\n<p><code>eval</code>的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨<code>eval()</code>这一种形式是直接调用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面这些形式都是<code>eval</code>的别名调用，作用域都是全局作用域。</p>\n<h2> 几种特殊运算符</h2>\n<h3> 对象相加, valueOf, toString()</h3>\n<p>如果运算子是对象，必须先转成原始类型的值，然后再相加。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>obj</code>转成原始类型的值是<code>[object Object]</code>，再加<code>2</code>就得到了上面的结果。</p>\n<p>对象转成原始类型的值，规则如下。</p>\n<p>首先，自动调用对象的<code>valueOf</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>一般来说，对象的<code>valueOf</code>方法总是返回对象自身，这时再自动调用对象的<code>toString</code>方法，将其转为字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>对象的<code>toString</code>方法默认返回<code>[object Object]</code>，所以就得到了最前面那个例子的结果。</p>\n<p>知道了这个规则以后，就可以自己定义<code>valueOf</code>方法或<code>toString</code>方法，得到想要的结果。</p>\n<h3> 三元条件表达式</h3>\n<p>通常来说，三元条件表达式与<code>if...else</code>语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，<code>if...else</code>是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用<code>if..else</code>。</p>\n<h3> void 运算符</h3>\n<p><code>void</code>运算符的作用是执行一个表达式，然后不返回任何值，或者说返回<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>**上面是<code>void</code>运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为<code>void</code>运算符的优先性很高，如果不使用括号，容易造成错误的结果。**比如，<code>void 4 + 7</code>实际上等同于<code>(void 4) + 7</code>。</p>\n<p>下面是<code>void</code>运算符的一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。</p>\n<p>请看下面的代码。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，点击链接后，会先执行<code>onclick</code>的代码，由于<code>onclick</code>返回<code>false</code>，所以浏览器不会跳转到 example.com。</p>\n<p><code>void</code>运算符可以取代上面的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 严格模式</h2>\n<p>除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。</p>\n<p>同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。</p>\n<h3> 设计目的</h3>\n<p>早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。</p>\n<p>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p>\n<ul>\n<li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li>\n<li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li>\n<li>提高编译器效率，增加运行速度。</li>\n<li>为未来新版本的 JavaScript 语法做好铺垫。</li>\n</ul>\n<p>总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。</p>\n<h4> 启用方法</h4>\n<p>进入严格模式的标志，是一行字符串<code>use strict</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。</p>\n<p>严格模式可以用于整个脚本，也可以只用于单个函数。</p>\n<p><strong>（1） 整个脚本文件</strong></p>\n<p><code>use strict</code>放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，<code>use strict</code>可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个<code>&lt;script&gt;</code>标签是严格模式，后一个不是。</p>\n<p>如果<code>use strict</code>写成下面这样，则不起作用，严格模式必须从代码一开始就生效。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）单个函数</strong></p>\n<p><code>use strict</code>放在函数体的第一行，则整个函数以严格模式运行。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 显式报错</h3>\n<p>严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。</p>\n<h4> 只读属性不可写</h4>\n<p>严格模式下，设置字符串的<code>length</code>属性，会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码报错，因为<code>length</code>是只读属性，严格模式下不可写。正常模式下，改变<code>length</code>属性是无效的，但不会报错。</p>\n<p>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 只设置了取值器的属性不可写</h4>\n<p>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>obj.v</code>只有取值器，没有存值器，对它进行赋值就会报错。</p>\n<h4> 禁止扩展的对象不可扩展</h4>\n<p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>obj</code>对象禁止扩展，添加属性就会报错。</p>\n<h4> eval、arguments 不可用作标识名</h4>\n<p>严格模式下，使用<code>eval</code>或者<code>arguments</code>作为标识名，将会报错。下面的语句都会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 函数不能有重名的参数</h4>\n<p>正常模式下，如果函数有多个重名的参数，可以用<code>arguments[i]</code>读取。严格模式下，这属于语法错误。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 禁止八进制的前缀0表示法</h4>\n<p>正常模式下，整数的第一位如果是<code>0</code>，表示这是八进制数，比如<code>0100</code>等于十进制的64。严格模式禁止这种表示法，整数第一位为<code>0</code>，将报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 增强的安全措施</h3>\n<p>严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。</p>\n<h4> 全局变量显式声明</h4>\n<p>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因此，严格模式下，变量都必须先声明，然后再使用。</p>\n<h4> 禁止 this 关键字指向全局对象</h4>\n<p>正常模式下，函数内部的<code>this</code>可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，严格模式的函数体内部<code>this</code>是<code>undefined</code>。</p>\n<p>这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加<code>new</code>，这时<code>this</code>不再指向全局对象，而是报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>严格模式下，函数直接调用时（不使用<code>new</code>调用），函数内部的<code>this</code>表示<code>undefined</code>（未定义），因此可以用<code>call</code>、<code>apply</code>和<code>bind</code>方法，将任意值绑定在<code>this</code>上面。正常模式下，<code>this</code>指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而<code>null</code>和<code>undefined</code>这两个无法转成对象的值，将被忽略。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，可以把任意类型的值，绑定在<code>this</code>上面。</p>\n<h4> 禁止使用 fn.callee、fn.caller</h4>\n<p>函数内部不得使用<code>fn.caller</code>、<code>fn.arguments</code>，否则会报错。这意味着不能在函数内部得到调用栈了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 禁止使用 arguments.callee、arguments.caller</h4>\n<p><code>arguments.callee</code>和<code>arguments.caller</code>是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用<code>arguments.callee</code>、<code>arguments.caller</code>将会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 禁止删除变量</h4>\n<p>严格模式下无法删除变量，如果使用<code>delete</code>命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的<code>configurable</code>属性设置为<code>true</code>，才能被<code>delete</code>命令删除。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 静态绑定</h3>\n<p>JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。</p>\n<p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。</p>\n<p>具体来说，涉及以下几个方面。</p>\n<h4> 禁止使用 with 语句</h4>\n<p>严格模式下，使用<code>with</code>语句将报错。因为<code>with</code>语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 创设 eval 作用域</h4>\n<p>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：<code>eval</code>作用域。</p>\n<p>正常模式下，<code>eval</code>语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，<code>eval</code>语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，<code>eval</code>所生成的变量只能用于<code>eval</code>内部。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，由于<code>eval</code>语句内部是一个独立作用域，所以内部的变量<code>x</code>不会泄露到外部。</p>\n<p>注意，如果希望<code>eval</code>语句也使用严格模式，有两种方式。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面两种写法，<code>eval</code>内部使用的都是严格模式。</p>\n<h4> arguments 不再追踪参数的变化</h4>\n<p>变量<code>arguments</code>代表函数的参数。严格模式下，函数内部改变参数与<code>arguments</code>的联系被切断了，两者不再存在联动关系。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，改变函数的参数，不会反应到<code>arguments</code>对象上来。</p>\n<h3> 向下一个版本的 JavaScript 过渡</h3>\n<p>JavaScript 语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。</p>\n<h4> 非函数代码块不得声明函数</h4>\n<p>ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码在<code>if</code>代码块和<code>for</code>代码块中声明了函数，ES5 环境会报错。</p>\n<p>注意，如果是 ES6 环境，上面的代码不会报错，因为 ES6 允许在代码块之中声明函数。</p>\n<h4> 保留字</h4>\n<p>为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "20.模块加载的实现",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses20.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses20.html",
      "summary": "ESM VS CJS 它们有三个重大差异。 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。; CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。; CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。; 第二个差异是因为 Comm...",
      "content_html": "<h1> 模块加载的实现</h1>\n<h2> ESM VS CJS</h2>\n<p>它们有三个重大差异。</p>\n<ul>\n<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>\n<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>\n<li>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</li>\n</ul>\n<p>第二个差异是因为 CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>\n<p>下面重点解释第一个差异。</p>\n<p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件<code>lib.js</code>的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>\n<p>还是举上面的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p>\n<p>再举一个出现在<code>export</code>一节中的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了 500 毫秒，又变为等于<code>baz</code>。</p>\n<p>让我们看看，<code>m2.js</code>能否正确读取这个变化。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p>\n<p>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的<code>const</code>变量。</p>\n<p><strong>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的脚本<code>mod.js</code>，输出的是一个<code>C</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在执行<code>main.js</code>，输出的是<code>1</code>。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>C</code>的同一个实例。</p>\n<h2> 浏览器加载</h2>\n<h3> 模块加载规则</h3>\n<p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=\"application/javascript\"</code>可以省略。</p>\n<p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p>\n<p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>\n<p><code>defer</code>与<code>async</code>的区别是</p>\n<p><code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行。</p>\n<p><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</p>\n<p>一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p>\n<h3> ES6 模块加载规则</h3>\n<p><strong>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=\"module\"</code>属性。</strong></p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。</p>\n<p>浏览器对于带有<code>type=\"module\"</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>如果网页有多个<code>&lt;script type=\"module\"&gt;</code>，它们会按照在页面出现的顺序依次执行。</p>\n<p><code>&lt;script&gt;</code> 标签的<code>async</code>属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>一旦使用了<code>async</code>属性，<code>&lt;script type=\"module\"&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</p>\n<p><strong>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</strong></p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>举例来说，jQuery 就支持模块加载。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p>\n<ul>\n<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>\n<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>\n<li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li>\n<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>\n<li>同一个模块如果加载多次，将只执行一次。</li>\n</ul>\n<p>下面是一个示例模块。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> Node.js 的模块加载方法</h2>\n<h3> 模块引用</h3>\n<p>JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS。</p>\n<p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p>\n<p>它们采用不同的加载方案。从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。</p>\n<p>Node.js 要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，那么就必须采用<code>.mjs</code>后缀名。Node.js 遇到<code>.mjs</code>文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>\"use strict\"</code>。</p>\n<p>如果不希望将后缀名改成<code>.mjs</code>，可以在项目的<code>package.json</code>文件中，指定<code>type</code>字段为<code>module</code>。</p>\n<div class=\"language-json\" data-ext=\"json\"></div><p>一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</p>\n<p>总结为一句话：<code>.mjs</code>文件总是以 ES6 模块加载，<code>.cjs</code>文件总是以 CommonJS 模块加载，<code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。</p>\n<p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p>\n<h3> package.json文件</h3>\n<h4> main 字段</h4>\n<p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，可以只使用<code>main</code>字段，指定模块加载的入口文件。</p>\n<div class=\"language-json\" data-ext=\"json\"></div><p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有<code>type</code>字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p>\n<p>然后，<code>import</code>命令就可以加载这个模块。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，运行该脚本以后，Node.js 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p>\n<p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p>\n<h4> exports 字段</h4>\n<p><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</p>\n<p><strong>（1）子目录别名</strong></p>\n<p><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</p>\n<div class=\"language-json\" data-ext=\"json\"></div><p>上面的代码指定<code>src/submodule.js</code>别名为<code>submodule</code>，然后就可以从别名加载这个文件。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是子目录别名的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）main 的别名</strong></p>\n<p><code>exports</code>字段的别名如果是<code>.</code>，就代表模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p>\n<p><strong>（3）条件加载</strong></p>\n<p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开<code>--experimental-conditional-exports</code>标志。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，别名<code>.</code>的<code>require</code>条件指定<code>require()</code>命令的入口文件（即 CommonJS 的入口），<code>default</code>条件指定其他情况的入口（即 ES6 的入口）。</p>\n<p>上面的写法可以简写如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，如果同时还有其他别名，就不能采用简写，否则或报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> CommonJS 模块加载 ES6 模块</h3>\n<p>CommonJS 的<code>require()</code>命令不能加载 ES6 模块，会报错，只能使用<code>import()</code>这个方法加载。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码可以在 CommonJS 模块中运行。</p>\n<p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p>\n<h3> ES6 模块加载 CommonJS 模块</h3>\n<p><strong>ES6 模块的<code>import</code>命令可以加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这是因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是<code>module.exports</code>，是一个对象，无法被静态分析，所以只能整体加载。</p>\n<p>加载单一的输出项，可以写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>还有一种变通的加载方法，就是使用 Node.js 内置的<code>module.createRequire()</code>方法。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块。<strong>但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。</strong></p>\n<h3> 同时支持两种格式的模块</h3>\n<p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p>\n<p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p>\n<p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p>\n<p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>{ type: \"module\" }</code>。</p>\n<p>另一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p>\n<h3> Node.js 的内置模块</h3>\n<p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 加载路径</h3>\n<p>ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>为了与浏览器的<code>import</code>加载规则相同，Node.js 的<code>.mjs</code>文件支持 URL 路径。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p>\n<p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议）和<code>data:</code>协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以<code>/</code>或<code>//</code>开头的路径）。</p>\n<h3> 内部变量</h3>\n<p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p>\n<p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p>\n<p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p>\n<ul>\n<li><code>arguments</code></li>\n<li><code>require</code></li>\n<li><code>module</code></li>\n<li><code>exports</code></li>\n<li><code>__filename</code></li>\n<li><code>__dirname</code></li>\n</ul>\n<h2> 循环加载</h2>\n<h3> 概念</h3>\n<p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p>\n<p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p>\n<p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p>\n<h3> CommonJS 模块的加载原理</h3>\n<p>介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。</p>\n<p>CommonJS 的一个模块，就是一个脚本文件。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p>\n<p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p>\n<h3> CommonJS 模块的循环加载</h3>\n<p>CommonJS 模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出。</p>\n<p>让我们来看，Node <a href=\"https://nodejs.org/api/modules.html#modules_cycles\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a>里面的例子。脚本文件<code>a.js</code>代码如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p>\n<p>再看<code>b.js</code>的代码。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p>\n<p><code>a.js</code>已经执行的部分，只有一行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。</p>\n<p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>执行<code>main.js</code>，运行结果如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</p>\n<p>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，如果发生循环加载，<code>require('a').foo</code>的值很可能后面会被改写，改用<code>require('a')</code>会更保险一点。</p>\n<h3> ES6 模块的循环加载</h3>\n<p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from 'foo'</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>\n<p>请看下面这个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p>\n<p>让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</p>\n<p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>这是因为函数具有提升作用，在执行<code>import {bar} from './b'</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</p>\n<p>我们再来看 ES6 模块加载器<a href=\"https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md\" target=\"_blank\" rel=\"noopener noreferrer\">SystemJS</a>给出的一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p>\n<p>运行上面这段代码，结果如下。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。</p>\n<p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "21.DOM",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses21.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses21.html",
      "summary": "基本概念 DOM 理解 DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个...",
      "content_html": "<h1> DOM</h1>\n<h2> 基本概念</h2>\n<h3> DOM 理解</h3>\n<p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p>\n<p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p>\n<p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。</p>\n<h3> 节点</h3>\n<p><strong>DOM 的最小组成单位叫做节点（node）。</strong></p>\n<p>文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p>\n<p><strong>节点的类型有七种。</strong></p>\n<ul>\n<li><strong><code>Document</code>：整个文档树的顶层节点</strong></li>\n<li><strong><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</strong></li>\n<li><strong><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</strong></li>\n<li><strong><code>Attr</code>：网页元素的属性（比如<code>class=\"right\"</code>）</strong></li>\n<li><strong><code>Text</code>：标签之间或标签包含的文本</strong></li>\n<li><strong><code>Comment</code>：注释</strong></li>\n<li><strong><code>DocumentFragment</code>：文档的片段</strong></li>\n</ul>\n<p>浏览器提供一个原生的节点对象<code>Node</code>，上面这七种节点都继承了<code>Node</code>，因此具有一些共同的属性和方法。</p>\n<h3> 节点树</h3>\n<p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，又像一棵树。</p>\n<p>浏览器原生提供<code>document</code>节点，代表整个文档。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>文档的第一层有两个节点：</strong></p>\n<p><strong>第一个是文档类型节点（<code>&lt;!doctype html&gt;</code>）</strong></p>\n<p><strong>第二个是 HTML 网页的顶层容器标签<code>&lt;html&gt;</code>。</strong></p>\n<p><strong>后者构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</strong></p>\n<p><strong>除了根节点，其他节点都有三种层级关系。</strong></p>\n<ul>\n<li><strong>父节点关系（parentNode）：直接的那个上级节点</strong></li>\n<li><strong>子节点关系（childNodes）：直接的下级节点</strong></li>\n<li><strong>同级节点关系（sibling）：拥有同一个父节点的节点</strong></li>\n</ul>\n<p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括<code>firstChild</code>（第一个子节点）和<code>lastChild</code>（最后一个子节点）等属性，同级节点接口包括<code>nextSibling</code>（紧邻在后的那个同级节点）和<code>previousSibling</code>（紧邻在前的那个同级节点）属性。</p>\n<h2> Node 接口</h2>\n<h3> 概述</h3>\n<p>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</p>\n<h3> 属性</h3>\n<h4> Node.prototype.nodeType</h4>\n<p><code>nodeType</code>属性返回一个整数值，表示节点的类型。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，文档节点的类型值为9。</p>\n<p>Node 对象定义了几个常量，对应这些类型值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，文档节点的<code>nodeType</code>属性等于常量<code>Node.DOCUMENT_NODE</code>。</p>\n<p>不同节点的<code>nodeType</code>属性值和对应的常量如下。</p>\n<ul>\n<li>文档节点（document）：9，对应常量<code>Node.DOCUMENT_NODE</code></li>\n<li>元素节点（element）：1，对应常量<code>Node.ELEMENT_NODE</code></li>\n<li>属性节点（attr）：2，对应常量<code>Node.ATTRIBUTE_NODE</code></li>\n<li>文本节点（text）：3，对应常量<code>Node.TEXT_NODE</code></li>\n<li>文档片断节点（DocumentFragment）：11，对应常量<code>Node.DOCUMENT_FRAGMENT_NODE</code></li>\n<li>文档类型节点（DocumentType）：10，对应常量<code>Node.DOCUMENT_TYPE_NODE</code></li>\n<li>注释节点（Comment）：8，对应常量<code>Node.COMMENT_NODE</code></li>\n</ul>\n<p>确定节点类型时，使用<code>nodeType</code>属性是常用方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Node.prototype.nodeName</h4>\n<p><code>nodeName</code>属性返回节点的名称。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，元素节点<code>&lt;div&gt;</code>的<code>nodeName</code>属性就是大写的标签名<code>DIV</code>。</p>\n<p>不同节点的<code>nodeName</code>属性值如下。</p>\n<ul>\n<li>文档节点（document）：<code>#document</code></li>\n<li>元素节点（element）：大写的标签名</li>\n<li>属性节点（attr）：属性的名称</li>\n<li>文本节点（text）：<code>#text</code></li>\n<li>文档片断节点（DocumentFragment）：<code>#document-fragment</code></li>\n<li>文档类型节点（DocumentType）：文档的类型</li>\n<li>注释节点（Comment）：<code>#comment</code></li>\n</ul>\n<h4> Node.prototype.nodeValue</h4>\n<p><code>nodeValue</code>属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p>\n<p><strong>只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的<code>nodeValue</code>可以返回结果，其他类型的节点一律返回<code>null</code>。</strong></p>\n<p><strong>同样的，也只有这三类节点可以设置<code>nodeValue</code>属性的值，其他类型的节点设置无效。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>div</code>是元素节点，<code>nodeValue</code>属性返回<code>null</code>。<code>div.firstChild</code>是文本节点，所以可以返回文本值。</p>\n<h4> Node.prototype.textContent</h4>\n<p><code>textContent</code>属性返回当前节点和它的所有后代节点的文本内容。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>textContent</code>属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</strong></p>\n<p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码在插入文本时，会将<code>&lt;p&gt;</code>标签解释为文本，而不会当作标签处理。</p>\n<p>对于文本节点（text）、注释节点（comment）和属性节点（attr），<code>textContent</code>属性的值与<code>nodeValue</code>属性相同。<strong>对于其他类型的节点，该属性会将每个子节点（不包括注释节点）的内容连接在一起返回。如果一个节点没有子节点，则返回空字符串。</strong></p>\n<p>文档节点（document）和文档类型节点（doctype）的<code>textContent</code>属性为<code>null</code>。如果要读取整个文档的内容，可以使用<code>document.documentElement.textContent</code>。</p>\n<h4> Node.prototype.baseURI</h4>\n<p><strong><code>baseURI</code>属性返回一个字符串，表示当前网页的绝对路径。</strong></p>\n<p>浏览器根据这个属性，计算网页上的相对路径的 URL。</p>\n<p><strong>该属性为只读。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果无法读到网页的 URL，<code>baseURI</code>属性返回<code>null</code>。</p>\n<p>该属性的值一般由当前网址的 URL（即<code>window.location</code>属性）决定，但是可以使用 HTML 的<code>&lt;base&gt;</code>标签，改变该属性的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>设置了以后，<code>baseURI</code>属性就返回<code>&lt;base&gt;</code>标签设置的值。</p>\n<h4> Node.prototype.ownerDocument</h4>\n<p><code>Node.ownerDocument</code>属性返回当前节点所在的顶层文档对象，即<code>document</code>对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>document</code>对象本身的<code>ownerDocument</code>属性，返回<code>null</code>。</p>\n<h4> Node.prototype.nextSibling</h4>\n<p><code>Node.nextSibling</code>属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>d1.nextSibling</code>就是紧跟在<code>d1</code>后面的同级节点<code>d2</code>。</p>\n<p><strong>注意，该属性还包括文本节点和注释节点（<code>&lt;!-- comment --&gt;</code>）。</strong></p>\n<p><strong>因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</strong></p>\n<p><code>nextSibling</code>属性可以用来遍历所有子节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码遍历<code>div1</code>节点的所有子节点。</p>\n<h4> Node.prototype.previousSibling</h4>\n<p><code>previousSibling</code>属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>d2.previousSibling</code>就是<code>d2</code>前面的同级节点<code>d1</code>。</p>\n<p><strong>注意，该属性还包括文本节点和注释节点。</strong></p>\n<p><strong>因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</strong></p>\n<h4> Node.prototype.parentNode</h4>\n<p><code>**parentNode</code>属性返回当前节点的父节点。**</p>\n<p>对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，通过<code>node.parentNode</code>属性将<code>node</code>节点从文档里面移除。</p>\n<p><strong>文档节点（document）和文档片段节点（documentfragment）的父节点都是<code>null</code>。</strong></p>\n<p><strong>另外，对于那些生成后还没插入 DOM 树的节点，父节点也是<code>null</code>。</strong></p>\n<h4> <strong>Node.prototype.parentElement</strong></h4>\n<p><strong><code>parentElement</code>属性返回当前节点的父元素节点。</strong></p>\n<p>如果当前节点没有父节点，或者父节点类型不是元素节点，则返回<code>null</code>。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，父元素节点的样式设定了红色。</p>\n<p><strong>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。<code>parentElement</code>属性相当于把后两种父节点都排除了。</strong></p>\n<h4> Node.prototype.firstChild，Node.prototype.lastChild</h4>\n<p><code>**firstChild</code>属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code>null</code>。**</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>p</code>元素的第一个子节点是<code>span</code>元素。</p>\n<p><strong>注意，<code>firstChild</code>返回的除了元素节点，还可能是文本节点或注释节点。</strong></p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，<code>p</code>元素与<code>span</code>元素之间有空白字符，这导致<code>firstChild</code>返回的是文本节点。</p>\n<p><code>**lastChild</code>属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回<code>null</code>。用法与<code>firstChild</code>属性相同。**</p>\n<h4> Node.prototype.childNodes</h4>\n<p><code>childNodes</code>属性返回一个类似数组的对象（<code>NodeList</code>集合），成员包括当前节点的所有子节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>children</code>就是<code>ul</code>元素的所有子节点。</p>\n<p>使用该属性，可以遍历某个节点的所有子节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，文档节点的第一个子节点的类型是10（即文档类型节点），第二个子节点的类型是1（即元素节点）。</p>\n<p>注意，除了元素节点，<code>childNodes</code>属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的<code>NodeList</code>集合。由于<code>NodeList</code>对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。</p>\n<h4> Node.prototype.isConnected</h4>\n<p><code>isConnected</code>属性返回一个布尔值，表示当前节点是否在文档之中。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>test</code>节点是脚本生成的节点，没有插入文档之前，<code>isConnected</code>属性返回<code>false</code>，插入之后返回<code>true</code>。</p>\n<h3> 方法</h3>\n<h4> Node.prototype.appendChild()</h4>\n<p><strong><code>appendChild()</code>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。</strong></p>\n<p><strong>该方法的返回值就是插入文档的子节点。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码新建一个<code>&lt;p&gt;</code>节点，将其插入<code>document.body</code>的尾部。</p>\n<p><strong>如果参数节点是 DOM 已经存在的节点，<code>appendChild()</code>方法会将其从原来的位置，移动到新位置。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，插入的是一个已经存在的节点<code>myDiv</code>，结果就是该节点会从原来的位置，移动到<code>document.body</code>的尾部。</p>\n<p><strong>如果<code>appendChild()</code>方法的参数是<code>DocumentFragment</code>节点，那么插入的是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值是一个空的<code>DocumentFragment</code>节点。</strong></p>\n<h4> Node.prototype.hasChildNodes()</h4>\n<p><strong><code>hasChildNodes</code>方法返回一个布尔值，表示当前节点是否有子节点。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，如果<code>foo</code>节点有子节点，就移除第一个子节点。</p>\n<p>注意，子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，<code>hasChildNodes</code>方法也会返回<code>true</code>。</p>\n<p><strong>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。</strong></p>\n<ul>\n<li><strong><code>node.hasChildNodes()</code></strong></li>\n<li><strong><code>node.firstChild !== null</code></strong></li>\n<li>**<code>node.childNodes &amp;&amp; node.childNodes.length &gt; 0**</code></li>\n</ul>\n<p><strong><code>hasChildNodes</code>方法结合<code>firstChild</code>属性和<code>nextSibling</code>属性，可以遍历当前节点的所有后代节点。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>DOMComb</code>函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。</p>\n<h4> Node.prototype.cloneNode()</h4>\n<p><code>cloneNode</code>方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>该方法有一些使用注意点:</strong></p>\n<p><strong>（1）克隆一个节点，会拷贝该节点的所有属性，但是会丧失<code>addEventListener</code>方法和<code>on-</code>属性（即<code>node.onclick = fn</code>），添加在这个节点上的事件回调函数。</strong></p>\n<p><strong>（2）该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如<code>Node.appendChild</code>这样的方法添加到文档之中。</strong></p>\n<p><strong>（3）克隆一个节点之后，DOM 有可能出现两个有相同<code>id</code>属性（即<code>id=\"xxx\"</code>）的网页元素，这时应该修改其中一个元素的<code>id</code>属性。如果原节点有<code>name</code>属性，可能也需要修改。</strong></p>\n<h4> Node.prototype.insertBefore()</h4>\n<p><strong><code>insertBefore</code>方法用于将某个节点插入父节点内部的指定位置。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>**insertBefore</code>方法接受两个参数:**</p>\n<p><strong>第一个参数是所要插入的节点<code>newNode</code></strong></p>\n<p><strong>第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。</strong></p>\n<p><strong>返回值是插入的新节点<code>newNode</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，新建一个<code>&lt;p&gt;</code>节点，插在<code>document.body.firstChild</code>的前面，也就是成为<code>document.body</code>的第一个子节点。</p>\n<p><strong>如果<code>insertBefore</code>方法的第二个参数为<code>null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>p</code>将成为<code>document.body</code>的最后一个子节点。这也说明<code>insertBefore</code>的第二个参数不能省略。</p>\n<p><strong>注意，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</strong></p>\n<p><strong>由于不存在<code>insertAfter</code>方法，如果新节点要插在父节点的某个子节点后面，可以用<code>insertBefore</code>方法结合<code>nextSibling</code>属性模拟。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>parent</code>是父节点，<code>s1</code>是一个全新的节点，<code>s2</code>是可以将<code>s1</code>节点，插在<code>s2</code>节点的后面。如果<code>s2</code>是当前节点的最后一个子节点，则<code>s2.nextSibling</code>返回<code>null</code>，这时<code>s1</code>节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在<code>s2</code>的后面。</p>\n<p><strong>如果要插入的节点是<code>DocumentFragment</code>类型，那么插入的将是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值将是一个空的<code>DocumentFragment</code>节点。</strong></p>\n<h4> Node.prototype.removeChild()</h4>\n<p><strong><code>removeChild</code>方法接受一个子节点作为参数，用于从当前节点移除该子节点。</strong></p>\n<p>返回值是移除的子节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码移除了<code>divA</code>节点。注意，这个方法是在<code>divA</code>的父节点上调用的，不是在<code>divA</code>上调用的。</strong></p>\n<p>下面是如何移除当前节点的所有子节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p>\n<p>如果参数节点不是当前节点的子节点，<code>removeChild</code>方法将报错。</p>\n<h4> Node.prototype.replaceChild()</h4>\n<p><code>replaceChild</code>方法用于将一个新的节点，替换当前节点的某一个子节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>replaceChild</code>方法接受两个参数，第一个参数<code>newChild</code>是用来替换的新节点，第二个参数<code>oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code>oldChild</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码是如何将指定节点<code>divA</code>替换走。</p>\n<h4> Node.prototype.contains()</h4>\n<p><code>contains</code>方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p>\n<ul>\n<li>参数节点为当前节点。</li>\n<li>参数节点为当前节点的子节点。</li>\n<li>参数节点为当前节点的后代节点。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码检查参数节点<code>node</code>，是否包含在当前文档之中。</p>\n<p>注意，当前节点传入<code>contains</code>方法，返回<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Node.prototype.compareDocumentPosition()</h4>\n<p><code>compareDocumentPosition</code>方法的用法，与<code>contains</code>方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。</p>\n<table>\n<thead>\n<tr>\n<th>二进制值</th>\n<th>十进制值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>000000</td>\n<td>0</td>\n<td>两个节点相同</td>\n</tr>\n<tr>\n<td>000001</td>\n<td>1</td>\n<td>两个节点不在同一个文档（即有一个节点不在当前文档）</td>\n</tr>\n<tr>\n<td>000010</td>\n<td>2</td>\n<td>参数节点在当前节点的前面</td>\n</tr>\n<tr>\n<td>000100</td>\n<td>4</td>\n<td>参数节点在当前节点的后面</td>\n</tr>\n<tr>\n<td>001000</td>\n<td>8</td>\n<td>参数节点包含当前节点</td>\n</tr>\n<tr>\n<td>010000</td>\n<td>16</td>\n<td>当前节点包含参数节点</td>\n</tr>\n<tr>\n<td>100000</td>\n<td>32</td>\n<td>浏览器内部使用</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，节点<code>div</code>包含节点<code>input</code>（二进制<code>010000</code>），而且节点<code>input</code>在节点<code>div</code>的后面（二进制<code>000100</code>），所以第一个<code>compareDocumentPosition</code>方法返回<code>20</code>（二进制<code>010100</code>，即<code>010000 + 000100</code>），第二个<code>compareDocumentPosition</code>方法返回<code>10</code>（二进制<code>001010</code>）。</p>\n<p>由于<code>compareDocumentPosition</code>返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>compareDocumentPosition</code>的返回值与<code>4</code>（又称掩码）进行与运算（<code>&amp;</code>），得到一个布尔值，表示<code>&lt;head&gt;</code>是否在<code>&lt;body&gt;</code>前面。</p>\n<h4> Node.prototype.isEqualNode()，Node.prototype.isSameNode()</h4>\n<p><code>isEqualNode</code>方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>isSameNode</code>方法返回一个布尔值，表示两个节点是否为同一个节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Node.prototype.normalize()</h4>\n<p><code>normalize</code>方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码使用<code>normalize</code>方法之前，<code>wrapper</code>节点有两个毗邻的文本子节点。使用<code>normalize</code>方法之后，两个文本子节点被合并成一个。</p>\n<p>该方法是<code>Text.splitText</code>的逆方法，可以查看《Text 节点对象》一章，了解更多内容。</p>\n<h4> Node.prototype.getRootNode()</h4>\n<p><strong><code>getRootNode()</code>方法返回当前节点所在文档的根节点<code>document</code>，与<code>ownerDocument</code>属性的作用相同。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法可用于<code>document</code>节点自身，这一点与<code>document.ownerDocument</code>不同。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 总结</h3>\n<h4> 节点的类型</h4>\n<ul>\n<li><strong><code>Document</code>：整个文档树的顶层节点</strong></li>\n<li><strong><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</strong></li>\n<li><strong><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</strong></li>\n<li><strong><code>Attr</code>：网页元素的属性（比如<code>class=\"right\"</code>）</strong></li>\n<li><strong><code>Text</code>：标签之间或标签包含的文本</strong></li>\n<li><strong><code>Comment</code>：注释</strong></li>\n<li><strong><code>DocumentFragment</code>：文档的片段</strong></li>\n</ul>\n<h4> 节点的三种类型</h4>\n<ul>\n<li><strong>父节点关系（parentNode）：直接的那个上级节点</strong></li>\n<li><strong>子节点关系（childNodes）：直接的下级节点</strong></li>\n<li><strong>同级节点关系（sibling）：拥有同一个父节点的节点</strong></li>\n</ul>\n<h4> 查询节点常用的方法</h4>\n<h5> 对所有类型节点都可以使用</h5>\n<ol>\n<li>\n<p><strong>Node.prototype.nodeType</strong></p>\n<p><code>nodeType</code>属性返回一个整数值，表示节点的类型。</p>\n</li>\n<li>\n<p><strong>Node.prototype.nodeName</strong></p>\n<p><code>nodeName</code>属性返回节点的名称。</p>\n</li>\n<li>\n<p><strong>Node.prototype.nodeValue</strong></p>\n<p><code>nodeValue</code>属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p>\n<p>只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的<code>nodeValue</code>可以返回结果，其他类型的节点一律返回<code>null</code>。同样的，也只有这三类节点可以设置<code>nodeValue</code>属性的值，其他类型的节点设置无效。</p>\n</li>\n<li>\n<p><strong>Node.prototype.textContent</strong></p>\n<p><code>textContent</code>属性返回当前节点和它的所有后代节点的文本内容。</p>\n<p><code>textContent</code>属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p>\n<p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。</p>\n</li>\n</ol>\n<h5> 对同级节点使用</h5>\n<ol>\n<li>\n<p><strong>Node.prototype.nextSibling</strong></p>\n<p><code>Node.nextSibling</code>属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code>null</code>。</p>\n<p>注意，该属性还包括文本节点和注释节点（<code>&lt;!-- comment --&gt;</code>）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p>\n</li>\n<li>\n<p><strong>Node.prototype.previousSibling</strong></p>\n<p><code>previousSibling</code>属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code>null</code>。</p>\n<p>注意，该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</p>\n</li>\n</ol>\n<h5> 对父类节点使用</h5>\n<ol>\n<li>\n<p><strong>Node.prototype.parentNode</strong></p>\n<p><code>parentNode</code>属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</p>\n<p>文档节点（document）和文档片段节点（documentfragment）的父节点都是<code>null</code>。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是<code>null</code>。</p>\n</li>\n<li>\n<p><strong>Node.prototype.parentElement</strong></p>\n<p><code>parentElement</code>属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回<code>null</code>。</p>\n<p>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。<code>parentElement</code>属性相当于把后两种父节点都排除了。</p>\n</li>\n</ol>\n<h5> 对子类节点使用</h5>\n<ol>\n<li>\n<p><strong>Node.prototype.firstChild，Node.prototype.lastChild</strong></p>\n<p><code>firstChild</code>属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code>null</code>。</p>\n<p>注意，<code>firstChild</code>返回的除了元素节点，还可能是文本节点或注释节点。</p>\n<p><code>lastChild</code>属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回<code>null</code>。用法与<code>firstChild</code>属性相同。</p>\n</li>\n<li>\n<p><strong>Node.prototype.childNodes</strong></p>\n<p><code>childNodes</code>属性返回一个类似数组的对象（<code>NodeList</code>集合），成员包括当前节点的所有子节点。</p>\n<p>文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。</p>\n<p>注意，除了元素节点，<code>childNodes</code>属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的<code>NodeList</code>集合。由于<code>NodeList</code>对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。</p>\n</li>\n</ol>\n<h4> 增加节点常用的方法</h4>\n<h5> Node.prototype.appendChild()</h5>\n<p><code>appendChild()</code>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p>\n<p>如果参数节点是 DOM 已经存在的节点，<code>appendChild()</code>方法会将其从原来的位置，移动到新位置。</p>\n<p>如果<code>appendChild()</code>方法的参数是<code>DocumentFragment</code>节点，那么插入的是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值是一个空的<code>DocumentFragment</code>节点。</p>\n<h5> Node.prototype.insertBefore()</h5>\n<p><code>insertBefore</code>方法用于将某个节点插入父节点内部的指定位置。</p>\n<p><code>insertBefore</code>方法接受两个参数：</p>\n<p>第一个参数是所要插入的节点<code>newNode</code></p>\n<p>第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。</p>\n<p>返回值是插入的新节点<code>newNode</code>。</p>\n<p>如果<code>insertBefore</code>方法的第二个参数为<code>null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</p>\n<p>注意，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</p>\n<p>由于不存在<code>insertAfter</code>方法，如果新节点要插在父节点的某个子节点后面，可以用<code>insertBefore</code>方法结合<code>nextSibling</code>属性模拟。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果要插入的节点是<code>DocumentFragment</code>类型，那么插入的将是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值将是一个空的<code>DocumentFragment</code>节点。</p>\n<h5> Node.prototype.cloneNode()</h5>\n<p><code>cloneNode</code>方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法有一些使用注意点：</p>\n<p>（1）克隆一个节点，会拷贝该节点的所有属性，但是会丧失<code>addEventListener</code>方法和<code>on-</code>属性（即<code>node.onclick = fn</code>），添加在这个节点上的事件回调函数。</p>\n<p>（2）该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如<code>Node.appendChild</code>这样的方法添加到文档之中。</p>\n<p>（3）克隆一个节点之后，DOM 有可能出现两个有相同<code>id</code>属性（即<code>id=\"xxx\"</code>）的网页元素，这时应该修改其中一个元素的<code>id</code>属性。如果原节点有<code>name</code>属性，可能也需要修改。</p>\n<h4> 删除节点常用的方法</h4>\n<h5> Node.prototype.removeChild()</h5>\n<p><code>removeChild</code>方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p>\n<p>注意，这个方法是在父节点上调用的，不是在要删除的节点上调用，不然起不到想要删除的效果。</p>\n<p>被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p>\n<p>如果参数节点不是当前节点的子节点，<code>removeChild</code>方法将报错。</p>\n<h4> 修改节点的常用方法</h4>\n<h5> 直接法</h5>\n<p>使用删除方法，先删除某个节点，之后使用添加的方法，新增某个节点。</p>\n<h5> Node.prototype.replaceChild()</h5>\n<p><code>replaceChild</code>方法用于将一个新的节点，替换当前节点的某一个子节点。</p>\n<p><code>replaceChild</code>方法接受两个参数：</p>\n<p>第一个参数<code>newChild</code>是用来替换的新节点</p>\n<p>第二个参数<code>oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code>oldChild</code></p>\n<h4> 节点相关的判断方法</h4>\n<h5> 返回顶层文档对象</h5>\n<h6> Node.prototype.ownerDocument</h6>\n<p><code>Node.ownerDocument</code>属性返回当前节点所在的顶层文档对象，即<code>document</code>对象。</p>\n<p><code>document</code>对象本身的<code>ownerDocument</code>属性，返回<code>null</code>。</p>\n<h6> Node.prototype.getRootNode()</h6>\n<p><code>getRootNode()</code>方法返回当前节点所在文档的根节点<code>document</code>，与<code>ownerDocument</code>属性的作用相同。</p>\n<p>该方法可用于<code>document</code>节点自身，这一点与<code>document.ownerDocument</code>不同。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h5> 判断是否有节点</h5>\n<h6> Node.prototype.isConnected</h6>\n<p><code>isConnected</code>属性返回一个布尔值，表示当前节点是否在文档之中。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>test</code>节点是脚本生成的节点，没有插入文档之前，<code>isConnected</code>属性返回<code>false</code>，插入之后返回<code>true</code>。</p>\n<h6> Node.prototype.contains()</h6>\n<p><code>contains</code>方法返回一个布尔值，表示参数节点是否满足以下三个条件之一：</p>\n<ul>\n<li>参数节点为当前节点。</li>\n<li>参数节点为当前节点的子节点。</li>\n<li>参数节点为当前节点的后代节点。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码检查参数节点<code>node</code>，是否包含在当前文档之中。</p>\n<p>注意，当前节点传入<code>contains</code>方法，返回<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h5> 判断是否有子节点</h5>\n<p>判断一个节点有没有子节点，有许多种方法，下面是其中的三种：</p>\n<ul>\n<li><code>node.hasChildNodes()</code></li>\n<li><code>node.firstChild !== null</code></li>\n<li><code>node.childNodes &amp;&amp; node.childNodes.length &gt; 0</code></li>\n</ul>\n<h6> Node.prototype.hasChildNodes()</h6>\n<p><code>hasChildNodes</code>方法返回一个布尔值，表示当前节点是否有子节点。</p>\n<p>注意，子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，<code>hasChildNodes</code>方法也会返回<code>true</code>。</p>\n<h6> Node.prototype.contains()</h6>\n<p><code>contains</code>方法返回一个布尔值，表示参数节点是否满足以下三个条件之一：</p>\n<ul>\n<li>参数节点为当前节点。</li>\n<li>参数节点为当前节点的子节点。</li>\n<li>参数节点为当前节点的后代节点。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码检查参数节点<code>node</code>，是否包含在当前文档之中。</p>\n<p>注意，当前节点传入<code>contains</code>方法，返回<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h5> 判断节点是否相等</h5>\n<h6> Node.prototype.isEqualNode()，Node.prototype.isSameNode()</h6>\n<p><code>isEqualNode</code>方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>isSameNode</code>方法返回一个布尔值，表示两个节点是否为同一个节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> NodeList 接口 &amp; HTMLCollection 接口</h2>\n<h3> 设计目的</h3>\n<p>节点都是单个对象，有时需要一种数据结构，能够容纳多个节点。DOM 提供两种节点集合，用于容纳多个节点：<code>NodeList</code>和<code>HTMLCollection</code>。</p>\n<p>这两种集合都属于接口规范。许多 DOM 属性和方法，返回的结果是<code>NodeList</code>实例或<code>HTMLCollection</code>实例。主要区别是，<code>NodeList</code>可以包含各种类型的节点，<code>HTMLCollection</code>只能包含 HTML 元素节点。</p>\n<h3> NodeList 接口</h3>\n<h4> 概述</h4>\n<p><code>NodeList</code>实例是一个类似数组的对象，它的成员是节点对象。</p>\n<p><strong>通过以下方法可以得到<code>NodeList</code>实例：</strong></p>\n<ul>\n<li><strong><code>Node.childNodes</code></strong></li>\n<li><strong><code>document.querySelectorAll()</code>等节点搜索方法</strong></li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>NodeList</code>实例很像数组，可以使用<code>length</code>属性和<code>forEach</code>方法。但是，它不是数组，不能使用<code>pop</code>或<code>push</code>之类数组特有的方法。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，NodeList 实例<code>children</code>不是数组，但是具有<code>length</code>属性和<code>forEach</code>方法。</p>\n<p><strong>如果<code>NodeList</code>实例要使用数组方法，可以将其转为真正的数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>除了使用<code>forEach</code>方法遍历 NodeList 实例，还可以使用<code>for</code>循环。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> NodeList 的动态性与静态性</h4>\n<p>注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有<code>Node.childNodes</code>返回的是一个动态集合，其他的 NodeList 都是静态集合。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，文档增加一个子节点，NodeList 实例<code>children</code>的<code>length</code>属性就增加了1。</p>\n<h4> NodeList.prototype.length</h4>\n<p><code>length</code>属性返回 NodeList 实例包含的节点数量。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>document.querySelectorAll</code>返回一个 NodeList 集合。对于那些不存在的 HTML 标签，<code>length</code>属性返回<code>0</code>。</p>\n<h4> NodeList.prototype.forEach()</h4>\n<p><code>forEach</code>方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的<code>forEach</code>方法完全一致。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，回调函数<code>f</code>的三个参数依次是当前成员、位置和当前 NodeList 实例。<code>forEach</code>方法的第二个参数，用于绑定回调函数内部的<code>this</code>，该参数可省略。</p>\n<h4> NodeList.prototype.item()</h4>\n<p><code>item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>item(0)</code>返回第一个成员。</p>\n<p>如果参数值大于实际长度，或者索引不合法（比如负数），<code>item</code>方法返回<code>null</code>。如果省略参数，<code>item</code>方法会报错。</p>\n<p>所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用<code>item</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h4>\n<p>这三个方法都返回一个 ES6 的遍历器对象，可以通过<code>for...of</code>循环遍历获取每一个成员的信息。</p>\n<p>区别在于：<code>keys()</code>返回键名的遍历器，<code>values()</code>返回键值的遍历器，<code>entries()</code>返回的遍历器同时包含键名和键值的信息。</p>\n<p>也就是说，虽然NodeList是伪数组，但是部署了Iterator遍历器。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> HTMLCollection 接口</h3>\n<h4> 概述</h4>\n<p><strong><code>HTMLCollection</code>是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。</strong></p>\n<p><strong>它的返回值是一个类似数组的对象，但是与<code>NodeList</code>接口不同，<code>HTMLCollection</code>没有<code>forEach</code>方法，只能使用<code>for</code>循环遍历。</strong></p>\n<p><strong>返回<code>HTMLCollection</code>实例的，主要是一些<code>Document</code>对象的集合属性，比如<code>document.links</code>、<code>document.forms</code>、<code>document.images</code>等。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>HTMLCollection</code>实例都是动态集合，节点的变化会实时反映在集合中。</strong></p>\n<p><strong>如果元素节点有<code>id</code>或<code>name</code>属性，那么<code>HTMLCollection</code>实例上面，可以使用<code>id</code>属性或<code>name</code>属性引用该节点元素。如果没有对应的节点，则返回<code>null</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>document.images</code>是一个<code>HTMLCollection</code>实例，可以通过<code>&lt;img&gt;</code>元素的<code>id</code>属性值，从<code>HTMLCollection</code>实例上取到这个元素。</p>\n<h4> HTMLCollection.prototype.length</h4>\n<p><code>length</code>属性返回<code>HTMLCollection</code>实例包含的成员数量。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> HTMLCollection.prototype.item()</h4>\n<p><code>item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>item(0)</code>表示返回0号位置的成员。由于方括号运算符也具有同样作用，而且使用更方便，所以一般情况下，总是使用方括号运算符。</p>\n<p>如果参数值超出成员数量或者不合法（比如小于0），那么<code>item</code>方法返回<code>null</code>。</p>\n<h4> HTMLCollection.prototype.namedItem()</h4>\n<p><code>namedItem</code>方法的参数是一个字符串，表示<code>id</code>属性或<code>name</code>属性的值，返回对应的元素节点。如果没有对应的节点，则返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> ParentNode 接口 &amp; ChildNode 接口</h2>\n<h3> ParentNode 接口</h3>\n<h4> 产生</h4>\n<p>如果当前节点是父节点，就会混入了（mixin）<code>ParentNode</code>接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会拥有<code>ParentNode</code>接口。</p>\n<h4> ParentNode.children</h4>\n<p><strong><code>children</code>属性返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有元素子节点。该属性只读。</strong></p>\n<p>下面是遍历某个节点的所有元素子节点的示例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>注意，<code>children</code>属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。</strong></p>\n<p><strong>如果没有元素类型的子节点，返回值<code>HTMLCollection</code>实例的<code>length</code>属性为<code>0</code>。</strong></p>\n<p>另外，<code>HTMLCollection</code>是动态集合，会实时反映 DOM 的任何变化。</p>\n<h4> ParentNode.firstElementChild</h4>\n<p><code>firstElementChild</code>属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>document</code>节点的第一个元素子节点是<code>&lt;HTML&gt;</code>。</p>\n<h4> ParentNode.lastElementChild</h4>\n<p><code>lastElementChild</code>属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>document</code>节点的最后一个元素子节点是<code>&lt;HTML&gt;</code>（因为<code>document</code>只包含这一个元素子节点）。</p>\n<h4> ParentNode.childElementCount</h4>\n<p><code>childElementCount</code>属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回<code>0</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> ParentNode.append()，ParentNode.prepend()</h4>\n<p><strong>（1）ParentNode.append()</strong></p>\n<p><strong><code>append()</code>方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</strong></p>\n<p><strong>该方法不仅可以添加元素子节点（参数为元素节点），还可以添加文本子节点（参数为字符串）。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>该方法没有返回值。</p>\n<p><strong>注意，该方法与<code>Node.prototype.appendChild()</code>方法有三点不同。</strong></p>\n<ul>\n<li><strong><code>append()</code>允许字符串作为参数，<code>appendChild()</code>只允许子节点作为参数。</strong></li>\n<li><strong><code>append()</code>没有返回值，而<code>appendChild()</code>返回添加的子节点。</strong></li>\n<li><strong><code>append()</code>可以添加多个子节点和字符串（即允许多个参数），<code>appendChild()</code>只能添加一个节点（即只允许一个参数）。</strong></li>\n</ul>\n<p><strong>（2）ParentNode.prepend()</strong></p>\n<p><code>prepend()</code>方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与<code>append()</code>方法完全一致，也是没有返回值。</p>\n<h3> ChildNode 接口</h3>\n<h4> 产生</h4>\n<p>如果一个节点有父节点，那么该节点就拥有了<code>ChildNode</code>接口。</p>\n<h4> ChildNode.remove()</h4>\n<p><code>remove()</code>方法用于从父节点移除当前节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码在 DOM 里面移除了<code>el</code>节点。</p>\n<h4> ChildNode.before()，ChildNode.after()</h4>\n<p><strong>（1）ChildNode.before()</strong></p>\n<p><strong><code>before()</code>方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</strong></p>\n<p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>（2）ChildNode.after()</strong></p>\n<p><strong><code>after()</code>方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与<code>before</code>方法完全相同。</strong></p>\n<h4> ChildNode.replaceWith()</h4>\n<p><strong><code>replaceWith()</code>方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>el</code>节点将被<code>span</code>节点替换。</p>\n<h2> Document 节点</h2>\n<h3> 概述</h3>\n<p><code>document</code>节点对象代表整个文档，每张网页都有自己的<code>document</code>对象。<code>window.document</code>属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p>\n<p><strong><code>document</code>对象有不同的办法可以获取：</strong></p>\n<ul>\n<li><strong>正常的网页，直接使用<code>document</code>或<code>window.document</code>。</strong></li>\n<li><strong><code>iframe</code>框架里面的网页，使用<code>iframe</code>节点的<code>contentDocument</code>属性。</strong></li>\n<li><strong>Ajax 操作返回的文档，使用<code>XMLHttpRequest</code>对象的<code>responseXML</code>属性。</strong></li>\n<li><strong>内部节点的<code>ownerDocument</code>属性。</strong></li>\n</ul>\n<p><code>document</code>对象继承了<code>EventTarget</code>接口和<code>Node</code>接口，并且混入（mixin）了<code>ParentNode</code>接口。这意味着，这些接口的方法都可以在<code>document</code>对象上调用。除此之外，<code>document</code>对象还有很多自己的属性和方法。</p>\n<h3> 属性</h3>\n<h4> 快捷方式属性</h4>\n<p>以下属性是指向文档内部的某个节点的快捷方式。</p>\n<p><strong>（1）document.defaultView</strong></p>\n<p><code>document.defaultView</code>属性返回<code>document</code>对象所属的<code>window</code>对象。如果当前文档不属于<code>window</code>对象，该属性返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）document.doctype</strong></p>\n<p>对于 HTML 文档来说，<code>document</code>对象一般有两个子节点。第一个子节点是<code>document.doctype</code>，指向<code>&lt;DOCTYPE&gt;</code>节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成<code>&lt;!DOCTYPE html&gt;</code>。如果网页没有声明 DTD，该属性返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>document.firstChild</code>通常就返回这个节点。</p>\n<p><strong>（3）document.documentElement</strong></p>\n<p><code>document.documentElement</code>属性返回当前文档的根元素节点（root）。它通常是<code>document</code>节点的第二个子节点，紧跟在<code>document.doctype</code>节点后面。HTML网页的该属性，一般是<code>&lt;html&gt;</code>节点。</p>\n<p><strong>（4）document.body，document.head</strong></p>\n<p><code>document.body</code>属性指向<code>&lt;body&gt;</code>节点，<code>document.head</code>属性指向<code>&lt;head&gt;</code>节点。</p>\n<p>这两个属性总是存在的，如果网页源码里面省略了<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。</p>\n<p><strong>（5）document.scrollingElement</strong></p>\n<p><code>document.scrollingElement</code>属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。</p>\n<p>标准模式下，这个属性返回的文档的根元素<code>document.documentElement</code>（即<code>&lt;html&gt;</code>）。兼容（quirk）模式下，返回的是<code>&lt;body&gt;</code>元素，如果该元素不存在，返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（6）document.activeElement</strong></p>\n<p><code>document.activeElement</code>属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>等表单元素，如果当前没有焦点元素，返回<code>&lt;body&gt;</code>元素或<code>null</code>。</p>\n<p><strong>（7）document.fullscreenElement</strong></p>\n<p><code>document.fullscreenElement</code>属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，通过<code>document.fullscreenElement</code>可以知道<code>&lt;video&gt;</code>元素有没有处在全屏状态，从而判断用户行为。</p>\n<h4> 节点集合属性</h4>\n<p>以下属性返回一个<code>HTMLCollection</code>实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。</p>\n<p><strong>（1）document.links</strong></p>\n<p><code>document.links</code>属性返回当前文档所有设定了<code>href</code>属性的<code>&lt;a&gt;</code>及<code>&lt;area&gt;</code>节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）document.forms</strong></p>\n<p><code>document.forms</code>属性返回所有<code>&lt;form&gt;</code>表单节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码获取文档第一个表单。</p>\n<p>除了使用位置序号，<code>id</code>属性和<code>name</code>属性也可以用来引用表单。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（3）document.images</strong></p>\n<p><code>document.images</code>属性返回页面所有<code>&lt;img&gt;</code>图片节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码在所有<code>img</code>标签中，寻找某张图片。</p>\n<p><strong>（4）document.embeds，document.plugins</strong></p>\n<p><code>document.embeds</code>属性和<code>document.plugins</code>属性，都返回所有<code>&lt;embed&gt;</code>节点。</p>\n<p><strong>（5）document.scripts</strong></p>\n<p><code>document.scripts</code>属性返回所有<code>&lt;script&gt;</code>节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（6）document.styleSheets</strong></p>\n<p><code>document.styleSheets</code>属性返回文档内嵌或引入的样式表集合，详细介绍请看《CSS 对象模型》一章。</p>\n<p><strong>（7）小结</strong></p>\n<p>除了<code>document.styleSheets</code>，以上的集合属性返回的都是<code>HTMLCollection</code>实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>HTMLCollection</code>实例是类似数组的对象，所以这些属性都有<code>length</code>属性，都可以使用方括号运算符引用成员。如果成员有<code>id</code>或<code>name</code>属性，还可以用这两个属性的值，在<code>HTMLCollection</code>实例上引用到这个成员。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 文档静态信息属性</h4>\n<p>以下属性返回文档信息。</p>\n<p><strong>（1）document.documentURI，document.URL</strong></p>\n<p><code>document.documentURI</code>属性和<code>document.URL</code>属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，<code>documentURI</code>继承自<code>Document</code>接口，可用于所有文档；<code>URL</code>继承自<code>HTMLDocument</code>接口，只能用于 HTML 文档。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果文档的锚点（<code>#anchor</code>）变化，这两个属性都会跟着变化。</p>\n<p><strong>（2）document.domain</strong></p>\n<p><code>document.domain</code>属性返回当前文档的域名，不包含协议和端口。比如，网页的网址是<code>http://www.example.com:80/hello.html</code>，那么<code>document.domain</code>属性就等于<code>www.example.com</code>。如果无法获取域名，该属性返回<code>null</code>。</p>\n<p><code>document.domain</code>基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把<code>document.domain</code>设为对应的上级域名。比如，当前域名是<code>a.sub.example.com</code>，则<code>document.domain</code>属性可以设置为<code>sub.example.com</code>，也可以设为<code>example.com</code>。修改后，<code>document.domain</code>相同的两个网页，可以读取对方的资源，比如设置的 Cookie。</p>\n<p>另外，设置<code>document.domain</code>会导致端口被改成<code>null</code>。因此，如果通过设置<code>document.domain</code>来进行通信，双方网页都必须设置这个值，才能保证端口相同。</p>\n<p><strong>（3）document.location</strong></p>\n<p><code>Location</code>对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过<code>window.location</code>和<code>document.location</code>属性，可以拿到这个对象。</p>\n<p>关于这个对象的详细介绍，请看《浏览器模型》部分的《Location 对象》章节。</p>\n<p><strong>（4）document.lastModified</strong></p>\n<p><code>document.lastModified</code>属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>document.lastModified</code>属性的值是字符串，所以不能直接用来比较。<code>Date.parse</code>方法将其转为<code>Date</code>实例，才能比较两个网页。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果页面上有 JavaScript 生成的内容，<code>document.lastModified</code>属性返回的总是当前时间。</p>\n<p><strong>（5）document.title</strong></p>\n<p><code>document.title</code>属性返回当前文档的标题。默认情况下，返回<code>&lt;title&gt;</code>节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（6）document.characterSet</strong></p>\n<p><code>document.characterSet</code>属性返回当前文档的编码，比如<code>UTF-8</code>、<code>ISO-8859-1</code>等等。</p>\n<p><strong>（7）document.referrer</strong></p>\n<p><code>document.referrer</code>属性返回一个字符串，表示当前文档的访问者来自哪里。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，<code>document.referrer</code>返回一个空字符串。</p>\n<p><code>document.referrer</code>的值，总是与 HTTP 头信息的<code>Referer</code>字段保持一致。但是，<code>document.referrer</code>的拼写有两个<code>r</code>，而头信息的<code>Referer</code>字段只有一个<code>r</code>。</p>\n<p><strong>（8）document.dir</strong></p>\n<p><code>document.dir</code>返回一个字符串，表示文字方向。它只有两个可能的值：<code>rtl</code>表示文字从右到左，阿拉伯文是这种方式；<code>ltr</code>表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</p>\n<p><strong>（9）document.compatMode</strong></p>\n<p><code>compatMode</code>属性返回浏览器处理文档的模式，可能的值为<code>BackCompat</code>（向后兼容模式）和<code>CSS1Compat</code>（严格模式）。</p>\n<p>一般来说，如果网页代码的第一行设置了明确的<code>DOCTYPE</code>（比如<code>&lt;!doctype html&gt;</code>），<code>document.compatMode</code>的值都为<code>CSS1Compat</code>。</p>\n<h4> 文档状态属性</h4>\n<p><strong>（1）document.hidden</strong></p>\n<p><code>document.hidden</code>属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得<code>document.hidden</code>返回<code>true</code>。</p>\n<p>这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。</p>\n<p><strong>（2）document.visibilityState</strong></p>\n<p><code>document.visibilityState</code>返回文档的可见状态。</p>\n<p>它的值有四种可能。</p>\n<blockquote>\n<ul>\n<li><code>visible</code>：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。</li>\n<li><code>hidden</code>：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。</li>\n<li><code>prerender</code>：页面处于正在渲染状态，对于用户来说，该页面不可见。</li>\n<li><code>unloaded</code>：页面从内存里面卸载了。</li>\n</ul>\n</blockquote>\n<p>这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。</p>\n<p><strong>（3）document.readyState</strong></p>\n<p><code>document.readyState</code>属性返回当前文档的状态，共有三种可能的值。</p>\n<ul>\n<li><code>loading</code>：加载 HTML 代码阶段（尚未完成解析）</li>\n<li><code>interactive</code>：加载外部资源阶段</li>\n<li><code>complete</code>：加载完成</li>\n</ul>\n<p>这个属性变化的过程如下。</p>\n<ol>\n<li>浏览器开始解析 HTML 文档，<code>document.readyState</code>属性等于<code>loading</code>。</li>\n<li>浏览器遇到 HTML 文档中的<code>&lt;script&gt;</code>元素，并且没有<code>async</code>或<code>defer</code>属性，就暂停解析，开始执行脚本，这时<code>document.readyState</code>属性还是等于<code>loading</code>。</li>\n<li>HTML 文档解析完成，<code>document.readyState</code>属性变成<code>interactive</code>。</li>\n<li>浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，<code>document.readyState</code>属性变成<code>complete</code>。</li>\n</ol>\n<p>下面的代码用来检查网页是否加载成功。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，每次状态变化都会触发一个<code>readystatechange</code>事件。</p>\n<h4> document.cookie</h4>\n<p><code>document.cookie</code>属性用来操作浏览器 Cookie。</p>\n<h4> document.designMode</h4>\n<p><code>document.designMode</code>属性控制当前文档是否可编辑。该属性只有两个值<code>on</code>和<code>off</code>，默认值为<code>off</code>。一旦设为<code>on</code>，用户就可以编辑整个文档的内容。</p>\n<p>下面代码打开<code>iframe</code>元素内部文档的<code>designMode</code>属性，就能将其变为一个所见即所得的编辑器。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> document.currentScript</h4>\n<p><code>document.currentScript</code>属性只用在<code>&lt;script&gt;</code>元素的内嵌脚本或加载的外部脚本之中，返回当前脚本所在的那个 DOM 节点，即<code>&lt;script&gt;</code>元素的 DOM 节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>document.currentScript</code>就是<code>&lt;script&gt;</code>元素节点。</p>\n<h4> document.implementation</h4>\n<p><code>document.implementation</code>属性返回一个<code>DOMImplementation</code>对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。</p>\n<ul>\n<li><code>DOMImplementation.createDocument()</code>：创建一个 XML 文档。</li>\n<li><code>DOMImplementation.createHTMLDocument()</code>：创建一个 HTML 文档。</li>\n<li><code>DOMImplementation.createDocumentType()</code>：创建一个 DocumentType 对象。</li>\n</ul>\n<p>下面是创建 HTML 文档的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，第一步生成一个新的 HTML 文档<code>doc</code>，然后用它的根元素<code>document.documentElement</code>替换掉<code>document.documentElement</code>。这会使得当前文档的内容全部消失，变成<code>hello world</code>。</p>\n<h3> 方法</h3>\n<h4> document.open()，document.close()</h4>\n<p><code>document.open</code>方法清除当前文档所有内容，使得文档处于可写状态，供<code>document.write</code>方法写入内容。</p>\n<p><code>document.close</code>方法用来关闭<code>document.open()</code>打开的文档。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> document.write()，document.writeln()</h4>\n<p><code>document.write</code>方法用于向当前文档写入内容。</p>\n<p>在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行<code>document.close()</code>），<code>document.write</code>写入的内容就会追加在已有内容的后面。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>document.write</code>会当作 HTML 代码解析，不会转义。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>document.write</code>会将<code>&lt;p&gt;</code>当作 HTML 标签解释。</p>\n<p>如果页面已经解析完成（<code>DOMContentLoaded</code>事件发生之后），再调用<code>write</code>方法，它会先调用<code>open</code>方法，擦除当前文档所有内容，然后再写入。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果在页面渲染过程中调用<code>write</code>方法，并不会自动调用<code>open</code>方法。（可以理解成，<code>open</code>方法已调用，但<code>close</code>方法还未调用。）</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>在浏览器打开上面网页，将会显示<code>hello world</code>。</p>\n<p><code>document.write</code>是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对<code>innerHTML</code>属性赋值）。所以，除了某些特殊情况，应该尽量避免使用<code>document.write</code>这个方法。</p>\n<p><code>document.writeln</code>方法与<code>write</code>方法完全一致，除了会在输出内容的尾部添加换行符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>writeln</code>方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入<code>&lt;br&gt;</code>。</p>\n<h4> document.querySelector()，document.querySelectorAll()</h4>\n<p><strong><code>document.querySelector</code>方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回<code>null</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>document.querySelectorAll</code>方法与<code>querySelector</code>用法类似，区别是返回一个<code>NodeList</code>对象，包含所有匹配给定选择器的节点。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码返回<code>class</code>属性是<code>note</code>或<code>alert</code>的<code>div</code>元素。</p>\n<p>这两个方法都支持复杂的 CSS 选择器。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是，它们不支持 CSS 伪元素的选择器（比如<code>:first-line</code>和<code>:first-letter</code>）和伪类的选择器（比如<code>:link</code>和<code>:visited</code>），即无法选中伪元素和伪类。</p>\n<p>如果<code>querySelectorAll</code>方法的参数是字符串<code>*</code>，则会返回文档中的所有元素节点。另外，<code>querySelectorAll</code>的返回结果不是动态集合，不会实时反映元素节点的变化。</p>\n<p>最后，这两个方法除了定义在<code>document</code>对象上，还定义在元素节点上，即在元素节点上也可以调用。</p>\n<h4> document.getElementsByTagName()</h4>\n<p><code>document.getElementsByTagName()</code>方法搜索 HTML 标签名，返回符合条件的元素。**它的返回值是一个类似数组对象（<code>HTMLCollection</code>实例），可以实时反映 HTML 文档的变化。**如果没有任何匹配的元素，就返回一个空集。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码返回当前文档的所有<code>p</code>元素节点。</p>\n<p>HTML 标签名是大小写不敏感的，因此<code>getElementsByTagName()</code>方法的参数也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。</p>\n<p>如果传入<code>*</code>，就可以返回文档中所有 HTML 元素。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，元素节点本身也定义了<code>getElementsByTagName</code>方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码选中第一个<code>p</code>元素内部的所有<code>span</code>元素。</p>\n<h4> document.getElementsByClassName()</h4>\n<p><strong><code>document.getElementsByClassName()</code>方法返回一个类似数组的对象（<code>HTMLCollection</code>实例），包括了所有<code>class</code>名字符合指定条件的元素，元素的变化实时反映在返回结果中。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于<code>class</code>是保留字，所以 JavaScript 一律使用<code>className</code>表示 CSS 的<code>class</code>。</p>\n<p>参数可以是多个<code>class</code>，它们之间使用空格分隔。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码返回同时具有<code>foo</code>和<code>bar</code>两个<code>class</code>的元素，<code>foo</code>和<code>bar</code>的顺序不重要。</p>\n<p>注意，正常模式下，CSS 的<code>class</code>是大小写敏感的。（<code>quirks mode</code>下，大小写不敏感。）</p>\n<p>与<code>getElementsByTagName()</code>方法一样，<code>getElementsByClassName()</code>方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> document.getElementsByName()</h4>\n<p><code>document.getElementsByName()</code>方法用于选择拥有<code>name</code>属性的 HTML 元素（比如<code>&lt;form&gt;</code>、<code>&lt;radio&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;frame&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;object&gt;</code>等），返回一个类似数组的的对象（<code>NodeList</code>实例），因为<code>name</code>属性相同的元素可能不止一个。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> document.getElementById()</h4>\n<p><code>document.getElementById()</code>方法返回匹配指定<code>id</code>属性的元素节点。如果没有发现匹配的节点，则返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，该方法的参数是大小写敏感的。比如，如果某个节点的<code>id</code>属性是<code>main</code>，那么<code>document.getElementById('Main')</code>将返回<code>null</code>。</p>\n<p><code>document.getElementById()</code>方法与<code>document.querySelector()</code>方法都能获取元素节点，不同之处是<code>document.querySelector()</code>方法的参数使用 CSS 选择器语法，<code>document.getElementById()</code>方法的参数是元素的<code>id</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，两个方法都能选中<code>id</code>为<code>myElement</code>的元素，但是<code>document.getElementById()</code>比<code>document.querySelector()</code>效率高得多。</p>\n<p>另外，这个方法只能在<code>document</code>对象上使用，不能在其他元素节点上使用。</p>\n<h4> document.elementFromPoint()，document.elementsFromPoint()</h4>\n<p><code>document.elementFromPoint()</code>方法返回位于页面指定位置最上层的元素节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码选中在<code>(50, 50)</code>这个坐标位置的最上层的那个 HTML 元素。</p>\n<p><code>elementFromPoint</code>方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回<code>null</code>。</p>\n<p><code>document.elementsFromPoint()</code>返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><h4> document.createElement()</h4>\n<p><code>document.createElement</code>方法用来生成元素节点，并返回该节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>createElement</code>方法的参数为元素的标签名，即元素节点的<code>tagName</code>属性，对于 HTML 网页大小写不敏感，即参数为<code>div</code>或<code>DIV</code>返回的是同一种节点。如果参数里面包含尖括号（即<code>&lt;</code>和<code>&gt;</code>）会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>document.createElement</code>的参数可以是自定义的标签名。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> document.createTextNode()</h4>\n<p><code>document.createTextNode</code>方法用来生成文本节点（<code>Text</code>实例），并返回该节点。它的参数是文本节点的内容。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码新建一个<code>div</code>节点和一个文本节点，然后将文本节点插入<code>div</code>节点。</p>\n<p>这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>createTextNode</code>方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。</p>\n<p>需要注意的是，该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，由于<code>createTextNode</code>方法不转义双引号，导致<code>onmouseover</code>方法被注入了代码。</p>\n<h4> document.createAttribute()</h4>\n<p><code>document.createAttribute</code>方法生成一个新的属性节点（<code>Attr</code>实例），并返回它。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>document.createAttribute</code>方法的参数<code>name</code>，是属性的名称。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码为<code>div1</code>节点，插入一个值为<code>newVal</code>的<code>my_attrib</code>属性。</p>\n<h4> document.createComment()</h4>\n<p><code>document.createComment</code>方法生成一个新的注释节点，并返回该节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>document.createComment</code>方法的参数是一个字符串，会成为注释节点的内容。</p>\n<h4> document.createDocumentFragment()</h4>\n<p><code>document.createDocumentFragment</code>方法生成一个空的文档片段对象（<code>DocumentFragment</code>实例）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>DocumentFragment</code>是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为<code>DocumentFragment</code>不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，文档片断<code>docfrag</code>包含四个<code>&lt;li&gt;</code>节点，这些子节点被一次性插入了当前文档。</p>\n<h4> document.createEvent()</h4>\n<p><code>document.createEvent</code>方法生成一个事件对象（<code>Event</code>实例），该对象可以被<code>element.dispatchEvent</code>方法使用，触发指定事件。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>document.createEvent</code>方法的参数是事件类型，比如<code>UIEvents</code>、<code>MouseEvents</code>、<code>MutationEvents</code>、<code>HTMLEvents</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码新建了一个名为<code>build</code>的事件实例，然后触发该事件。</p>\n<h4> document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</h4>\n<p>这三个方法用于处理<code>document</code>节点的事件。它们都继承自<code>EventTarget</code>接口，详细介绍参见《EventTarget 接口》一章。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> document.hasFocus()</h4>\n<p><code>document.hasFocus</code>方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。</p>\n<h4> document.adoptNode()，document.importNode()</h4>\n<p><code>document.adoptNode</code>方法将某个节点及其子节点，从原来所在的文档或<code>DocumentFragment</code>里面移除，归属当前<code>document</code>对象，返回插入后的新节点。插入的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>document.adoptNode</code>方法只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用<code>appendChild</code>方法或<code>insertBefore</code>方法，将新节点插入当前文档树。</p>\n<p><code>document.importNode</code>方法则是从原来所在的文档或<code>DocumentFragment</code>里面，拷贝某个节点及其子节点，让它们归属当前<code>document</code>对象。拷贝的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>document.importNode</code>方法的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（false）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为<code>true</code>。</p>\n<p>注意，<code>document.importNode</code>方法只是拷贝外部节点，这时该节点的父节点是<code>null</code>。下一步还必须将这个节点插入当前文档树。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码从<code>iframe</code>窗口，拷贝一个指定节点<code>myNode</code>，插入当前文档。</p>\n<h4> document.createNodeIterator()</h4>\n<p><code>document.createNodeIterator</code>方法返回一个子节点遍历器。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码返回<code>&lt;body&gt;</code>元素子节点的遍历器。</p>\n<p><code>document.createNodeIterator</code>方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型，这里指定为元素节点（<code>NodeFilter.SHOW_ELEMENT</code>）。几种主要的节点类型写法如下。</p>\n<ul>\n<li>所有节点：NodeFilter.SHOW_ALL</li>\n<li>元素节点：NodeFilter.SHOW_ELEMENT</li>\n<li>文本节点：NodeFilter.SHOW_TEXT</li>\n<li>评论节点：NodeFilter.SHOW_COMMENT</li>\n</ul>\n<p><code>document.createNodeIterator</code>方法返回一个“遍历器”对象（<code>NodeFilter</code>实例）。该实例的<code>nextNode()</code>方法和<code>previousNode()</code>方法，可以用来遍历所有子节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，使用遍历器的<code>nextNode</code>方法，将根节点的所有子节点，依次读入一个数组。<code>nextNode</code>方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回<code>null</code>。<code>previousNode</code>方法则是先将指针移向上一个节点，然后返回该节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>currentNode</code>和<code>previousNode</code>都指向同一个的节点。</p>\n<p>注意，遍历器返回的第一个节点，总是根节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> document.createTreeWalker()</h4>\n<p><code>document.createTreeWalker</code>方法返回一个 DOM 的子树遍历器。它与<code>document.createNodeIterator</code>方法基本是类似的，区别在于它返回的是<code>TreeWalker</code>实例，后者返回的是<code>NodeIterator</code>实例。另外，它的第一个节点不是根节点。</p>\n<p><code>document.createTreeWalker</code>方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型（与<code>document.createNodeIterator</code>方法的第二个参数相同）。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码遍历<code>&lt;body&gt;</code>节点下属的所有元素节点，将它们插入<code>nodeList</code>数组。</p>\n<h4> document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()</h4>\n<p><strong>（1）document.execCommand()</strong></p>\n<p>如果<code>document.designMode</code>属性设为<code>on</code>，那么整个文档用户可编辑；如果元素的<code>contenteditable</code>属性设为<code>true</code>，那么该元素可编辑。这两种情况下，可以使用<code>document.execCommand()</code>方法，改变内容的样式，比如<code>document.execCommand('bold')</code>会使得字体加粗。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法接受三个参数。</p>\n<ul>\n<li><code>command</code>：字符串，表示所要实施的样式。</li>\n<li><code>showDefaultUI</code>：布尔值，表示是否要使用默认的用户界面，建议总是设为<code>false</code>。</li>\n<li><code>input</code>：字符串，表示该样式的辅助内容，比如生成超级链接时，这个参数就是所要链接的网址。如果第二个参数设为<code>true</code>，那么浏览器会弹出提示框，要求用户在提示框输入该参数。但是，不是所有浏览器都支持这样做，为了兼容性，还是需要自己部署获取这个参数的方式。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，先提示用户输入所要链接的网址，然后手动生成超级链接。注意，第二个参数是<code>false</code>，表示此时不需要自动弹出提示框。</p>\n<p><code>document.execCommand()</code>的返回值是一个布尔值。如果为<code>false</code>，表示这个方法无法生效。</p>\n<p>这个方法大部分情况下，只对选中的内容生效。如果有多个内容可编辑区域，那么只对当前焦点所在的元素生效。</p>\n<p><code>document.execCommand()</code>方法可以执行的样式改变有很多种，下面是其中的一些：bold、insertLineBreak、selectAll、createLink、insertOrderedList、subscript、delete、insertUnorderedList、superscript、formatBlock、insertParagraph、undo、forwardDelete、insertText、unlink、insertImage、italic、unselect、insertHTML、redo。这些值都可以用作第一个参数，它们的含义不难从字面上看出来。</p>\n<p><strong>（2）document.queryCommandSupported()</strong></p>\n<p><code>document.queryCommandSupported()</code>方法返回一个布尔值，表示浏览器是否支持<code>document.execCommand()</code>的某个命令。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（3）document.queryCommandEnabled()</strong></p>\n<p><code>document.queryCommandEnabled()</code>方法返回一个布尔值，表示当前是否可用<code>document.execCommand()</code>的某个命令。比如，<code>bold</code>（加粗）命令只有存在文本选中时才可用，如果没有选中文本，就不可用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，先判断浏览器是否支持<code>copy</code>命令（允许可编辑区域的选中内容，复制到剪贴板），如果支持，就新建一个临时文本框，里面写入内容“你好”，并将其选中。然后，判断是否选中成功，如果成功，就将“你好”复制到剪贴板，再删除那个临时文本框。</p>\n<h4> document.getSelection()</h4>\n<p>这个方法指向<code>window.getSelection()</code>，参见<code>BOM</code>对象一节的介绍。</p>\n<h2> Element 节点</h2>\n<h3> 简介</h3>\n<p><code>Element</code>节点对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个<code>Element</code>节点对象（以下简称元素节点）。</p>\n<p>元素节点的<code>nodeType</code>属性都是<code>1</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Element</code>对象继承了<code>Node</code>接口，因此<code>Node</code>的属性和方法在<code>Element</code>对象都存在。</p>\n<p>此外，不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点，比如<code>&lt;a&gt;</code>元素的构造函数是<code>HTMLAnchorElement()</code>，<code>&lt;button&gt;</code>是<code>HTMLButtonElement()</code>。因此，元素节点不是一种对象，而是许多种对象，这些对象除了继承<code>Element</code>对象的属性和方法，还有各自独有的属性和方法。</p>\n<h3> 实例属性</h3>\n<h4> 元素特性的相关属性</h4>\n<p><strong>（1）Element.id</strong></p>\n<p><code>Element.id</code>属性返回指定元素的<code>id</code>属性，该属性可读写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>id</code>属性的值是大小写敏感，即浏览器能正确识别<code>&lt;p id=\"foo\"&gt;</code>和<code>&lt;p id=\"FOO\"&gt;</code>这两个元素的<code>id</code>属性，但是最好不要这样命名。</p>\n<p><strong>（2）Element.tagName</strong></p>\n<p><code>Element.tagName</code>属性返回指定元素的大写标签名，与<code>nodeName</code>属性的值相等。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（3）Element.dir</strong></p>\n<p><code>Element.dir</code>属性用于读写当前元素的文字方向，可能是从左到右（<code>\"ltr\"</code>），也可能是从右到左（<code>\"rtl\"</code>）。</p>\n<p><strong>（4）Element.accessKey</strong></p>\n<p><code>Element.accessKey</code>属性用于读写分配给当前元素的快捷键。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>btn</code>元素的快捷键是<code>h</code>，按下<code>Alt + h</code>就能将焦点转移到它上面。</p>\n<p><strong>（5）Element.draggable</strong></p>\n<p><code>Element.draggable</code>属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。</p>\n<p><strong>（6）Element.lang</strong></p>\n<p><code>Element.lang</code>属性返回当前元素的语言设置。该属性可读写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（7）Element.tabIndex</strong></p>\n<p><code>Element.tabIndex</code>属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。</p>\n<p><code>tabIndex</code>属性值如果是负值（通常是<code>-1</code>），则 Tab 键不会遍历到该元素。如果是正整数，则按照顺序，从小到大遍历。如果两个元素的<code>tabIndex</code>属性的正整数值相同，则按照出现的顺序遍历。遍历完所有<code>tabIndex</code>为正整数的元素以后，再遍历所有<code>tabIndex</code>等于<code>0</code>、或者属性值是非法值、或者没有<code>tabIndex</code>属性的元素，顺序为它们在网页中出现的顺序。</p>\n<p><strong>（8）Element.title</strong></p>\n<p><code>Element.title</code>属性用来读写当前元素的 HTML 属性<code>title</code>。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</p>\n<h4> 元素状态的相关属性</h4>\n<p><strong>（1）Element.hidden</strong></p>\n<p><code>Element.hidden</code>属性返回一个布尔值，表示当前元素的<code>hidden</code>属性，用来控制当前元素是否可见。该属性可读写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，<code>Element.hidden</code>并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</p>\n<p>CSS 的设置高于<code>Element.hidden</code>。如果 CSS 指定了该元素不可见（<code>display: none</code>）或可见（<code>display: hidden</code>），那么<code>Element.hidden</code>并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</p>\n<p><strong>（2）Element.contentEditable，Element.isContentEditable</strong></p>\n<p>HTML 元素可以设置<code>contentEditable</code>属性，使得元素的内容可以编辑。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>&lt;div&gt;</code>元素有<code>contenteditable</code>属性，因此用户可以在网页上编辑这个区块的内容。</p>\n<p><code>Element.contentEditable</code>属性返回一个字符串，表示是否设置了<code>contenteditable</code>属性，有三种可能的值。该属性可写。</p>\n<ul>\n<li><code>\"true\"</code>：元素内容可编辑</li>\n<li><code>\"false\"</code>：元素内容不可编辑</li>\n<li><code>\"inherit\"</code>：元素是否可编辑，继承了父元素的设置</li>\n</ul>\n<p><code>Element.isContentEditable</code>属性返回一个布尔值，同样表示是否设置了<code>contenteditable</code>属性。该属性只读。</p>\n<h4> Element.attributes</h4>\n<p><code>Element.attributes</code>属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点，详见《属性的操作》。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码遍历<code>p</code>元素的所有属性。</p>\n<h4> Element.className，Element.classList</h4>\n<p><code>className</code>属性用来读写当前元素节点的<code>class</code>属性。它的值是一个字符串，每个<code>class</code>之间用空格分割。</p>\n<p><code>classList</code>属性返回一个类似数组的对象，当前元素节点的每个<code>class</code>就是这个对象的一个成员。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>className</code>属性返回一个空格分隔的字符串，而<code>classList</code>属性指向一个类似数组的对象，该对象的<code>length</code>属性（只读）返回当前元素的<code>class</code>数量。</p>\n<p><code>classList</code>对象有下列方法。</p>\n<ul>\n<li><code>add()</code>：增加一个 class。</li>\n<li><code>remove()</code>：移除一个 class。</li>\n<li><code>contains()</code>：检查当前元素是否包含某个 class。</li>\n<li><code>toggle()</code>：将某个 class 移入或移出当前元素。</li>\n<li><code>item()</code>：返回指定索引位置的 class。</li>\n<li><code>toString()</code>：将 class 的列表转为字符串。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面比较一下，<code>className</code>和<code>classList</code>在添加和删除某个 class 时的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>toggle</code>方法可以接受一个布尔值，作为第二个参数。如果为<code>true</code>，则添加该属性；如果为<code>false</code>，则去除该属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Element.dataset</h4>\n<p>网页元素可以自定义<code>data-</code>属性，用来添加数据。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码中，<code>&lt;div&gt;</code>元素有一个自定义的<code>data-timestamp</code>属性，用来为该元素添加一个时间戳。</p>\n<p><code>Element.dataset</code>属性返回一个对象，可以从这个对象读写<code>data-</code>属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，<code>dataset</code>上面的各个属性返回都是字符串。</p>\n<p>HTML 代码中，<code>data-</code>属性的属性名，只能包含英文字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>）。它们转成 JavaScript 对应的<code>dataset</code>属性名，规则如下。</p>\n<ul>\n<li>开头的<code>data-</code>会省略。</li>\n<li>如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。</li>\n<li>其他字符不变。</li>\n</ul>\n<p>因此，<code>data-abc-def</code>对应<code>dataset.abcDef</code>，<code>data-abc-1</code>对应<code>dataset[\"abc-1\"]</code>。</p>\n<p>除了使用<code>dataset</code>读写<code>data-</code>属性，也可以使用<code>Element.getAttribute()</code>和<code>Element.setAttribute()</code>，通过完整的属性名读写这些属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Element.innerHTML</h4>\n<p><code>Element.innerHTML</code>属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括<code>&lt;HTML&gt;</code>和<code>&lt;body&gt;</code>元素。</p>\n<p>如果将<code>innerHTML</code>属性设为空，等于删除所有它包含的所有节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码等于将<code>el</code>节点变成了一个空节点，<code>el</code>原来包含的节点被全部删除。</p>\n<p>注意，读取属性值的时候，如果文本节点包含<code>&amp;</code>、小于号（<code>&lt;</code>）和大于号（<code>&gt;</code>），<code>innerHTML</code>属性会将它们转为实体形式<code>&amp;</code>、<code>&lt;</code>、<code>&gt;</code>。如果想得到原文，建议使用<code>element.textContent</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>写入的时候，如果插入的文本包含 HTML 标签，会被解析成为节点对象插入 DOM。注意，如果文本之中含有<code>&lt;script&gt;</code>标签，虽然可以生成<code>script</code>节点，但是插入的代码不会执行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将脚本插入内容，脚本并不会执行。但是，<code>innerHTML</code>还是有安全风险的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>alert</code>方法是会执行的。因此为了安全考虑，如果插入的是文本，最好用<code>textContent</code>属性代替<code>innerHTML</code>。</p>\n<h4> Element.outerHTML</h4>\n<p><code>Element.outerHTML</code>属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>outerHTML</code>属性是可读写的，对它进行赋值，等于替换掉当前元素。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，变量<code>d</code>代表子节点，它的<code>outerHTML</code>属性重新赋值以后，内层的<code>div</code>元素就不存在了，被<code>p</code>元素替换了。但是，变量<code>d</code>依然指向原来的<code>div</code>元素，这表示被替换的<code>DIV</code>元素还存在于内存中。</p>\n<p>注意，如果一个节点没有父节点，设置<code>outerHTML</code>属性会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>div</code>元素没有父节点，设置<code>outerHTML</code>属性会报错。</p>\n<h4> Element.clientHeight，Element.clientWidth</h4>\n<p><code>Element.clientHeight</code>属性返回一个整数值，表示元素节点的 CSS 高度（单位像素），只对块级元素生效，对于行内元素返回<code>0</code>。如果块级元素没有设置 CSS 高度，则返回实际高度。</p>\n<p>除了元素本身的高度，它还包括<code>padding</code>部分，但是不包括<code>border</code>、<code>margin</code>。如果有水平滚动条，还要减去水平滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。</p>\n<p><code>Element.clientWidth</code>属性返回元素节点的 CSS 宽度，同样只对块级元素有效，也是只包括元素本身的宽度和<code>padding</code>，如果有垂直滚动条，还要减去垂直滚动条的宽度。</p>\n<p><code>document.documentElement</code>的<code>clientHeight</code>属性，返回当前视口的高度（即浏览器窗口的高度），等同于<code>window.innerHeight</code>属性减去水平滚动条的高度（如果有的话）。<code>document.body</code>的高度则是网页的实际高度。一般来说，<code>document.body.clientHeight</code>大于<code>document.documentElement.clientHeight</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Element.clientLeft，Element.clientTop</h4>\n<p><code>Element.clientLeft</code>属性等于元素节点左边框（left border）的宽度（单位像素），不包括左侧的<code>padding</code>和<code>margin</code>。如果没有设置左边框，或者是行内元素（<code>display: inline</code>），该属性返回<code>0</code>。该属性总是返回整数值，如果是小数，会四舍五入。</p>\n<p><code>Element.clientTop</code>属性等于网页元素顶部边框的宽度（单位像素），其他特点都与<code>clientLeft</code>相同。</p>\n<h4> Element.scrollHeight，Element.scrollWidth</h4>\n<p><code>Element.scrollHeight</code>属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括<code>padding</code>，但是不包括<code>border</code>、<code>margin</code>以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（<code>::before</code>或<code>::after</code>）的高度。</p>\n<p><code>Element.scrollWidth</code>属性表示当前元素的总宽度（单位像素），其他地方都与<code>scrollHeight</code>属性类似。这两个属性只读。</p>\n<p>整张网页的总高度可以从<code>document.documentElement</code>或<code>document.body</code>上读取。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，如果元素节点的内容出现溢出，即使溢出的内容是隐藏的，<code>scrollHeight</code>属性仍然返回元素的总高度。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，即使<code>myDiv</code>元素的 CSS 高度只有200像素，且溢出部分不可见，但是<code>scrollHeight</code>仍然会返回该元素的原始高度。</p>\n<h4> Element.scrollLeft，Element.scrollTop</h4>\n<p><code>Element.scrollLeft</code>属性表示当前元素的水平滚动条向右侧滚动的像素数量，<code>Element.scrollTop</code>属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0。</p>\n<p>如果要查看整张网页的水平的和垂直的滚动距离，要从<code>document.documentElement</code>元素上读取。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这两个属性都可读写，设置该属性的值，会导致浏览器将当前元素自动滚动到相应的位置。</p>\n<h4> Element.offsetParent</h4>\n<p><code>Element.offsetParent</code>属性返回最靠近当前元素的、并且 CSS 的<code>position</code>属性不等于<code>static</code>的上层元素。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性就是<code>div</code>元素。</p>\n<p>该属性主要用于确定子元素位置偏移的计算基准，<code>Element.offsetTop</code>和<code>Element.offsetLeft</code>就是<code>offsetParent</code>元素计算的。</p>\n<p>如果该元素是不可见的（<code>display</code>属性为<code>none</code>），或者位置是固定的（<code>position</code>属性为<code>fixed</code>），则<code>offsetParent</code>属性返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性是<code>null</code>。</p>\n<p>如果某个元素的所有上层节点的<code>position</code>属性都是<code>static</code>，则<code>Element.offsetParent</code>属性指向<code>&lt;body&gt;</code>元素。</p>\n<h4> Element.offsetHeight，Element.offsetWidth</h4>\n<p><code>Element.offsetHeight</code>属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。</p>\n<p><code>Element.offsetWidth</code>属性表示元素的 CSS 水平宽度（单位像素），其他都与<code>Element.offsetHeight</code>一致。</p>\n<p>这两个属性都是只读属性，只比<code>Element.clientHeight</code>和<code>Element.clientWidth</code>多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如<code>display: none;</code>），则返回<code>0</code>。</p>\n<h4> Element.offsetLeft，Element.offsetTop</h4>\n<p><code>Element.offsetLeft</code>返回当前元素左上角相对于<code>Element.offsetParent</code>节点的水平位移，<code>Element.offsetTop</code>返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移。</p>\n<p>下面的代码可以算出元素左上角相对于整张网页的坐标。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> Element.style</h4>\n<p>每个元素节点都有<code>style</code>用来读写该元素的行内样式信息，具体介绍参见《CSS 操作》一章。</p>\n<h4> Element.children，Element.childElementCount</h4>\n<p><code>Element.children</code>属性返回一个类似数组的对象（<code>HTMLCollection</code>实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码遍历了<code>para</code>元素的所有子元素。</p>\n<p>这个属性与<code>Node.childNodes</code>属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。</p>\n<p><code>Element.childElementCount</code>属性返回当前元素节点包含的子元素节点的个数，与<code>Element.children.length</code>的值相同。</p>\n<h4> Element.firstElementChild，Element.lastElementChild</h4>\n<p><code>Element.firstElementChild</code>属性返回当前元素的第一个元素子节点，<code>Element.lastElementChild</code>返回最后一个元素子节点。</p>\n<p>如果没有元素子节点，这两个属性返回<code>null</code>。</p>\n<h4> Element.nextElementSibling，Element.previousElementSibling</h4>\n<p><code>Element.nextElementSibling</code>属性返回当前元素节点的后一个同级元素节点，如果没有则返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Element.previousElementSibling</code>属性返回当前元素节点的前一个同级元素节点，如果没有则返回<code>null</code>。</p>\n<h3> 实例方法</h3>\n<h4> 属性相关方法</h4>\n<p>元素节点提供六个方法，用来操作属性。</p>\n<ul>\n<li><code>getAttribute()</code>：读取某个属性的值</li>\n<li><code>getAttributeNames()</code>：返回当前元素的所有属性名</li>\n<li><code>setAttribute()</code>：写入属性值</li>\n<li><code>hasAttribute()</code>：某个属性是否存在</li>\n<li><code>hasAttributes()</code>：当前元素是否有属性</li>\n<li><code>removeAttribute()</code>：删除属性</li>\n</ul>\n<p>这些方法的介绍请看《属性的操作》一章。</p>\n<h4> Element.querySelector()</h4>\n<p><code>Element.querySelector</code>方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码返回<code>content</code>节点的第一个<code>p</code>元素。</p>\n<p><code>Element.querySelector</code>方法可以接受任何复杂的 CSS 选择器。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，这个方法无法选中伪元素。</p>\n<p>它可以接受多个选择器，它们之间使用逗号分隔。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码返回<code>element</code>的第一个<code>div</code>或<code>p</code>子元素。</p>\n<p>需要注意的是，浏览器执行<code>querySelector</code>方法时，是先在全局范围内搜索给定的 CSS 选择器，然后过滤出哪些属于当前元素的子元素。因此，会有一些违反直觉的结果，下面是一段 HTML 代码。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>那么，像下面这样查询的话，实际上返回的是第一个<code>p</code>元素，而不是第二个。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Element.querySelectorAll()</h4>\n<p><code>Element.querySelectorAll</code>方法接受 CSS 选择器作为参数，返回一个<code>NodeList</code>实例，包含所有匹配的子元素。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法的执行机制与<code>querySelector</code>方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。因此，选择器实际上针对整个文档的。</p>\n<p>它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。如果选择器里面有伪元素的选择器，则总是返回一个空的<code>NodeList</code>实例。</p>\n<h4> Element.getElementsByClassName()</h4>\n<p><code>Element.getElementsByClassName</code>方法返回一个<code>HTMLCollection</code>实例，成员是当前元素节点的所有具有指定 class 的子元素节点。该方法与<code>document.getElementsByClassName</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，该方法的参数大小写敏感。</p>\n<p>由于<code>HTMLCollection</code>实例是一个活的集合，<code>document</code>对象的任何变化会立刻反应到实例，下面的代码不会生效。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>matches</code>集合的第一个成员，一旦被拿掉 class 里面的<code>foo</code>，就会立刻从<code>matches</code>里面消失，导致出现上面的结果。</p>\n<h4> Element.getElementsByTagName()</h4>\n<p><code>Element.getElementsByTagName()</code>方法返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有匹配指定标签名的子元素节点。该方法与<code>document.getElementsByClassName()</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，该方法的参数是大小写不敏感的，因为 HTML 标签名也是大小写不敏感。</p>\n<h4> Element.closest()</h4>\n<p><code>Element.closest</code>方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回<code>null</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，由于<code>closest</code>方法将当前节点也考虑在内，所以第二个<code>closest</code>方法返回<code>div-03</code>。</p>\n<h4> Element.matches()</h4>\n<p><code>Element.matches</code>方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 事件相关方法</h4>\n<p>以下三个方法与<code>Element</code>节点的事件相关。这些方法都继承自<code>EventTarget</code>接口，详见相关章节。</p>\n<ul>\n<li><code>Element.addEventListener()</code>：添加事件的回调函数</li>\n<li><code>Element.removeEventListener()</code>：移除事件监听函数</li>\n<li><code>Element.dispatchEvent()</code>：触发事件</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Element.scrollIntoView()</h4>\n<p><code>Element.scrollIntoView</code>方法滚动当前元素，进入浏览器的可见区域，类似于设置<code>window.location.hash</code>的效果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法可以接受一个布尔值作为参数。如果为<code>true</code>，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为<code>false</code>，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为<code>true</code>。</p>\n<h4> Element.getBoundingClientRect()</h4>\n<p><code>Element.getBoundingClientRect</code>方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>getBoundingClientRect</code>方法返回的<code>rect</code>对象，具有以下属性（全部为只读）。</p>\n<ul>\n<li><code>x</code>：元素左上角相对于视口的横坐标</li>\n<li><code>y</code>：元素左上角相对于视口的纵坐标</li>\n<li><code>height</code>：元素高度</li>\n<li><code>width</code>：元素宽度</li>\n<li><code>left</code>：元素左上角相对于视口的横坐标，与<code>x</code>属性相等</li>\n<li><code>right</code>：元素右边界相对于视口的横坐标（等于<code>x + width</code>）</li>\n<li><code>top</code>：元素顶部相对于视口的纵坐标，与<code>y</code>属性相等</li>\n<li><code>bottom</code>：元素底部相对于视口的纵坐标（等于<code>y + height</code>）</li>\n</ul>\n<p>由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将<code>left</code>属性加上<code>window.scrollX</code>，<code>top</code>属性加上<code>window.scrollY</code>。</p>\n<p>注意，<code>getBoundingClientRect</code>方法的所有属性，都把边框（<code>border</code>属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，<code>width</code>和<code>height</code>包括了元素本身 + <code>padding</code> + <code>border</code>。</p>\n<p>另外，上面的这些属性，都是继承自原型的属性，<code>Object.keys</code>会返回一个空数组，这一点也需要注意。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>rect</code>对象没有自身属性，而<code>Object.keys</code>方法只返回对象自身的属性，所以返回了一个空数组。</p>\n<h4> Element.getClientRects()</h4>\n<p><code>Element.getClientRects</code>方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形（所以方法名中的<code>Rect</code>用的是复数）。每个矩形都有<code>bottom</code>、<code>height</code>、<code>left</code>、<code>right</code>、<code>top</code>和<code>width</code>六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p>\n<p>对于盒状元素（比如<code>&lt;div&gt;</code>和<code>&lt;p&gt;</code>），该方法返回的对象中只有该元素一个成员。对于行内元素（比如<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;em&gt;</code>），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和<code>Element.getBoundingClientRect()</code>方法的主要区别，后者对于行内元素总是返回一个矩形。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码是一个行内元素<code>&lt;span&gt;</code>，如果它在页面上占据三行，<code>getClientRects</code>方法返回的对象就有三个成员，如果它在页面上占据一行，<code>getClientRects</code>方法返回的对象就只有一个成员。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移。</p>\n<p>注意，如果行内元素包括换行符，那么该方法会把换行符考虑在内。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>&lt;span&gt;</code>节点内部有三个换行符，即使 HTML 语言忽略换行符，将它们显示为一行，<code>getClientRects()</code>方法依然会返回三个成员。如果行宽设置得特别窄，上面的<code>&lt;span&gt;</code>元素显示为6行，那么就会返回六个成员。</p>\n<h4> Element.insertAdjacentElement()</h4>\n<p><code>Element.insertAdjacentElement</code>方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Element.insertAdjacentElement</code>方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点。第一个参数只可以取如下的值。</p>\n<ul>\n<li><code>beforebegin</code>：当前元素之前</li>\n<li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li>\n<li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li>\n<li><code>afterend</code>：当前元素之后</li>\n</ul>\n<p>注意，<code>beforebegin</code>和<code>afterend</code>这两个值，只在当前节点有父节点时才会生效。如果当前节点是由脚本创建的，没有父节点，那么插入会失败。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>p1</code>没有父节点，所以插入<code>p2</code>到它后面就失败了。</p>\n<p>如果插入的节点是一个文档里现有的节点，它会从原有位置删除，放置到新的位置。</p>\n<h4> Element.insertAdjacentHTML()，Element.insertAdjacentText()</h4>\n<p><code>Element.insertAdjacentHTML</code>方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。第一个参数只能设置下面四个值之一。</p>\n<ul>\n<li><code>beforebegin</code>：当前元素之前</li>\n<li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li>\n<li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li>\n<li><code>afterend</code>：当前元素之后</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法只是在现有的 DOM 结构里面插入节点，这使得它的执行速度比<code>innerHTML</code>方法快得多。</p>\n<p>注意，该方法不会转义 HTML 字符串，这导致它不能用来插入用户输入的内容，否则会有安全风险。</p>\n<p><code>Element.insertAdjacentText</code>方法在相对于当前节点的指定位置，插入一个文本节点，用法与<code>Element.insertAdjacentHTML</code>方法完全一致。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Element.remove()</h4>\n<p><code>Element.remove</code>方法继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将<code>el</code>节点从 DOM 树里面移除。</p>\n<h4> Element.focus()，Element.blur()</h4>\n<p><code>Element.focus</code>方法用于将当前页面的焦点，转移到指定元素上。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法可以接受一个对象作为参数。参数对象的<code>preventScroll</code>属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码会让<code>btn</code>元素获得焦点，并滚动到可见区域。</p>\n<p>最后，从<code>document.activeElement</code>属性可以得到当前获得焦点的元素。</p>\n<p><code>Element.blur</code>方法用于将焦点从当前元素移除。</p>\n<h4> Element.click()</h4>\n<p><code>Element.click</code>方法用于在当前元素上模拟一次鼠标点击，相当于触发了<code>click</code>事件。</p>\n<h2> 属性的操作</h2>\n<h3> 属性的定义</h3>\n<p><strong>HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。</strong></p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码中，<code>a</code>元素包括两个属性：<code>id</code>属性和<code>href</code>属性。</p>\n<p>属性本身是一个对象（<code>Attr</code>对象），但是实际上，这个对象极少使用。一般都是通过元素节点对象（<code>HTMlElement</code>对象）来操作属性。本章介绍如何操作这些属性。</p>\n<h3> Element.attributes 属性</h3>\n<p><strong>元素对象有一个<code>attributes</code>属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。</strong></p>\n<p>其他类型的节点对象，虽然也有<code>attributes</code>属性，但返回的都是<code>null</code>，因此可以把这个属性视为元素对象独有的。</p>\n<p>单个属性可以通过序号引用，也可以通过属性名引用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>注意，上面代码的三种方法，返回的都是属性节点对象，而不是属性值。</strong></p>\n<p>属性节点对象有<code>name</code>和<code>value</code>属性，对应该属性的属性名和属性值，等同于<code>nodeName</code>属性和<code>nodeValue</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面代码可以遍历一个元素节点的所有属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 元素的标准属性</h3>\n<p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>a</code>元素标签的属性<code>id</code>和<code>href</code>，自动成为节点对象的属性。</p>\n<p>这些属性都是可写的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的写法，会立刻替换掉<code>img</code>对象的<code>src</code>属性，即会显示另外一张图片。</p>\n<p>这种修改属性的方法，常常用于添加表单的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码为表单添加提交网址和提交方法。</p>\n<p>注意，这种用法虽然可以读写属性，但是无法删除属性，<code>delete</code>运算符在这里不会生效。</p>\n<p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如<code>onClick</code>。</p>\n<p>有些 HTML 属性名是 JavaScript 的保留字，转为 JavaScript 属性时，必须改名。主要是以下两个。</p>\n<ul>\n<li><code>for</code>属性改为<code>htmlFor</code></li>\n<li><code>class</code>属性改为<code>className</code></li>\n</ul>\n<p>另外，HTML 属性值一般都是字符串，但是 JavaScript 属性会自动转换类型。比如，将字符串<code>true</code>转为布尔值，将<code>onClick</code>的值转为一个函数，将<code>style</code>属性的值转为一个<code>CSSStyleDeclaration</code>对象。因此，可以对这些属性赋予各种类型的值。</p>\n<h3> 属性操作的标准方法</h3>\n<h4> 概述</h4>\n<p><strong>元素节点提供六个方法，用来操作属性：</strong></p>\n<ul>\n<li><code>getAttribute()</code></li>\n<li><code>getAttributeNames()</code></li>\n<li><code>setAttribute()</code></li>\n<li><code>hasAttribute()</code></li>\n<li><code>hasAttributes()</code></li>\n<li><code>removeAttribute()</code></li>\n</ul>\n<p>这有几点注意。</p>\n<p>（1）适用性</p>\n<p>这六个方法对所有属性（包括用户自定义的属性）都适用。</p>\n<p>（2）返回值</p>\n<p><code>getAttribute()</code>只返回字符串，不会返回其他类型的值。</p>\n<p>（3）属性名</p>\n<p>这些方法只接受属性的标准名称，不用改写保留字，比如<code>for</code>和<code>class</code>都可以直接使用。另外，这些方法对于属性名是大小写不敏感的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>setAttribute</code>方法直接使用<code>class</code>作为属性名，不用写成<code>className</code>。</p>\n<h4> Element.getAttribute()</h4>\n<p><code>Element.getAttribute</code>方法返回当前元素节点的指定属性。如果指定属性不存在，则返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Element.getAttributeNames()</h4>\n<p><strong><code>Element.getAttributeNames()</code>返回一个数组，成员是当前元素的所有属性的名字。如果当前元素没有任何属性，则返回一个空数组。</strong></p>\n<p><strong>使用<code>Element.attributes</code>属性，也可以拿到同样的结果，唯一的区别是它返回的是类似数组的对象。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码用于遍历某个节点的所有属性。</p>\n<h4> Element.setAttribute()</h4>\n<p><code>Element.setAttribute</code>方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。该方法没有返回值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>button</code>元素的<code>name</code>属性被设成<code>myButton</code>，<code>disabled</code>属性被设成<code>true</code>。</p>\n<p>这里有两个地方需要注意，首先，属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值<code>true</code>就会变成字符串<code>true</code>；其次，上例的<code>disable</code>属性是一个布尔属性，对于<code>&lt;button&gt;</code>元素来说，这个属性不需要属性值，只要设置了就总是会生效，因此<code>setAttribute</code>方法里面可以将<code>disabled</code>属性设成任意值。</p>\n<h4> Element.hasAttribute()</h4>\n<p><strong><code>Element.hasAttribute</code>方法返回一个布尔值，表示当前元素节点是否包含指定属性。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码检查<code>div</code>节点是否含有<code>align</code>属性。如果有，则设置为居中对齐。</p>\n<h4> Element.hasAttributes()</h4>\n<p><strong><code>Element.hasAttributes</code>方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回<code>false</code>，否则返回<code>true</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Element.removeAttribute()</h4>\n<p><code>Element.removeAttribute</code>方法移除指定属性。该方法没有返回值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> dataset 属性</h3>\n<p>有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是自定义属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码为<code>div</code>元素自定义了<code>foo</code>属性，然后可以用<code>getAttribute()</code>和<code>setAttribute()</code>读写这个属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种方法虽然可以达到目的，但是会使得 HTML 元素的属性不符合标准，导致网页代码通不过校验。</p>\n<p>更好的解决方法是，使用标准提供的<code>data-*</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>然后，使用元素节点对象的<code>dataset</code>属性，它指向一个对象，可以用来操作 HTML 元素标签的<code>data-*</code>属性。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，通过<code>dataset.foo</code>读写<code>data-foo</code>属性。</p>\n<p><strong>删除一个<code>data-*</code>属性，可以直接使用<code>delete</code>命令。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>除了<code>dataset</code>属性，也可以用<code>getAttribute('data-foo')</code>、<code>removeAttribute('data-foo')</code>、<code>setAttribute('data-foo')</code>、<code>hasAttribute('data-foo')</code>等方法操作<code>data-*</code>属性。</p>\n<p>注意，<code>data-</code>后面的属性名有限制，只能包含字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>)。而且，属性名不应该使用<code>A</code>到<code>Z</code>的大写字母，比如不能有<code>data-helloWorld</code>这样的属性名，而要写成<code>data-hello-world</code>。</p>\n<p>转成<code>dataset</code>的键名时，连词线后面如果跟着一个小写字母，那么连词线会被移除，该小写字母转为大写字母，其他字符不变。反过来，<code>dataset</code>的键名转成属性名时，所有大写字母都会被转成连词线+该字母的小写形式，其他字符不变。比如，<code>dataset.helloWorld</code>会转成<code>data-hello-world</code>。</p>\n<h2> Text 节点</h2>\n<h3> 概念</h3>\n<p>文本节点（<code>Text</code>）代表元素节点（<code>Element</code>）和属性节点（<code>Attribute</code>）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</p>\n<p>通常我们使用父节点的<code>firstChild</code>、<code>nextSibling</code>等属性获取文本节点，或者使用<code>Document</code>节点的<code>createTextNode</code>方法创造一个文本节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>浏览器原生提供一个<code>Text</code>构造函数。它返回一个文本节点实例。它的参数就是该文本节点的文本内容。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>注意，由于空格也是一个字符，所以哪怕只有一个空格，也会形成文本节点。比如，<code>&lt;p&gt; &lt;/p&gt;</code>包含一个空格，它的子节点就是一个文本节点。</strong></p>\n<p>文本节点除了继承<code>Node</code>接口，还继承了<code>CharacterData</code>接口。<code>Node</code>接口的属性和方法请参考《Node 接口》一节，这里不再重复介绍了，以下的属性和方法大部分来自<code>CharacterData</code>接口。</p>\n<h3> 属性</h3>\n<h4> data</h4>\n<p><code>data</code>属性等同于<code>nodeValue</code>属性，用来设置或读取文本节点的内容。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> wholeText</h3>\n<p><code>wholeText</code>属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，<code>wholeText</code>属性的返回值，与<code>data</code>属性和<code>textContent</code>属性相同。但是，某些特殊情况会有差异。</p>\n<p>举例来说，HTML 代码如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这时，文本节点的<code>wholeText</code>属性和<code>data</code>属性，返回值相同。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>但是，一旦移除<code>&lt;em&gt;</code>节点，<code>wholeText</code>属性与<code>data</code>属性就会有差异，因为这时其实<code>&lt;p&gt;</code>节点下面包含了两个毗邻的文本节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> length</h3>\n<p><code>length</code>属性返回当前文本节点的文本长度。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> nextElementSibling，previousElementSibling</h3>\n<p><strong><code>nextElementSibling</code>属性返回紧跟在当前文本节点后面的那个同级元素节点。如果取不到元素节点，则返回<code>null</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>previousElementSibling</code>属性返回当前文本节点前面最近的同级元素节点。如果取不到元素节点，则返回<code>null</code>。</strong></p>\n<h3> 方法</h3>\n<h4> appendData()，deleteData()，insertData()，replaceData()，subStringData()</h4>\n<p>以下5个方法都是编辑<code>Text</code>节点文本内容的方法。</p>\n<ul>\n<li><code>appendData()</code>：在<code>Text</code>节点尾部追加字符串。</li>\n<li><code>deleteData()</code>：删除<code>Text</code>节点内部的子字符串，第一个参数为子字符串开始位置，第二个参数为子字符串长度。</li>\n<li><code>insertData()</code>：在<code>Text</code>节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。</li>\n<li><code>replaceData()</code>：用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。</li>\n<li><code>subStringData()</code>：用于获取子字符串，第一个参数为子字符串在<code>Text</code>节点中的开始位置，第二个参数为子字符串长度。</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> remove()</h4>\n<p><code>remove</code>方法用于移除当前<code>Text</code>节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> splitText()</h4>\n<p><code>splitText</code>方法将<code>Text</code>节点一分为二，变成两个毗邻的<code>Text</code>节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错。</p>\n<p>分割后，该方法返回分割位置后方的字符串，而原<code>Text</code>节点变成只包含分割位置前方的字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>父元素节点的<code>normalize</code>方法可以将毗邻的两个<code>Text</code>节点合并。</p>\n<p>接上面的例子，文本节点的<code>splitText</code>方法将一个<code>Text</code>节点分割成两个，父元素的<code>normalize</code>方法可以实现逆操作，将它们合并。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><h2> DocumentFragment 节点</h2>\n<h3> 概述</h3>\n<p><code>DocumentFragment</code>节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，<code>parentNode</code>返回<code>null</code>，但是可以插入任意数量的子节点。它不属于当前文档，操作<code>DocumentFragment</code>节点，要比直接操作 DOM 树快得多。</p>\n<h3> 用法</h3>\n<p>它一般用于构建一个 DOM 结构，然后插入当前文档。</p>\n<p><strong><code>document.createDocumentFragment</code>方法，以及浏览器原生的<code>DocumentFragment</code>构造函数，可以创建一个空的<code>DocumentFragment</code>节点。</strong></p>\n<p>然后再使用其他 DOM 方法，向其添加子节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码创建了一个<code>DocumentFragment</code>节点，然后将一个<code>li</code>节点添加在它里面，最后将<code>DocumentFragment</code>节点移动到原文档。</p>\n<p><strong>注意，<code>DocumentFragment</code>节点本身不能被插入当前文档。当它作为<code>appendChild()</code>、<code>insertBefore()</code>、<code>replaceChild()</code>等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。</strong></p>\n<p>一旦<code>DocumentFragment</code>节点被添加进当前文档，它自身就变成了空节点（<code>textContent</code>属性为空字符串），可以被再次使用。如果想要保存<code>DocumentFragment</code>节点的内容，可以使用<code>cloneNode</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面这样添加<code>DocumentFragment</code>节点进入当前文档，不会清空<code>DocumentFragment</code>节点。</p>\n<p>下面是一个例子，使用<code>DocumentFragment</code>反转一个指定节点的所有子节点的顺序。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>DocumentFragment</code>节点对象没有自己的属性和方法，全部继承自<code>Node</code>节点和<code>ParentNode</code>接口。也就是说，<code>DocumentFragment</code>节点比<code>Node</code>节点多出以下四个属性。</strong></p>\n<ul>\n<li><strong><code>children</code>：返回一个动态的<code>HTMLCollection</code>集合对象，包括当前<code>DocumentFragment</code>对象的所有子元素节点。</strong></li>\n<li><strong><code>firstElementChild</code>：返回当前<code>DocumentFragment</code>对象的第一个子元素节点，如果没有则返回<code>null</code>。</strong></li>\n<li><strong><code>lastElementChild</code>：返回当前<code>DocumentFragment</code>对象的最后一个子元素节点，如果没有则返回<code>null</code>。</strong></li>\n<li><strong><code>childElementCount</code>：返回当前<code>DocumentFragment</code>对象的所有子元素数量。</strong></li>\n</ul>\n<h2> CSS 操作</h2>\n<h3> 概述</h3>\n<p>CSS 与 JavaScript 是两个有着明确分工的领域，前者负责页面的视觉效果，后者负责与用户的行为互动。但是，它们毕竟同属网页开发的前端，因此不可避免有着交叉和互相配合。本章介绍如何通过 JavaScript 操作 CSS。</p>\n<h3> HTML 元素的 style 属性</h3>\n<p>操作 CSS 样式最简单的方法，就是使用网页元素节点的<code>getAttribute()</code>方法、<code>setAttribute()</code>方法和<code>removeAttribute()</code>方法，直接读写或删除网页元素的<code>style</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码相当于下面的 HTML 代码。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>style</code>不仅可以使用字符串读写，它本身还是一个对象，部署了 CSSStyleDeclaration 接口（详见下面的介绍），可以直接读写个别属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> CSSStyleDeclaration 接口</h3>\n<h4> 获取</h4>\n<p><strong>CSSStyleDeclaration 接口用来操作元素的样式，三个地方部署了这个接口：</strong></p>\n<ul>\n<li><strong>元素节点的<code>style</code>属性（<code>Element.style</code>）</strong></li>\n<li><strong><code>CSSStyle</code>实例的<code>style</code>属性</strong></li>\n<li><strong><code>window.getComputedStyle()</code>的返回值</strong></li>\n</ul>\n<p>CSSStyleDeclaration 接口可以直接读写 CSS 的样式属性，不过，连词号需要变成骆驼拼写法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>style</code>属性的值是一个 CSSStyleDeclaration 实例。这个对象所包含的属性与 CSS 规则一一对应，但是名字需要改写，比如<code>background-color</code>写成<code>backgroundColor</code>。改写的规则是将横杠从 CSS 属性名中去除，然后将横杠后的第一个字母大写。如果 CSS 属性名是 JavaScript 保留字，则规则名之前需要加上字符串<code>css</code>，比如<code>float</code>写成<code>cssFloat</code>。</p>\n<p>注意，该对象的属性值都是字符串，设置时必须包括单位，但是不含规则结尾的分号。比如，<code>divStyle.width</code>不能写为<code>100</code>，而要写为<code>100px</code>。</p>\n<p><strong>另外，<code>Element.style</code>返回的只是行内样式，并不是该元素的全部样式。通过样式表设置的样式，或者从父元素继承的样式，无法通过这个属性得到。元素的全部样式要通过<code>window.getComputedStyle()</code>得到。</strong></p>\n<h4> CSSStyleDeclaration 实例属性</h4>\n<h5> CSSStyleDeclaration.cssText</h5>\n<p><code>CSSStyleDeclaration.cssText</code>属性用来读写当前规则的所有样式声明文本。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>cssText</code>的属性值不用改写 CSS 属性名。</p>\n<p>删除一个元素的所有行内样式，最简便的方法就是设置<code>cssText</code>为空字符串。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><h5> CSSStyleDeclaration.length</h5>\n<p><code>CSSStyleDeclaration.length</code>属性返回一个整数值，表示当前规则包含多少条样式声明。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>myDiv</code>元素的行内样式共包含3条样式规则。</p>\n<h5> CSSStyleDeclaration.parentRule</h5>\n<p><code>CSSStyleDeclaration.parentRule</code>属性返回当前规则所属的那个样式块（CSSRule 实例）。如果不存在所属的样式块，该属性返回<code>null</code>。</p>\n<p>该属性只读，且只在使用 CSSRule 接口时有意义。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> CSSStyleDeclaration 实例方法</h4>\n<h5> CSSStyleDeclaration.getPropertyPriority()</h5>\n<p><code>CSSStyleDeclaration.getPropertyPriority</code>方法接受 CSS 样式的属性名作为参数，返回一个字符串，表示有没有设置<code>important</code>优先级。如果有就返回<code>important</code>，否则返回空字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>margin</code>属性有<code>important</code>优先级，<code>color</code>属性没有。</p>\n<h5> CSSStyleDeclaration.getPropertyValue()</h5>\n<p><code>CSSStyleDeclaration.getPropertyValue</code>方法接受 CSS 样式属性名作为参数，返回一个字符串，表示该属性的属性值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h5> CSSStyleDeclaration.item()</h5>\n<p><code>CSSStyleDeclaration.item</code>方法接受一个整数值作为参数，返回该位置的 CSS 属性名。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>0</code>号位置的 CSS 属性名是<code>color</code>，<code>1</code>号位置的 CSS 属性名是<code>background-color</code>。</p>\n<p>如果没有提供参数，这个方法会报错。如果参数值超过实际的属性数目，这个方法返回一个空字符值。</p>\n<h5> CSSStyleDeclaration.removeProperty()</h5>\n<p><code>CSSStyleDeclaration.removeProperty</code>方法接受一个属性名作为参数，在 CSS 规则里面移除这个属性，返回这个属性原来的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，删除<code>color</code>属性以后，字体颜色从红色变成默认颜色。</p>\n<h5> CSSStyleDeclaration.setProperty()</h5>\n<p><code>CSSStyleDeclaration.setProperty</code>方法用来设置新的 CSS 属性。该方法没有返回值。</p>\n<p>该方法可以接受三个参数。</p>\n<ul>\n<li>第一个参数：属性名，该参数是必需的。</li>\n<li>第二个参数：属性值，该参数可选。如果省略，则参数值默认为空字符串。</li>\n<li>第三个参数：优先级，该参数可选。如果设置，唯一的合法值是<code>important</code>，表示 CSS 规则里面的<code>!important</code>。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码执行后，<code>myDiv</code>元素就会出现蓝色的边框。</p>\n<h3> CSS 模块的侦测</h3>\n<p>CSS 的规格发展太快，新的模块层出不穷。不同浏览器的不同版本，对 CSS 模块的支持情况都不一样。有时候，需要知道当前浏览器是否支持某个模块，这就叫做“CSS模块的侦测”。</p>\n<p>一个比较普遍适用的方法是，判断元素的<code>style</code>对象的某个属性值是否为字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果该 CSS 属性确实存在，会返回一个字符串。即使该属性实际上并未设置，也会返回一个空字符串。如果该属性不存在，则会返回<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码说明，这个浏览器支持<code>max-width</code>属性，但是不支持<code>maximum-width</code>属性。</p>\n<p>注意，不管 CSS 属性名的写法带不带连词线，<code>style</code>属性上都能反映出该属性是否存在。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另外，使用的时候，需要把不同浏览器的 CSS 前缀也考虑进去。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种侦测方法可以写成一个函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> CSS 对象</h3>\n<p>浏览器原生提供 CSS 对象，为 JavaScript 操作 CSS 提供一些工具方法。</p>\n<p>这个对象目前有两个静态方法。</p>\n<h4> CSS.escape()</h4>\n<p><code>CSS.escape</code>方法用于转义 CSS 选择器里面的特殊字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，该元素的<code>id</code>属性包含一个<code>#</code>号，该字符在 CSS 选择器里面有特殊含义。不能直接写成<code>document.querySelector('#foo#bar')</code>，只能写成<code>document.querySelector('#foo\\\\#bar')</code>。这里必须使用双斜杠的原因是，单引号字符串本身会转义一次斜杠。</p>\n<p><code>CSS.escape</code>方法就用来转义那些特殊字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> CSS.supports()</h4>\n<p><code>CSS.supports</code>方法返回一个布尔值，表示当前环境是否支持某一句 CSS 规则。</p>\n<p>它的参数有两种写法，一种是第一个参数是属性名，第二个参数是属性值；另一种是整个参数就是一行完整的 CSS 语句。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，第二种写法的参数结尾不能带有分号，否则结果不准确。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> window.getComputedStyle()</h3>\n<p>行内样式（inline style）具有最高的优先级，改变行内样式，通常会立即反映出来。但是，网页元素最终的样式是综合各种规则计算出来的。因此，如果想得到元素实际的样式，只读取行内样式是不够的，需要得到浏览器最终计算出来的样式规则。</p>\n<p><code>window.getComputedStyle</code>方法，就用来返回浏览器计算后得到的最终规则。它接受一个节点对象作为参数，返回一个 CSSStyleDeclaration 实例，包含了指定节点的最终样式信息。所谓“最终样式信息”，指的是各种 CSS 规则叠加后的结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，得到的背景色就是<code>div</code>元素真正的背景色。</p>\n<p>注意，CSSStyleDeclaration 实例是一个活的对象，任何对于样式的修改，会实时反映到这个实例上面。另外，这个实例是只读的。</p>\n<p><code>getComputedStyle</code>方法还可以接受第二个参数，表示当前元素的伪元素（比如<code>:before</code>、<code>:after</code>、<code>:first-line</code>、<code>:first-letter</code>等）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面的例子是如何获取元素的高度。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码得到的<code>height</code>属性，是浏览器最终渲染出来的高度，比其他方法得到的高度更可靠。由于<code>styleObj</code>是 CSSStyleDeclaration 实例，所以可以使用各种 CSSStyleDeclaration 的实例属性和方法。</p>\n<p>有几点需要注意。</p>\n<ul>\n<li>CSSStyleDeclaration 实例返回的 CSS 值都是绝对单位。比如，长度都是像素单位（返回值包括<code>px</code>后缀），颜色是<code>rgb(#, #, #)</code>或<code>rgba(#, #, #, #)</code>格式。</li>\n<li>CSS 规则的简写形式无效。比如，想读取<code>margin</code>属性的值，不能直接读，只能读<code>marginLeft</code>、<code>marginTop</code>等属性；再比如，<code>font</code>属性也是不能直接读的，只能读<code>font-size</code>等单个属性。</li>\n<li>如果读取 CSS 原始的属性名，要用方括号运算符，比如<code>styleObj['z-index']</code>；如果读取骆驼拼写法的 CSS 属性名，可以直接读取<code>styleObj.zIndex</code>。</li>\n<li>该方法返回的 CSSStyleDeclaration 实例的<code>cssText</code>属性无效，返回<code>undefined</code>。</li>\n</ul>\n<h3> CSS 伪元素</h3>\n<p>CSS 伪元素是通过 CSS 向 DOM 添加的元素，主要是通过<code>:before</code>和<code>:after</code>选择器生成，然后用<code>content</code>属性指定伪元素的内容。</p>\n<p>下面是一段 HTML 代码。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>CSS 添加伪元素<code>:before</code>的写法如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>节点元素的<code>style</code>对象无法读写伪元素的样式，这时就要用到<code>window.getComputedStyle()</code>。JavaScript 获取伪元素，可以使用下面的方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>此外，也可以使用 CSSStyleDeclaration 实例的<code>getPropertyValue</code>方法，获取伪元素的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> StyleSheet 接口</h3>\n<h4> 概述</h4>\n<p><code>StyleSheet</code>接口代表网页的一张样式表，包括<code>&lt;link&gt;</code>元素加载的样式表和<code>&lt;style&gt;</code>元素内嵌的样式表。</p>\n<p><code>document</code>对象的<code>styleSheets</code>属性，可以返回当前页面的所有<code>StyleSheet</code>实例（即所有样式表）。它是一个类似数组的对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果是<code>&lt;style&gt;</code>元素嵌入的样式表，还有另一种获取<code>StyleSheet</code>实例的方法，就是这个节点元素的<code>sheet</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>严格地说，<code>StyleSheet</code>接口不仅包括网页样式表，还包括 XML 文档的样式表。所以，它有一个子类<code>CSSStyleSheet</code>表示网页的 CSS 样式表。我们在网页里面拿到的样式表实例，实际上是<code>CSSStyleSheet</code>的实例。这个子接口继承了<code>StyleSheet</code>的所有属性和方法，并且定义了几个自己的属性，下面把这两个接口放在一起介绍。</p>\n<h4> 实例属性</h4>\n<p><code>StyleSheet</code>实例有以下属性。</p>\n<p><strong>（1）StyleSheet.disabled</strong></p>\n<p><code>StyleSheet.disabled</code>返回一个布尔值，表示该样式表是否处于禁用状态。手动设置<code>disabled</code>属性为<code>true</code>，等同于在<code>&lt;link&gt;</code>元素里面，将这张样式表设为<code>alternate stylesheet</code>，即该样式表将不会生效。</p>\n<p>注意，<code>disabled</code>属性只能在 JavaScript 脚本中设置，不能在 HTML 语句中设置。</p>\n<p><strong>（2）Stylesheet.href</strong></p>\n<p><code>Stylesheet.href</code>返回样式表的网址。对于内嵌样式表，该属性返回<code>null</code>。该属性只读。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（3）StyleSheet.media</strong></p>\n<p><code>StyleSheet.media</code>属性返回一个类似数组的对象（<code>MediaList</code>实例），成员是表示适用媒介的字符串。表示当前样式表是用于屏幕（screen），还是用于打印（print）或手持设备（handheld），或各种媒介都适用（all）。该属性只读，默认值是<code>screen</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>MediaList</code>实例的<code>appendMedium</code>方法，用于增加媒介；<code>deleteMedium</code>方法用于删除媒介。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（4）StyleSheet.title</strong></p>\n<p><code>StyleSheet.title</code>属性返回样式表的<code>title</code>属性。</p>\n<p><strong>（5）StyleSheet.type</strong></p>\n<p><code>StyleSheet.type</code>属性返回样式表的<code>type</code>属性，通常是<code>text/css</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（6）StyleSheet.parentStyleSheet</strong></p>\n<p>CSS 的<code>@import</code>命令允许在样式表中加载其他样式表。<code>StyleSheet.parentStyleSheet</code>属性返回包含了当前样式表的那张样式表。如果当前样式表是顶层样式表，则该属性返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（7）StyleSheet.ownerNode</strong></p>\n<p><code>StyleSheet.ownerNode</code>属性返回<code>StyleSheet</code>对象所在的 DOM 节点，通常是<code>&lt;link&gt;</code>或<code>&lt;style&gt;</code>。对于那些由其他样式表引用的样式表，该属性为<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（8）CSSStyleSheet.cssRules</strong></p>\n<p><code>CSSStyleSheet.cssRules</code>属性指向一个类似数组的对象（<code>CSSRuleList</code>实例），里面每一个成员就是当前样式表的一条 CSS 规则。使用该规则的<code>cssText</code>属性，可以得到 CSS 规则对应的字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>每条 CSS 规则还有一个<code>style</code>属性，指向一个对象，用来读写具体的 CSS 命令。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（9）CSSStyleSheet.ownerRule</strong></p>\n<p>有些样式表是通过<code>@import</code>规则输入的，它的<code>ownerRule</code>属性会返回一个<code>CSSRule</code>实例，代表那行<code>@import</code>规则。如果当前样式表不是通过<code>@import</code>引入的，<code>ownerRule</code>属性返回<code>null</code>。</p>\n<h4> 实例方法</h4>\n<p><strong>（1）CSSStyleSheet.insertRule()</strong></p>\n<p><code>CSSStyleSheet.insertRule</code>方法用于在当前样式表的插入一个新的 CSS 规则。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法可以接受两个参数，第一个参数是表示 CSS 规则的字符串，这里只能有一条规则，否则会报错。第二个参数是该规则在样式表的插入位置（从0开始），该参数可选，默认为0（即默认插在样式表的头部）。注意，如果插入位置大于现有规则的数目，会报错。</p>\n<p>该方法的返回值是新插入规则的位置序号。</p>\n<p>注意，浏览器对脚本在样式表里面插入规则有很多<a href=\"https://drafts.csswg.org/cssom/#insert-a-css-rule\" target=\"_blank\" rel=\"noopener noreferrer\">限制</a>。所以，这个方法最好放在<code>try...catch</code>里使用。</p>\n<p><strong>（2）CSSStyleSheet.deleteRule()</strong></p>\n<p><code>CSSStyleSheet.deleteRule</code>方法用来在样式表里面移除一条规则，它的参数是该条规则在<code>cssRules</code>对象中的位置。该方法没有返回值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 实例：添加样式表</h3>\n<p>网页添加样式表有两种方式。一种是添加一张内置样式表，即在文档中添加一个<code>&lt;style&gt;</code>节点。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另一种是添加外部样式表，即在文档中添加一个<code>&lt;link&gt;</code>节点，然后将<code>href</code>属性指向外部样式表的 URL。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> CSSRuleList 接口</h3>\n<p>CSSRuleList 接口是一个类似数组的对象，表示一组 CSS 规则，成员都是 CSSRule 实例。</p>\n<p>获取 CSSRuleList 实例，一般是通过<code>StyleSheet.cssRules</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>CSSRuleList 实例里面，每一条规则（CSSRule 实例）可以通过<code>rules.item(index)</code>或者<code>rules[index]</code>拿到。CSS 规则的条数通过<code>rules.length</code>拿到。还是用上面的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，添加规则和删除规则不能在 CSSRuleList 实例操作，而要在它的父元素 StyleSheet 实例上，通过<code>StyleSheet.insertRule()</code>和<code>StyleSheet.deleteRule()</code>操作。</p>\n<h3> CSSRule 接口</h3>\n<h4> 概述</h4>\n<p>一条 CSS 规则包括两个部分：CSS 选择器和样式声明。下面就是一条典型的 CSS 规则。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>JavaScript 通过 CSSRule 接口操作 CSS 规则。一般通过 CSSRuleList 接口（<code>StyleSheet.cssRules</code>）获取 CSSRule 实例。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> CSSRule 实例的属性</h4>\n<p><strong>（1）CSSRule.cssText</strong></p>\n<p><code>CSSRule.cssText</code>属性返回当前规则的文本，还是使用上面的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果规则是加载（<code>@import</code>）其他样式表，<code>cssText</code>属性返回<code>@import 'url'</code>。</p>\n<p><strong>（2）CSSRule.parentStyleSheet</strong></p>\n<p><code>CSSRule.parentStyleSheet</code>属性返回当前规则所在的样式表对象（StyleSheet 实例），还是使用上面的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（3）CSSRule.parentRule</strong></p>\n<p><code>CSSRule.parentRule</code>属性返回包含当前规则的父规则，如果不存在父规则（即当前规则是顶层规则），则返回<code>null</code>。</p>\n<p>父规则最常见的情况是，当前规则包含在<code>@media</code>规则代码块之中。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>（4）CSSRule.type</strong></p>\n<p><code>CSSRule.type</code>属性返回一个整数值，表示当前规则的类型。</p>\n<p>最常见的类型有以下几种。</p>\n<ul>\n<li>1：普通样式规则（CSSStyleRule 实例）</li>\n<li>3：<code>@import</code>规则</li>\n<li>4：<code>@media</code>规则（CSSMediaRule 实例）</li>\n<li>5：<code>@font-face</code>规则</li>\n</ul>\n<h3> CSSStyleRule 接口</h3>\n<p>如果一条 CSS 规则是普通的样式规则（不含特殊的 CSS 命令），那么除了 CSSRule 接口，它还部署了 CSSStyleRule 接口。</p>\n<p>CSSStyleRule 接口有以下两个属性。</p>\n<p><strong>（1）CSSStyleRule.selectorText</strong></p>\n<p><code>CSSStyleRule.selectorText</code>属性返回当前规则的选择器。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>注意，这个属性是可写的。</p>\n<p><strong>（2）CSSStyleRule.style</strong></p>\n<p><code>CSSStyleRule.style</code>属性返回一个对象（CSSStyleDeclaration 实例），代表当前规则的样式声明，也就是选择器后面的大括号里面的部分。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>CSSStyleDeclaration 实例的<code>cssText</code>属性，可以返回所有样式声明，格式为字符串。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><h3> CSSMediaRule 接口</h3>\n<p>如果一条 CSS 规则是<code>@media</code>代码块，那么它除了 CSSRule 接口，还部署了 CSSMediaRule 接口。</p>\n<p>该接口主要提供<code>media</code>属性和<code>conditionText</code>属性。前者返回代表<code>@media</code>规则的一个对象（MediaList 实例），后者返回<code>@media</code>规则的生效条件。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> window.matchMedia()</h3>\n<h4> 基本用法</h4>\n<p><code>window.matchMedia</code>方法用来将 CSS 的<a href=\"https://developer.mozilla.org/en-US/docs/DOM/Using_media_queries_from_code\" target=\"_blank\" rel=\"noopener noreferrer\"><code>MediaQuery</code></a>条件语句，转换成一个 MediaQueryList 实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，变量<code>mdl</code>就是 mediaQueryList 的实例。</p>\n<p>注意，如果参数不是有效的<code>MediaQuery</code>条件语句，<code>window.matchMedia</code>不会报错，依然返回一个 MediaQueryList 实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> MediaQueryList 接口的实例属性</h4>\n<p>MediaQueryList 实例有三个属性。</p>\n<p><strong>（1）MediaQueryList.media</strong></p>\n<p><code>MediaQueryList.media</code>属性返回一个字符串，表示对应的 MediaQuery 条件语句。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）MediaQueryList.matches</strong></p>\n<p><code>MediaQueryList.matches</code>属性返回一个布尔值，表示当前页面是否符合指定的 MediaQuery 条件语句。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面的例子根据<code>mediaQuery</code>是否匹配当前环境，加载相应的 CSS 样式表。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>（3）MediaQueryList.onchange</strong></p>\n<p>如果 MediaQuery 条件语句的适配环境发生变化，会触发<code>change</code>事件。<code>MediaQueryList.onchange</code>属性用来指定<code>change</code>事件的监听函数。该函数的参数是<code>change</code>事件对象（MediaQueryListEvent 实例），该对象与 MediaQueryList 实例类似，也有<code>media</code>和<code>matches</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>change</code>事件发生后，存在两种可能。一种是显示宽度从600像素以上变为以下，另一种是从600像素以下变为以上，所以在监听函数内部要判断一下当前是哪一种情况。</p>\n<h4> MediaQueryList 接口的实例方法</h4>\n<p>MediaQueryList 实例有两个方法<code>MediaQueryList.addListener()</code>和<code>MediaQueryList.removeListener()</code>，用来为<code>change</code>事件添加或撤销监听函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，<code>MediaQueryList.removeListener()</code>方法不能撤销<code>MediaQueryList.onchange</code>属性指定的监听函数。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "22.DOM事件",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses22.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses22.html",
      "summary": "EventTarget 接口 概述 DOM 的事件操作（监听和触发），都定义在EventTarget接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、`AudioNode、AudioContext）也部署了这个接口。 该接口主要提供三个实例方法。 addEventListener：绑定事件的监...",
      "content_html": "<h1> DOM 事件</h1>\n<h2> EventTarget 接口</h2>\n<h3> 概述</h3>\n<p>DOM 的事件操作（监听和触发），都定义在<code>EventTarget</code>接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p>\n<p>该接口主要提供三个实例方法。</p>\n<ul>\n<li><code>addEventListener</code>：绑定事件的监听函数</li>\n<li><code>removeEventListener</code>：移除事件的监听函数</li>\n<li><code>dispatchEvent</code>：触发事件</li>\n</ul>\n<h3> EventTarget.addEventListener()</h3>\n<p><code>EventTarget.addEventListener()</code>用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法接受三个参数。</p>\n<ul>\n<li><code>type</code>：事件名称，大小写敏感。</li>\n<li><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</li>\n<li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为<code>false</code>（监听函数只在冒泡阶段被触发）。该参数可选。</li>\n</ul>\n<p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>button</code>节点的<code>addEventListener</code>方法绑定<code>click</code>事件的监听函数<code>hello</code>，该函数只在冒泡阶段触发。</p>\n<p>关于参数，有两个地方需要注意。</p>\n<p>首先，第二个参数除了监听函数，还可以是一个具有<code>handleEvent</code>方法的对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>addEventListener</code>方法的第二个参数，就是一个具有<code>handleEvent</code>方法的对象。</p>\n<p>其次，第三个参数除了布尔值<code>useCapture</code>，还可以是一个属性配置对象。该对象有以下属性。</p>\n<blockquote>\n<ul>\n<li><code>capture</code>：布尔值，表示该事件是否在<code>捕获阶段</code>触发监听函数。</li>\n<li><code>once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li>\n<li><code>passive</code>：布尔值，表示监听函数不会调用事件的<code>preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li>\n</ul>\n</blockquote>\n<p>如果希望事件监听函数只执行一次，可以打开属性配置对象的<code>once</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>addEventListener</code>方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用<code>removeEventListener</code>方法手动去除）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>执行上面代码，点击文档只会输出一行<code>Hello world</code>。</p>\n<p>如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码通过匿名函数，向监听函数<code>print</code>传递了一个参数。</p>\n<p>监听函数内部的<code>this</code>，指向当前事件所在的那个对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，监听函数内部的<code>this</code>指向事件所在的对象<code>para</code>。</p>\n<h3> EventTarget.removeEventListener()</h3>\n<p><code>EventTarget.removeEventListener</code>方法用来移除<code>addEventListener</code>方法添加的事件监听函数。该方法没有返回值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>removeEventListener</code>方法的参数，与<code>addEventListener</code>方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p>\n<p>注意，<code>removeEventListener</code>方法移除的监听函数，必须是<code>addEventListener</code>方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>removeEventListener</code>方法无效，因为监听函数不是同一个匿名函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>removeEventListener</code>方法也是无效的，因为第三个参数不一样。</p>\n<h3> EventTarget.dispatchEvent()</h3>\n<p><code>EventTarget.dispatchEvent</code>方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了<code>Event.preventDefault()</code>，则返回值为<code>false</code>，否则为<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>dispatchEvent</code>方法的参数是一个<code>Event</code>对象的实例（详见《Event 对象》章节）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码在当前节点触发了<code>click</code>事件。</p>\n<p>如果<code>dispatchEvent</code>方法的参数为空，或者不是一个有效的事件对象，将报错。</p>\n<p>下面代码根据<code>dispatchEvent</code>方法的返回值，判断事件是否被取消了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 事件模型</h2>\n<h3> 监听函数</h3>\n<p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>\n<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>\n<h4> HTML 的 on- 属性</h4>\n<p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码为<code>body</code>节点的<code>load</code>事件、<code>div</code>节点的<code>click</code>事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p>\n<p>元素的事件监听属性，都是<code>on</code>加上事件名，比如<code>onload</code>就是<code>on + load</code>，表示<code>load</code>事件的监听代码。</p>\n<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>一旦指定的事件发生，<code>on-</code>属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。</p>\n<p>使用这个方法指定的监听代码，只会在冒泡阶段触发。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码中，<code>&lt;button&gt;</code>是<code>&lt;div&gt;</code>的子元素。<code>&lt;button&gt;</code>的<code>click</code>事件，也会触发<code>&lt;div&gt;</code>的<code>click</code>事件。由于<code>on-</code>属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code>1</code>，再输出<code>2</code>，即事件从子元素开始冒泡到父元素。</p>\n<p>直接设置<code>on-</code>属性，与通过元素节点的<code>setAttribute</code>方法设置<code>on-</code>属性，效果是一样的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 元素节点的事件属性</h4>\n<p>元素节点对象的事件属性，同样可以指定监听函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p>\n<p>注意，这种方法与 HTML 的<code>on-</code>属性的差异是，它的值是函数名（<code>doSomething</code>），而不像后者，必须给出完整的监听代码（<code>doSomething()</code>）。</p>\n<h4> EventTarget.addEventListener()</h4>\n<p>所有 DOM 节点实例都有<code>addEventListener</code>方法，用来为该节点定义事件的监听函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>addEventListener</code>方法的详细介绍，参见<code>EventTarget</code>章节。</p>\n<h4> 小结</h4>\n<p>上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</p>\n<p>第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次<code>onclick</code>属性，后一次定义会覆盖前一次。因此，也不推荐使用。</p>\n<p>第三种<code>EventTarget.addEventListener</code>是推荐的指定监听函数的方法。它有如下优点：</p>\n<ul>\n<li>同一个事件可以添加多个监听函数。</li>\n<li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li>\n<li>除了 DOM 节点，其他对象（比如<code>window</code>、<code>XMLHttpRequest</code>等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li>\n</ul>\n<h3> this 的指向</h3>\n<p>监听函数内部的<code>this</code>指向触发事件的那个元素节点。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>执行上面代码，点击后会输出<code>btn</code>。</p>\n<p>其他两种监听函数的写法，<code>this</code>的指向也是如此。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面两种写法，点击按钮以后也是输出<code>btn</code>。</p>\n<h3> 事件的传播</h3>\n<p>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p>\n<ul>\n<li><strong>第一阶段</strong>：从<code>window</code>对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</li>\n<li><strong>第二阶段</strong>：在目标节点上触发，称为“目标阶段”（target phase）。</li>\n<li><strong>第三阶段</strong>：从目标节点传导回<code>window</code>对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</li>\n</ul>\n<p>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码中，<code>&lt;div&gt;</code>节点之中有一个<code>&lt;p&gt;</code>节点。</p>\n<p>如果对这两个节点，都设置<code>click</code>事件的监听函数（每个节点的捕获阶段和冒泡阶段，各设置一个监听函数），共计设置四个监听函数。然后，对<code>&lt;p&gt;</code>点击，<code>click</code>事件会触发四次。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码表示，<code>click</code>事件被触发了四次：<code>&lt;div&gt;</code>节点的捕获阶段和冒泡阶段各1次，<code>&lt;p&gt;</code>节点的目标阶段触发了2次。</p>\n<ol>\n<li>捕获阶段：事件从<code>&lt;div&gt;</code>向<code>&lt;p&gt;</code>传播时，触发<code>&lt;div&gt;</code>的<code>click</code>事件；</li>\n<li>目标阶段：事件从<code>&lt;div&gt;</code>到达<code>&lt;p&gt;</code>时，触发<code>&lt;p&gt;</code>的<code>click</code>事件；</li>\n<li>冒泡阶段：事件从<code>&lt;p&gt;</code>传回<code>&lt;div&gt;</code>时，再次触发<code>&lt;div&gt;</code>的<code>click</code>事件。</li>\n</ol>\n<p>其中，<code>&lt;p&gt;</code>节点有两个监听函数（<code>addEventListener</code>方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为<code>click</code>事件触发一次。所以，<code>&lt;p&gt;</code>会在<code>target</code>阶段有两次输出。</p>\n<p>注意，浏览器总是假定<code>click</code>事件的目标节点，就是点击位置嵌套最深的那个节点（本例是<code>&lt;div&gt;</code>节点里面的<code>&lt;p&gt;</code>节点）。所以，<code>&lt;p&gt;</code>节点的捕获阶段和冒泡阶段，都会显示为<code>target</code>阶段。</p>\n<p>事件传播的最上层对象是<code>window</code>，接着依次是<code>document</code>，<code>html</code>（<code>document.documentElement</code>）和<code>body</code>（<code>document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code>window</code>、<code>document</code>、<code>html</code>、<code>body</code>、<code>div</code>、<code>p</code>，在冒泡阶段依次为<code>p</code>、<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>window</code>。</p>\n<h3> 事件的代理</h3>\n<p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>click</code>事件的监听函数定义在<code>&lt;ul&gt;</code>节点，但是实际上，它处理的是子节点<code>&lt;li&gt;</code>的<code>click</code>事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个<code>&lt;li&gt;</code>节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p>\n<p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code>stopPropagation</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>stopPropagation</code>方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p>\n<p>但是，<code>stopPropagation</code>方法只会阻止事件的传播，不会阻止该事件触发<code>&lt;p&gt;</code>节点的其他<code>click</code>事件的监听函数。也就是说，不是彻底取消<code>click</code>事件。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>p</code>元素绑定了两个<code>click</code>事件的监听函数。<code>stopPropagation</code>方法只能阻止这个事件的传播，不能取消这个事件，因此，第二个监听函数会触发。输出结果会先是1，然后是2。</p>\n<p>如果想要彻底取消该事件，不再触发后面所有<code>click</code>的监听函数，可以使用<code>stopImmediatePropagation</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>stopImmediatePropagation</code>方法可以彻底取消这个事件，使得后面绑定的所有<code>click</code>监听函数都不再触发。所以，只会输出1，不会输出2。</p>\n<h2> Event 对象</h2>\n<h3> 概述</h3>\n<p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</p>\n<p><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Event</code>构造函数接受两个参数。第一个参数<code>type</code>是字符串，表示事件的名称；第二个参数<code>options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p>\n<ul>\n<li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象是否冒泡。</li>\n<li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件是否可以被取消，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码新建一个<code>look</code>事件实例，然后使用<code>dispatchEvent</code>方法触发该事件。</p>\n<p>注意，如果不是显式指定<code>bubbles</code>属性为<code>true</code>，生成的事件就只能在“捕获阶段”触发监听函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>p</code>元素发出一个<code>click</code>事件，该事件默认不会冒泡。<code>div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code>div.addEventListener('click', callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。</p>\n<p>另一方面，如果这个事件在<code>div</code>元素上触发。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>那么，不管<code>div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code>div</code>元素是事件的目标，不存在是否冒泡的问题，<code>div</code>元素总是会接收到事件，因此导致监听函数生效。</p>\n<h3> 实例属性</h3>\n<h4> Event.bubbles，Event.eventPhase</h4>\n<p><code>Event.bubbles</code>属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<code>Event</code>构造函数生成的事件，默认是不冒泡的。</p>\n<p><code>Event.eventPhase</code>属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Event.eventPhase</code>的返回值有四种可能。</p>\n<ul>\n<li>0，事件目前没有发生。</li>\n<li>1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</li>\n<li>2，事件到达目标节点，即<code>Event.target</code>属性指向的那个节点。</li>\n<li>3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</li>\n</ul>\n<h4> Event.cancelable，Event.cancelBubble，event.defaultPrevented</h4>\n<p><code>Event.cancelable</code>属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</p>\n<p>大多数浏览器的原生事件是可以取消的。比如，取消<code>click</code>事件，点击链接将无效。但是除非显式声明，<code>Event</code>构造函数生成的事件，默认是不可以取消的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>当<code>Event.cancelable</code>属性为<code>true</code>时，调用<code>Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</p>\n<p>如果事件不能取消，调用<code>Event.preventDefault()</code>会没有任何效果。所以使用这个方法之前，最好用<code>Event.cancelable</code>属性判断一下是否可以取消。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Event.cancelBubble</code>属性是一个布尔值，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以阻止事件的传播。</p>\n<p><code>Event.defaultPrevented</code>属性返回一个布尔值，表示该事件是否调用过<code>Event.preventDefault</code>方法。该属性只读。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Event.currentTarget，Event.target</h4>\n<p>事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意事件都有两个与事件相关的节点，一个是事件的原始触发节点（<code>Event.target</code>），另一个是事件当前正在通过的节点（<code>Event.currentTarget</code>）。前者通常是后者的后代节点。</p>\n<p><code>Event.currentTarget</code>属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。</p>\n<p><code>Event.target</code>属性返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</p>\n<p>事件传播过程中，不同节点的监听函数内部的<code>Event.target</code>与<code>Event.currentTarget</code>属性的值是不一样的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>&lt;em&gt;</code>是<code>&lt;p&gt;</code>的子节点，点击<code>&lt;em&gt;</code>或者点击<code>&lt;p&gt;</code>，都会导致监听函数执行。这时，<code>e.target</code>总是指向原始点击位置的那个节点，而<code>e.currentTarget</code>指向事件传播过程中正在经过的那个节点。由于监听函数只有事件经过时才会触发，所以<code>e.currentTarget</code>总是等同于监听函数内部的<code>this</code>。</p>\n<h4> Event.type</h4>\n<p><code>Event.type</code>属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候指定的。该属性只读。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Event.timeStamp</h4>\n<p><code>Event.timeStamp</code>属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p>\n<p>下面是一个计算鼠标移动速度的例子，显示每秒移动的像素数量。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> Event.isTrusted</h4>\n<p><code>Event.isTrusted</code>属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>evt</code>对象是脚本产生的，所以<code>isTrusted</code>属性返回<code>false</code>。</p>\n<h4> Event.detail</h4>\n<p><code>Event.detail</code>属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于<code>click</code>和<code>dblclick</code>事件，<code>Event.detail</code>是鼠标按下的次数（<code>1</code>表示单击，<code>2</code>表示双击，<code>3</code>表示三击）；对于鼠标滚轮事件，<code>Event.detail</code>是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 实例方法</h3>\n<h4> Event.preventDefault()</h4>\n<p><code>Event.preventDefault</code>方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的<code>cancelable</code>属性为<code>true</code>，如果为<code>false</code>，调用该方法没有任何效果。</p>\n<p>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用<code>stopPropagation()</code>或<code>stopImmediatePropagation()</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。</p>\n<p>利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码为文本框的<code>keypress</code>事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。</p>\n<h4> Event.stopPropagation()</h4>\n<p><code>stopPropagation</code>方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>click</code>事件将不会进一步冒泡到<code>el</code>节点的父节点。</p>\n<h4> Event.stopImmediatePropagation()</h4>\n<p><code>Event.stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比<code>Event.stopPropagation()</code>更彻底。</p>\n<p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code>Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码在<code>el</code>节点上，为<code>click</code>事件添加了两个监听函数<code>l1</code>和<code>l2</code>。由于<code>l1</code>调用了<code>event.stopImmediatePropagation</code>方法，所以<code>l2</code>不会被调用。</p>\n<h4> Event.composedPath()</h4>\n<p><code>Event.composedPath()</code>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>click</code>事件的最底层节点是<code>p</code>，向上依次是<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>Window</code>。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "23.BOM",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses23.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses23.html",
      "summary": "浏览器环境概述 代码嵌入网页的方法 网页中嵌入 JavaScript 代码，主要有四种方法： 元素直接嵌入代码。; 标签加载外部脚本; 事件属性; URL 协议; script 元素嵌入代码 元素内部可以直接写入 JavaScript 代码。 标签有一个type属性，用来指定脚本类型。对 JavaScript 脚本来说，type属性可以设为两种值。 t...",
      "content_html": "<h1> BOM</h1>\n<h2> 浏览器环境概述</h2>\n<h3> 代码嵌入网页的方法</h3>\n<p>网页中嵌入 JavaScript 代码，主要有四种方法：</p>\n<ul>\n<li><code>&lt;script&gt;</code>元素直接嵌入代码。</li>\n<li><code>&lt;script&gt;</code>标签加载外部脚本</li>\n<li>事件属性</li>\n<li>URL 协议</li>\n</ul>\n<h4> script 元素嵌入代码</h4>\n<p><code>&lt;script&gt;</code>元素内部可以直接写入 JavaScript 代码。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p><code>&lt;script&gt;</code>标签有一个type属性，用来指定脚本类型。对 JavaScript 脚本来说，type属性可以设为两种值。</p>\n<ul>\n<li><code>text/javascript</code>：这是默认值，也是历史上一贯设定的值。如果你省略<code>type</code>属性，默认就是这个值。对于老式浏览器，设为这个值比较好。</li>\n<li><code>application/javascript</code>：对于较新的浏览器，建议设为这个值。</li>\n</ul>\n<div class=\"language-html\" data-ext=\"html\"></div><p>由于<code>&lt;script&gt;</code>标签默认就是 JavaScript 代码。所以，嵌入 JavaScript 脚本时，<code>type</code>属性可以省略。</p>\n<p>如果<code>type</code>属性的值，浏览器不认识，那么它不会执行其中的代码。利用这一点，可以在<code>&lt;script&gt;</code>标签之中嵌入任意的文本内容，只要加上一个浏览器不认识的<code>type</code>属性即可。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面的代码，浏览器不会执行，也不会显示它的内容，因为不认识它的<code>type</code>属性。但是，这个<code>&lt;script&gt;</code>节点依然存在于 DOM 之中，可以使用<code>&lt;script&gt;</code>节点的<code>text</code>属性读出它的内容。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> script 元素加载外部脚本</h4>\n<p><code>&lt;script&gt;</code>标签也可以指定加载外部的脚本文件。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>如果脚本文件使用了非英语字符，还应该注明字符的编码。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>所加载的脚本必须是纯的 JavaScript 代码，不能有<code>HTML</code>代码和<code>&lt;script&gt;</code>标签。</p>\n<p>加载外部脚本和直接添加代码块，这两种方法不能混用。下面代码的<code>console.log</code>语句直接被忽略。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>为了防止攻击者篡改外部脚本，<code>script</code>标签允许设置一个<code>integrity</code>属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码中，<code>script</code>标签有一个<code>integrity</code>属性，指定了外部脚本<code>/assets/application.js</code>的 SHA256 签名。一旦有人改了这个脚本，导致 SHA256 签名不匹配，浏览器就会拒绝加载。</p>\n<h3> 事件属性</h3>\n<p>网页元素的事件属性（比如<code>onclick</code>和<code>onmouseover</code>），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面的事件属性代码只有一个语句。如果有多个语句，使用分号分隔即可。</p>\n<h3> URL 协议</h3>\n<p>URL 支持<code>javascript:</code>协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>浏览器的地址栏也可以执行<code>javascript:</code>协议。将<code>javascript:console.log('Hello')</code>放入地址栏，按回车键也会执行这段代码。</p>\n<p>如果 JavaScript 代码返回一个字符串，浏览器就会新建一个文档，展示这个字符串的内容，原有文档的内容都会消失。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码中，用户点击链接以后，会打开一个新文档，里面有当前时间。</p>\n<p>如果返回的不是字符串，那么浏览器不会新建文档，也不会跳转。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码中，用户点击链接后，网页不会跳转，只会在控制台显示当前时间。</p>\n<p><code>javascript:</code>协议的常见用途是书签脚本 Bookmarklet。由于浏览器的书签保存的是一个网址，所以<code>javascript:</code>网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本前加上<code>void</code>，或者在脚本最后加上<code>void 0</code>。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面这两种写法，点击链接后，执行代码都不会网页跳转。</p>\n<h3> script 元素</h3>\n<h4> 工作原理</h4>\n<p>浏览器加载 JavaScript 脚本，主要通过<code>&lt;script&gt;</code>元素完成。正常的网页加载流程是这样的。</p>\n<ol>\n<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>\n<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li>\n<li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>\n<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li>\n</ol>\n<p>加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。</p>\n<p>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。</p>\n<p>为了避免这种情况，较好的做法是将<code>&lt;script&gt;</code>标签都放在页面底部，而不是头部。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。</p>\n<p>脚本文件都放在网页尾部加载，还有一个好处。因为在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码执行时会报错，因为此时<code>document.body</code>元素还未生成。</p>\n<p>一种解决方法是设定<code>DOMContentLoaded</code>事件的回调函数。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，指定<code>DOMContentLoaded</code>事件发生后，才开始执行相关代码。<code>DOMContentLoaded</code>事件只有在 DOM 结构生成之后才会触发。</p>\n<p>另一种解决方法是，使用<code>&lt;script&gt;</code>标签的<code>onload</code>属性。当<code>&lt;script&gt;</code>标签指定的外部脚本文件下载和解析完成，会触发一个<code>load</code>事件，可以把所需执行的代码，放在这个事件的回调函数里面。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>但是，如果将脚本放在页面底部，就可以完全按照正常的方式写，上面两种方式都不需要。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>如果有多个<code>script</code>标签，比如下面这样。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>浏览器会同时并行下载<code>a.js</code>和<code>b.js</code>，但是，执行时会保证先执行<code>a.js</code>，然后再执行<code>b.js</code>，即使后者先下载完成，也是如此。也就是说，脚本的执行顺序由它们在页面中的出现顺序决定，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。</p>\n<p>解析和执行 CSS，也会产生阻塞。Firefox 浏览器会等到脚本前面的所有样式表，都下载并解析完，再执行脚本；Webkit则是一旦发现脚本引用了样式，就会暂停执行脚本，等到样式表下载并解析完，再恢复执行。</p>\n<p>此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载6～20个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。</p>\n<h4> defer 属性</h4>\n<p>为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对<code>&lt;script&gt;</code>元素加入<code>defer</code>属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码中，只有等到 DOM 加载完成后，才会执行<code>a.js</code>和<code>b.js</code>。</p>\n<p><code>defer</code>属性的运行流程如下。</p>\n<ol>\n<li>浏览器开始解析 HTML 网页。</li>\n<li>解析过程中，发现带有<code>defer</code>属性的<code>&lt;script&gt;</code>元素。</li>\n<li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>元素加载的外部脚本。</li>\n<li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li>\n</ol>\n<p>有了<code>defer</code>属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在<code>DOMContentLoaded</code>事件触发前执行（即刚刚读取完<code>&lt;/html&gt;</code>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p>\n<p>对于内置而不是加载外部脚本的<code>script</code>标签，以及动态生成的<code>script</code>标签，<code>defer</code>属性不起作用。另外，使用<code>defer</code>加载的外部脚本不应该使用<code>document.write</code>方法。</p>\n<h4> async 属性</h4>\n<p>解决“阻塞效应”的另一个方法是对<code>&lt;script&gt;</code>元素加入<code>async</code>属性。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p><code>async</code>属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p>\n<ol>\n<li>浏览器开始解析 HTML 网页。</li>\n<li>解析过程中，发现带有<code>async</code>属性的<code>script</code>标签。</li>\n<li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>标签中的外部脚本。</li>\n<li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li>\n<li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li>\n</ol>\n<p><code>async</code>属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。另外，使用<code>async</code>属性的脚本文件里面的代码，不应该使用<code>document.write</code>方法。</p>\n<p><code>defer</code>属性和<code>async</code>属性到底应该使用哪一个？</p>\n<p>一般来说，如果脚本之间没有依赖关系，就使用<code>async</code>属性，如果脚本之间有依赖关系，就使用<code>defer</code>属性。如果同时使用<code>async</code>和<code>defer</code>属性，后者不起作用，浏览器行为由<code>async</code>属性决定。</p>\n<h4> 脚本的动态加载</h4>\n<p><code>&lt;script&gt;</code>元素还可以动态生成，生成后再插入页面，从而实现脚本的动态加载。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种方法的好处是，动态生成的<code>script</code>标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。</p>\n<p>如果想避免这个问题，可以设置async属性为<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码不会阻塞页面渲染，而且可以保证<code>b.js</code>在<code>a.js</code>后面执行。不过需要注意的是，在这段代码后面加载的脚本文件，会因此都等待<code>b.js</code>执行完成后再执行。</p>\n<p>如果想为动态加载的脚本指定回调函数，可以使用下面的写法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 加载使用的协议</h4>\n<p>如果不指定协议，浏览器默认采用 HTTP 协议下载。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面的<code>example.js</code>默认就是采用 HTTP 协议下载，如果要采用 HTTPS 协议下载，必需写明。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><h3> 浏览器的组成</h3>\n<p>浏览器的核心是两部分：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）。</p>\n<h4> 渲染引擎</h4>\n<p>渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。</p>\n<p>不同的浏览器有不同的渲染引擎。</p>\n<ul>\n<li>Firefox：Gecko 引擎</li>\n<li>Safari：WebKit 引擎</li>\n<li>Chrome：Blink 引擎</li>\n<li>IE: Trident 引擎</li>\n<li>Edge: EdgeHTML 引擎</li>\n</ul>\n<p>渲染引擎处理网页，通常分成四个阶段。</p>\n<ol>\n<li>解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。</li>\n<li>对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。</li>\n<li>布局：计算出渲染树的布局（layout）。</li>\n<li>绘制：将渲染树绘制到屏幕。</li>\n</ol>\n<p>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。</p>\n<h4> 重流和重绘</h4>\n<p>渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p>\n<p>页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（<code>a:hover</code>）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。</p>\n<p>重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。</p>\n<p>大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。</p>\n<p>作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替；再比如，重绘<code>table</code>布局和<code>flex</code>布局，开销都会比较大。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码只会导致一次重绘，因为浏览器会累积 DOM 变动，然后一次性执行。</p>\n<p>下面是一些优化技巧：</p>\n<ul>\n<li>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。</li>\n<li>缓存 DOM 信息。</li>\n<li>不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。</li>\n<li>使用<code>documentFragment</code>操作 DOM</li>\n<li>动画使用<code>absolute</code>定位或<code>fixed</code>定位，这样可以减少对其他元素的影响。</li>\n<li>只在必要时才显示隐藏元素。</li>\n<li>使用<code>window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。</li>\n<li>使用虚拟 DOM（virtual DOM）库。</li>\n</ul>\n<p>下面是一个<code>window.requestAnimationFrame()</code>对比效果的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的第一段代码，每读一次 DOM，就写入新的值，会造成不停的重排和重流。第二段代码把所有的写操作，都累积在一起，从而 DOM 代码变动的代价就最小化了。</p>\n<h4> JavaScript 引擎</h4>\n<p>JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。</p>\n<p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</p>\n<p>为了提高运行速度，目前的浏览器都将 JavaScript 进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p>\n<p>早期，浏览器内部对 JavaScript 的处理过程如下：</p>\n<ol>\n<li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li>\n<li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li>\n<li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li>\n<li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li>\n</ol>\n<p>逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。</p>\n<p>字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。并非所有的 JavaScript 虚拟机运行时都有字节码，有的 JavaScript 虚拟机基于源码，即只要有可能，就通过 JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如 Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。下面是目前最常见的一些 JavaScript 虚拟机：</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Chakra_(JScript_engine)\" target=\"_blank\" rel=\"noopener noreferrer\">Chakra</a> (Microsoft Internet Explorer)</li>\n<li><a href=\"https://en.wikipedia.org/wiki/WebKit#JavaScriptCore\" target=\"_blank\" rel=\"noopener noreferrer\">Nitro/JavaScript Core</a> (Safari)</li>\n<li><a href=\"https://dev.opera.com/articles/view/labs-carakan/\" target=\"_blank\" rel=\"noopener noreferrer\">Carakan</a> (Opera)</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/SpiderMonkey\" target=\"_blank\" rel=\"noopener noreferrer\">SpiderMonkey</a> (Firefox)</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Chrome_V8\" target=\"_blank\" rel=\"noopener noreferrer\">V8</a> (Chrome, Chromium)</li>\n</ul>\n<h2> Window 对象</h2>\n<h3> 概述</h3>\n<p>浏览器里面，<code>window</code>对象（注意，<code>w</code>为小写）指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>a</code>是一个没有声明就直接赋值的变量，它自动成为顶层对象的属性。</p>\n<p><code>window</code>有自己的实体含义，其实不适合当作最高一层的顶层对象，这是一个语言的设计失误。最早，设计这门语言的时候，原始设想是语言内置的对象越少越好，这样可以提高浏览器的性能。因此，语言设计者 Brendan Eich 就把<code>window</code>对象当作顶层对象，所有未声明就赋值的变量都自动变成<code>window</code>对象的属性。这种设计使得编译阶段无法检测出未声明变量，但到了今天已经没有办法纠正了。</p>\n<h3> window 对象的属性</h3>\n<h4> window.name</h4>\n<p><code>window.name</code>属性是一个字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的<code>target</code>属性使用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该属性只能保存字符串，如果写入的值不是字符串，会自动转成字符串。各个浏览器对这个值的储存容量有所不同，但是一般来说，可以高达几MB。</p>\n<p>只要浏览器窗口不关闭，这个属性是不会消失的。举例来说，访问<code>a.com</code>时，该页面的脚本设置了<code>window.name</code>，接下来在同一个窗口里面载入了<code>b.com</code>，新页面的脚本可以读到上一个网页设置的<code>window.name</code>。页面刷新也是这种情况。一旦浏览器窗口关闭后，该属性保存的值就会消失，因为这时窗口已经不存在了。</p>\n<h4> window.closed，window.opener</h4>\n<p><code>window.closed</code>属性返回一个布尔值，表示窗口是否关闭。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码检查当前窗口是否关闭。这种检查意义不大，因为只要能运行代码，当前窗口肯定没有关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>window.opener</code>属性表示打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面表达式会打开一个新窗口，然后返回<code>true</code>。</p>\n<p>如果两个窗口之间不需要通信，建议将子窗口的<code>opener</code>属性显式设为<code>null</code>，这样可以减少一些安全隐患。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，子窗口的<code>opener</code>属性设为<code>null</code>，两个窗口之间就没办法再联系了。</p>\n<p>通过<code>opener</code>属性，可以获得父窗口的全局属性和方法，但只限于两个窗口同源的情况（参见《同源限制》一章），且其中一个窗口由另一个打开。<code>&lt;a&gt;</code>元素添加<code>rel=\"noopener\"</code>属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> window.self，window.window</h4>\n<p><code>window.self</code>和<code>window.window</code>属性都指向窗口本身。这两个属性只读。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> window.frames，window.length</h4>\n<p><code>window.frames</code>属性返回一个类似数组的对象，成员为页面内所有框架窗口，包括<code>frame</code>元素和<code>iframe</code>元素。<code>window.frames[0]</code>表示页面中第一个框架窗口。</p>\n<p>如果<code>iframe</code>元素设置了<code>id</code>或<code>name</code>属性，那么就可以用属性值，引用这个<code>iframe</code>窗口。比如<code>&lt;iframe name=\"myIFrame\"&gt;</code>可以用<code>frames['myIFrame']</code>或者<code>frames.myIFrame</code>来引用。</p>\n<p><code>frames</code>属性实际上是<code>window</code>对象的别名。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>因此，<code>frames[0]</code>也可以用<code>window[0]</code>表示。但是，从语义上看，<code>frames</code>更清晰，而且考虑到<code>window</code>还是全局对象，因此推荐表示多窗口时，总是使用<code>frames[0]</code>的写法。更多介绍请看下文的《多窗口操作》部分。</p>\n<p><code>window.length</code>属性返回当前网页包含的框架总数。如果当前网页不包含<code>frame</code>和<code>iframe</code>元素，那么<code>window.length</code>就返回<code>0</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，<code>window.frames.length</code>与<code>window.length</code>应该是相等的。</p>\n<h4> window.frameElement</h4>\n<p><code>window.frameElement</code>属性主要用于当前窗口嵌在另一个网页的情况（嵌入<code>&lt;object&gt;</code>、<code>&lt;iframe&gt;</code>或<code>&lt;embed&gt;</code>元素），返回当前窗口所在的那个元素节点。如果当前窗口是顶层窗口，或者所嵌入的那个网页不是同源的，该属性返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>frameEl</code>变量就是<code>&lt;iframe&gt;</code>元素。</p>\n<h4> window.top，window.parent</h4>\n<p><code>window.top</code>属性指向最顶层窗口，主要用于在框架窗口（frame）里面获取顶层窗口。</p>\n<p><code>window.parent</code>属性指向父窗口。如果当前窗口没有父窗口，<code>window.parent</code>指向自身。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>对于不包含框架的网页，这两个属性等同于<code>window</code>对象。</p>\n<h4> window.status</h4>\n<p><code>window.status</code>属性用于读写浏览器状态栏的文本。但是，现在很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。</p>\n<h4> window.devicePixelRatio</h4>\n<p><code>window.devicePixelRatio</code>属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。也就是说，它表示一个 CSS 像素由多少个物理像素组成。它可以用于判断用户的显示环境，如果这个比率较大，就表示用户正在使用高清屏幕，因此可以显示较大像素的图片。</p>\n<h4> 位置大小属性</h4>\n<p>以下属性返回<code>window</code>对象的位置信息和大小信息。</p>\n<p>**（1）window.screenX，window.screenY **</p>\n<p><code>window.screenX</code>和<code>window.screenY</code>属性，返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。</p>\n<p><strong>（2） window.innerHeight，window.innerWidth</strong></p>\n<p><code>window.innerHeight</code>和<code>window.innerWidth</code>属性，返回网页在当前窗口中可见部分的高度和宽度，即“视口”（viewport）的大小（单位像素）。这两个属性只读。</p>\n<p>用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是960像素），只是每个像素占据的屏幕空间变大了，因此可见部分（视口）就变小了。</p>\n<p>注意，这两个属性值包括滚动条的高度和宽度。</p>\n<p><strong>（3）window.outerHeight，window.outerWidth</strong></p>\n<p><code>window.outerHeight</code>和<code>window.outerWidth</code>属性返回浏览器窗口的高度和宽度，包括浏览器菜单和边框（单位像素）。这两个属性只读。</p>\n<p><strong>（4）window.scrollX，window.scrollY</strong></p>\n<p><code>window.scrollX</code>属性返回页面的水平滚动距离，<code>window.scrollY</code>属性返回页面的垂直滚动距离，单位都为像素。这两个属性只读。</p>\n<p>注意，这两个属性的返回值不是整数，而是双精度浮点数。如果页面没有滚动，它们的值就是<code>0</code>。</p>\n<p>举例来说，如果用户向下拉动了垂直滚动条75像素，那么<code>window.scrollY</code>就是75左右。用户水平向右拉动水平滚动条200像素，<code>window.scrollX</code>就是200左右。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果页面向下滚动的距离小于75像素，那么页面向下滚动75像素。</p>\n<p><strong>（5）window.pageXOffset，window.pageYOffset</strong></p>\n<p><code>window.pageXOffset</code>属性和<code>window.pageYOffset</code>属性，是<code>window.scrollX</code>和<code>window.scrollY</code>别名。</p>\n<h4> 组件属性</h4>\n<p>组件属性返回浏览器的组件对象。这样的属性有下面几个。</p>\n<ul>\n<li><code>window.locationbar</code>：地址栏对象</li>\n<li><code>window.menubar</code>：菜单栏对象</li>\n<li><code>window.scrollbars</code>：窗口的滚动条对象</li>\n<li><code>window.toolbar</code>：工具栏对象</li>\n<li><code>window.statusbar</code>：状态栏对象</li>\n<li><code>window.personalbar</code>：用户安装的个人工具栏对象</li>\n</ul>\n<p>这些对象的<code>visible</code>属性是一个布尔值，表示这些组件是否可见。这些属性只读。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 全局对象属性</h4>\n<p>全局对象属性指向一些浏览器原生的全局对象。</p>\n<ul>\n<li><code>window.document</code>：指向<code>document</code>对象，详见《document 对象》一章。注意，这个属性有同源限制。只有来自同源的脚本才能读取这个属性。</li>\n<li><code>window.location</code>：指向<code>Location</code>对象，用于获取当前窗口的 URL 信息。它等同于<code>document.location</code>属性，详见《Location 对象》一章。</li>\n<li><code>window.navigator</code>：指向<code>Navigator</code>对象，用于获取环境信息，详见《Navigator 对象》一章。</li>\n<li><code>window.history</code>：指向<code>History</code>对象，表示浏览器的浏览历史，详见《History 对象》一章。</li>\n<li><code>window.localStorage</code>：指向本地储存的 localStorage 数据，详见《Storage 接口》一章。</li>\n<li><code>window.sessionStorage</code>：指向本地储存的 sessionStorage 数据，详见《Storage 接口》一章。</li>\n<li><code>window.console</code>：指向<code>console</code>对象，用于操作控制台，详见《console 对象》一章。</li>\n<li><code>window.screen</code>：指向<code>Screen</code>对象，表示屏幕信息，详见《Screen 对象》一章。</li>\n</ul>\n<h4> window.isSecureContext</h4>\n<p><code>window.isSecureContext</code>属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是<code>true</code>，否则就是<code>false</code>。</p>\n<h3> window 对象的方法</h3>\n<h4> window.alert()，window.prompt()，window.confirm()</h4>\n<p><code>window.alert()</code>、<code>window.prompt()</code>、<code>window.confirm()</code>都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。注意，这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。</p>\n<p><strong>（1）window.alert()</strong></p>\n<p><code>window.alert()</code>方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>用户只有点击“确定”按钮，对话框才会消失。对话框弹出期间，浏览器窗口处于冻结状态，如果不点“确定”按钮，用户什么也干不了。</p>\n<p><code>window.alert()</code>方法的参数只能是字符串，没法使用 CSS 样式，但是可以用<code>\\n</code>指定换行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）window.prompt()</strong></p>\n<p><code>window.prompt()</code>方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码会跳出一个对话框，文字提示为“您的年龄？”，要求用户在对话框中输入自己的年龄（默认显示25）。用户填入的值，会作为返回值存入变量<code>result</code>。</p>\n<p><code>window.prompt()</code>的返回值有两种情况，可能是字符串（有可能是空字符串），也有可能是<code>null</code>。具体分成三种情况。</p>\n<ol>\n<li>用户输入信息，并点击“确定”，则用户输入的信息就是返回值。</li>\n<li>用户没有输入信息，直接点击“确定”，则输入框的默认值就是返回值。</li>\n<li>用户点击了“取消”（或者按了 ESC 按钮），则返回值是<code>null</code>。</li>\n</ol>\n<p><code>window.prompt()</code>方法的第二个参数是可选的，但是最好总是提供第二个参数，作为输入框的默认值。</p>\n<p><strong>（3）window.confirm()</strong></p>\n<p><code>window.confirm()</code>方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码弹出一个对话框，上面只有一行文字“你最近好吗？”，用户选择点击“确定”或“取消”。</p>\n<p><code>confirm</code>方法返回一个布尔值，如果用户点击“确定”，返回<code>true</code>；如果用户点击“取消”，则返回<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>confirm</code>的一个用途是，用户离开当前页面时，弹出一个对话框，问用户是否真的要离开。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这三个方法都具有堵塞效应，一旦弹出对话框，整个页面就是暂停执行，等待用户做出反应。</p>\n<h4> window.open(), window.close()，window.stop()</h4>\n<p><strong>（1）window.open()</strong></p>\n<p><code>window.open</code>方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用，如果无法新建窗口，则返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码会让浏览器弹出一个新建窗口，网址是当前域名下的<code>somefile.html</code>。</p>\n<p><code>open</code>方法一共可以接受三个参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><ul>\n<li><code>url</code>：字符串，表示新窗口的网址。如果省略，默认网址就是<code>about:blank</code>。</li>\n<li><code>windowName</code>：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用<code>_blank</code>，表示新建一个没有名字的窗口。另外还有几个预设值，<code>_self</code>表示当前窗口，<code>_top</code>表示顶层窗口，<code>_parent</code>表示上一层窗口。</li>\n<li><code>windowFeatures</code>：字符串，内容为逗号分隔的键值对（详见下文），表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。</li>\n</ul>\n<p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，打开的新窗口高度和宽度都为200像素，没有地址栏，但有状态栏和滚动条，允许用户调整大小。</p>\n<p>第三个参数可以设定如下属性。</p>\n<ul>\n<li>left：新窗口距离屏幕最左边的距离（单位像素）。注意，新窗口必须是可见的，不能设置在屏幕以外的位置。</li>\n<li>top：新窗口距离屏幕最顶部的距离（单位像素）。</li>\n<li>height：新窗口内容区域的高度（单位像素），不得小于100。</li>\n<li>width：新窗口内容区域的宽度（单位像素），不得小于100。</li>\n<li>outerHeight：整个浏览器窗口的高度（单位像素），不得小于100。</li>\n<li>outerWidth：整个浏览器窗口的宽度（单位像素），不得小于100。</li>\n<li>menubar：是否显示菜单栏。</li>\n<li>toolbar：是否显示工具栏。</li>\n<li>location：是否显示地址栏。</li>\n<li>personalbar：是否显示用户自己安装的工具栏。</li>\n<li>status：是否显示状态栏。</li>\n<li>dependent：是否依赖父窗口。如果依赖，那么父窗口最小化，该窗口也最小化；父窗口关闭，该窗口也关闭。</li>\n<li>minimizable：是否有最小化按钮，前提是<code>dialog=yes</code>。</li>\n<li>noopener：新窗口将与父窗口切断联系，即新窗口的<code>window.opener</code>属性返回<code>null</code>，父窗口的<code>window.open()</code>方法也返回<code>null</code>。</li>\n<li>resizable：新窗口是否可以调节大小。</li>\n<li>scrollbars：是否允许新窗口出现滚动条。</li>\n<li>dialog：新窗口标题栏是否出现最大化、最小化、恢复原始大小的控件。</li>\n<li>titlebar：新窗口是否显示标题栏。</li>\n<li>alwaysRaised：是否显示在所有窗口的顶部。</li>\n<li>alwaysLowered：是否显示在父窗口的底下。</li>\n<li>close：新窗口是否显示关闭按钮。</li>\n</ul>\n<p>对于那些可以打开和关闭的属性，设为<code>yes</code>或<code>1</code>或不设任何值就表示打开，比如<code>status=yes</code>、<code>status=1</code>、<code>status</code>都会得到同样的结果。如果想设为关闭，不用写<code>no</code>，而是直接省略这个属性即可。也就是说，如果在第三个参数中设置了一部分属性，其他没有被设置的<code>yes/no</code>属性都会被设成<code>no</code>，只有<code>titlebar</code>和关闭按钮除外（它们的值默认为<code>yes</code>）。</p>\n<p>上面这些属性，属性名与属性值之间用等号连接，属性与属性之间用逗号分隔。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另外，<code>open()</code>方法的第二个参数虽然可以指定已经存在的窗口，但是不等于可以任意控制其他窗口。为了防止被不相干的窗口控制，浏览器只有在两个窗口同源，或者目标窗口被当前网页打开的情况下，才允许<code>open</code>方法指向该窗口。</p>\n<p><code>window.open</code>方法返回新窗口的引用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，如果新窗口和父窗口不是同源的（即不在同一个域），它们彼此不能获取对方窗口对象的内部属性。</p>\n<p>下面是另一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码先打开一个新窗口，然后在该窗口弹出一个对话框，再将网址导向<code>example.com</code>。</p>\n<p>由于<code>open</code>这个方法很容易被滥用，许多浏览器默认都不允许脚本自动新建窗口。只允许在用户点击链接或按钮时，脚本做出反应，弹出新窗口。因此，有必要检查一下打开新窗口是否成功。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）window.close()</strong></p>\n<p><code>window.close</code>方法用于关闭当前窗口，一般只用来关闭<code>window.open</code>方法新建的窗口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法只对顶层窗口有效，<code>iframe</code>框架之中的窗口使用该方法无效。</p>\n<p><strong>（3）window.stop()</strong></p>\n<p><code>window.stop()</code>方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> window.moveTo()，window.moveBy()</h4>\n<p><code>window.moveTo()</code>方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将窗口移动到屏幕<code>(100, 200)</code>的位置。</p>\n<p><code>window.moveBy()</code>方法将窗口移动到一个相对位置。它接受两个参数，分别是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将窗口向右移动25像素、向下移动50像素。</p>\n<p>为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用<code>window.open()</code>方法新建的，并且窗口里只有它一个 Tab 页。除此以外的情况，使用上面两个方法都是无效的。</p>\n<h4> window.resizeTo()，window.resizeBy()</h4>\n<p><code>window.resizeTo()</code>方法用于缩放窗口到指定大小。</p>\n<p>它接受两个参数，第一个是缩放后的窗口宽度（<code>outerWidth</code>属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（<code>outerHeight</code>属性）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将当前窗口缩放到，屏幕可用区域的一半宽度和高度。</p>\n<p><code>window.resizeBy()</code>方法用于缩放窗口。它与<code>window.resizeTo()</code>的区别是，它按照相对的量缩放，<code>window.resizeTo()</code>需要给出缩放后的绝对大小。</p>\n<p>它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码将当前窗口的宽度和高度，都缩小200像素。</p>\n<h4> window.scrollTo()，window.scroll()，window.scrollBy()</h4>\n<p><code>window.scrollTo</code>方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>它也可以接受一个配置对象作为参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>配置对象<code>options</code>有三个属性。</p>\n<ul>\n<li><code>top</code>：滚动后页面左上角的垂直坐标，即 y 坐标。</li>\n<li><code>left</code>：滚动后页面左上角的水平坐标，即 x 坐标。</li>\n<li><code>behavior</code>：字符串，表示滚动的方式，有三个可能值（<code>smooth</code>、<code>instant</code>、<code>auto</code>），默认值为<code>auto</code>。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>window.scroll()</code>方法是<code>window.scrollTo()</code>方法的别名。</p>\n<p><code>window.scrollBy()</code>方法用于将网页滚动指定距离（单位像素）。它接受两个参数：水平向右滚动的像素，垂直向下滚动的像素。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码用于将网页向下滚动一屏。</p>\n<p>如果不是要滚动整个文档，而是要滚动某个元素，可以使用下面三个属性和方法。</p>\n<ul>\n<li>Element.scrollTop</li>\n<li>Element.scrollLeft</li>\n<li>Element.scrollIntoView()</li>\n</ul>\n<h4> window.print()</h4>\n<p><code>window.print</code>方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。</p>\n<p>常见的打印按钮代码如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>非桌面设备（比如手机）可能没有打印功能，这时可以这样判断。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> window.focus()，window.blur()</h4>\n<p><code>window.focus()</code>方法会激活窗口，使其获得焦点，出现在其他窗口的前面。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码先检查<code>popup</code>窗口是否依然存在，确认后激活该窗口。</p>\n<p><code>window.blur()</code>方法将焦点从窗口移除。</p>\n<p>当前窗口获得焦点时，会触发<code>focus</code>事件；当前窗口失去焦点时，会触发<code>blur</code>事件。</p>\n<h3> window.getSelection()</h3>\n<p><code>window.getSelection</code>方法返回一个<code>Selection</code>对象，表示用户现在选中的文本。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>使用<code>Selection</code>对象的<code>toString</code>方法可以得到选中的文本。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> window.getComputedStyle()，window.matchMedia()</h4>\n<p><code>window.getComputedStyle()</code>方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象，详见《CSS 操作》一章。</p>\n<p><code>window.matchMedia()</code>方法用来检查 CSS 的<code>mediaQuery</code>语句，详见《CSS 操作》一章。</p>\n<h4> window.requestAnimationFrame()</h4>\n<p><code>window.requestAnimationFrame()</code>方法跟<code>setTimeout</code>类似，都是推迟某个函数的执行。不同之处在于，<code>setTimeout</code>必须指定推迟的时间，<code>window.requestAnimationFrame()</code>则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，<code>requestAnimationFrame()</code>会暂停执行。</p>\n<p>如果某个函数会改变网页的布局，一般就放在<code>window.requestAnimationFrame()</code>里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。</p>\n<p>该方法接受一个回调函数作为参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>callback</code>是一个回调函数。<code>callback</code>执行时，它的参数就是系统传入的一个高精度时间戳（<code>performance.now()</code>的返回值），单位是毫秒，表示距离网页加载的时间。</p>\n<p><code>window.requestAnimationFrame()</code>的返回值是一个整数，这个整数可以传入<code>window.cancelAnimationFrame()</code>，用来取消回调函数的执行。</p>\n<p>下面是一个<code>window.requestAnimationFrame()</code>执行网页动画的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码定义了一个网页动画，持续时间是2秒，会让元素向右移动。</p>\n<h4> window.requestIdleCallback()</h4>\n<p><code>window.requestIdleCallback()</code>跟<code>setTimeout</code>类似，也是将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用<code>window.requestIdleCallback()</code>将其推迟执行，以保证网页性能。</p>\n<p>它跟<code>window.requestAnimationFrame()</code>的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在16毫秒之内完成；<code>window.requestIdleCallback()</code>可以保证回调函数在系统资源空闲时执行。</p>\n<p>该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空闲，都会执行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>callback</code>参数是一个回调函数。该回调函数执行时，系统会传入一个<code>IdleDeadline</code>对象作为参数。<code>IdleDeadline</code>对象有一个<code>didTimeout</code>属性（布尔值，表示是否为超时调用）和一个<code>timeRemaining()</code>方法（返回该空闲时段剩余的毫秒数）。</p>\n<p><code>options</code>参数是一个配置对象，目前只有<code>timeout</code>一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。</p>\n<p><code>window.requestIdleCallback()</code>方法返回一个整数。该整数可以传入<code>window.cancelIdleCallback()</code>取消回调函数。</p>\n<p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>requestIdleCallback()</code>用来执行非关键任务<code>myNonEssentialWork</code>。该任务先确认本次空闲时段有剩余时间，然后才真正开始执行任务。</p>\n<p>下面是指定<code>timeout</code>的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码指定，<code>processPendingAnalyticsEvents</code>必须在未来2秒之内执行。</p>\n<p>如果由于超时导致回调函数执行，则<code>deadline.timeRemaining()</code>返回<code>0</code>，<code>deadline.didTimeout</code>返回<code>true</code>。</p>\n<p>如果多次执行<code>window.requestIdleCallback()</code>，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。</p>\n<h3> 事件</h3>\n<p><code>window</code>对象可以接收以下事件。</p>\n<h4> load 事件和 onload 属性</h4>\n<p><code>load</code>事件发生在文档在浏览器窗口加载完毕时。<code>window.onload</code>属性可以指定这个事件的回调函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码在网页加载完毕后，获取指定元素并进行处理。</p>\n<h4> error 事件和 onerror 属性</h4>\n<p>浏览器脚本发生错误时，会触发<code>window</code>对象的<code>error</code>事件。我们可以通过<code>window.onerror</code>属性对该事件指定回调函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于历史原因，<code>window</code>的<code>error</code>事件的回调函数不接受错误对象作为参数，而是一共可以接受五个参数，它们的含义依次如下。</p>\n<ul>\n<li>出错信息</li>\n<li>出错脚本的网址</li>\n<li>行号</li>\n<li>列号</li>\n<li>错误对象</li>\n</ul>\n<p>老式浏览器只支持前三个参数。</p>\n<p>并不是所有的错误，都会触发 JavaScript 的<code>error</code>事件（即让 JavaScript 报错）。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。</p>\n<p>下面是一个例子，如果整个页面未捕获错误超过3个，就显示警告。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>需要注意的是，如果脚本网址与网页网址不在同一个域（比如使用了 CDN），浏览器根本不会提供详细的出错信息，只会提示出错，错误类型是“Script error.”，行号为0，其他信息都没有。这是浏览器防止向外部脚本泄漏信息。一个解决方法是在脚本所在的服务器，设置<code>Access-Control-Allow-Origin</code>的 HTTP 头信息。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>然后，在网页的<code>&lt;script&gt;</code>标签中设置<code>crossorigin</code>属性。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>上面代码的<code>crossorigin=\"anonymous\"</code>表示，读取文件不需要身份信息，即不需要 cookie 和 HTTP 认证信息。如果设为<code>crossorigin=\"use-credentials\"</code>，就表示浏览器会上传 cookie 和 HTTP 认证信息，同时还需要服务器端打开 HTTP 头信息<code>Access-Control-Allow-Credentials</code>。</p>\n<h4> window 对象的事件监听属性</h4>\n<p>除了具备元素节点都有的 GlobalEventHandlers 接口，<code>window</code>对象还具有以下的事件监听函数属性。</p>\n<ul>\n<li><code>window.onafterprint</code>：<code>afterprint</code>事件的监听函数。</li>\n<li><code>window.onbeforeprint</code>：<code>beforeprint</code>事件的监听函数。</li>\n<li><code>window.onbeforeunload</code>：<code>beforeunload</code>事件的监听函数。</li>\n<li><code>window.onhashchange</code>：<code>hashchange</code>事件的监听函数。</li>\n<li><code>window.onlanguagechange</code>: <code>languagechange</code>的监听函数。</li>\n<li><code>window.onmessage</code>：<code>message</code>事件的监听函数。</li>\n<li><code>window.onmessageerror</code>：<code>MessageError</code>事件的监听函数。</li>\n<li><code>window.onoffline</code>：<code>offline</code>事件的监听函数。</li>\n<li><code>window.ononline</code>：<code>online</code>事件的监听函数。</li>\n<li><code>window.onpagehide</code>：<code>pagehide</code>事件的监听函数。</li>\n<li><code>window.onpageshow</code>：<code>pageshow</code>事件的监听函数。</li>\n<li><code>window.onpopstate</code>：<code>popstate</code>事件的监听函数。</li>\n<li><code>window.onstorage</code>：<code>storage</code>事件的监听函数。</li>\n<li><code>window.onunhandledrejection</code>：未处理的 Promise 对象的<code>reject</code>事件的监听函数。</li>\n<li><code>window.onunload</code>：<code>unload</code>事件的监听函数。</li>\n</ul>\n<h3> 多窗口操作</h3>\n<p>由于网页可以使用<code>iframe</code>元素，嵌入其他网页，因此一个网页之中会形成多个窗口。如果子窗口之中又嵌入别的网页，就会形成多级窗口。</p>\n<h4> 窗口的引用</h4>\n<p>各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。</p>\n<ul>\n<li><code>top</code>：顶层窗口，即最上层的那个窗口</li>\n<li><code>parent</code>：父窗口</li>\n<li><code>self</code>：当前窗口，即自身</li>\n</ul>\n<p>下面代码可以判断，当前窗口是否为顶层窗口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面的代码让父窗口的访问历史后退一次。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>与这些变量对应，浏览器还提供一些特殊的窗口名，供<code>window.open()</code>方法、<code>&lt;a&gt;</code>标签、<code>&lt;form&gt;</code>标签等引用。</p>\n<ul>\n<li><code>_top</code>：顶层窗口</li>\n<li><code>_parent</code>：父窗口</li>\n<li><code>_blank</code>：新窗口</li>\n</ul>\n<p>下面代码就表示在顶层窗口打开链接。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> iframe 元素</h4>\n<p>对于<code>iframe</code>嵌入的窗口，<code>document.getElementById</code>方法可以拿到该窗口的 DOM 节点，然后使用<code>contentWindow</code>属性获得<code>iframe</code>节点包含的<code>window</code>对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>frame.contentWindow</code>可以拿到子窗口的<code>window</code>对象。然后，在满足同源限制的情况下，可以读取子窗口内部的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>iframe 元素的contentDocument属性，可以拿到子窗口的document对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>iframe 元素遵守同源政策，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用window.postMessage方法。</p>\n<p>iframe 窗口内部，使用window.parent引用父窗口。如果当前页面没有父窗口，则window.parent属性返回自身。因此，可以通过window.parent是否等于window.self，判断当前窗口是否为iframe窗口。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>iframe 窗口的window对象，有一个frameElement属性，返回 iframe 在父窗口中的 DOM 节点。对于非嵌入的窗口，该属性等于null。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> window.frames 属性</h4>\n<p><code>window.frames</code>属性返回一个类似数组的对象，成员是所有子窗口的<code>window</code>对象。可以使用这个属性，实现窗口之间的互相引用。比如，<code>frames[0]</code>返回第一个子窗口，<code>frames[1].frames[2]</code>返回第二个子窗口内部的第三个子窗口，<code>parent.frames[1]</code>返回父窗口的第二个子窗口。</p>\n<p>注意，<code>window.frames</code>每个成员的值，是框架内的窗口（即框架的<code>window</code>对象），而不是<code>iframe</code>标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用<code>window.frames[0].document</code>的写法。</p>\n<p>另外，如果<code>&lt;iframe&gt;</code>元素设置了<code>name</code>或<code>id</code>属性，那么属性值会自动成为全局变量，并且可以通过<code>window.frames</code>属性引用，返回子窗口的<code>window</code>对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另外，<code>name</code>属性的值会自动成为子窗口的名称，可以用在<code>window.open</code>方法的第二个参数，或者<code>&lt;a&gt;</code>和<code>&lt;frame&gt;</code>标签的<code>target</code>属性。</p>\n<h2> Navigator 对象与 Screen 对象</h2>\n<h3> Navigator 对象的属性</h3>\n<h4> Navigator.userAgent</h4>\n<p><code>navigator.userAgent</code>属性返回浏览器的 User Agent 字符串，表示浏览器的厂商和版本信息。</p>\n<p>下面是 Chrome 浏览器的<code>userAgent</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>通过<code>userAgent</code>属性识别浏览器，不是一个好办法。因为必须考虑所有的情况（不同的浏览器，不同的版本），非常麻烦，而且用户可以改变这个字符串。这个字符串的格式并无统一规定，也无法保证未来的适用性，各种上网设备层出不穷，难以穷尽。所以，现在一般不再通过它识别浏览器了，而是使用“功能识别”方法，即逐一测试当前浏览器是否支持要用到的 JavaScript 功能。</p>\n<p>不过，通过<code>userAgent</code>可以大致准确地识别手机浏览器，方法就是测试是否包含<code>mobi</code>字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果想要识别所有移动设备的浏览器，可以测试更多的特征字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Navigator.plugins</h4>\n<p><code>Navigator.plugins</code>属性返回一个类似数组的对象，成员是 Plugin 实例对象，表示浏览器安装的插件，比如 Flash、ActiveX 等。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Navigator.platform</h4>\n<p><code>Navigator.platform</code>属性返回用户的操作系统信息，比如<code>MacIntel</code>、<code>Win32</code>、<code>Linux x86_64</code>等 。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Navigator.onLine</h4>\n<p><code>navigator.onLine</code>属性返回一个布尔值，表示用户当前在线还是离线（浏览器断线）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>有时，浏览器可以连接局域网，但是局域网不能连通外网。这时，有的浏览器的<code>onLine</code>属性会返回<code>true</code>，所以不能假定只要是<code>true</code>，用户就一定能访问互联网。不过，如果是<code>false</code>，可以断定用户一定离线。</p>\n<p>用户变成在线会触发<code>online</code>事件，变成离线会触发<code>offline</code>事件，可以通过<code>window.ononline</code>和<code>window.onoffline</code>指定这两个事件的回调函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Navigator.language，Navigator.languages</h4>\n<p><code>Navigator.language</code>属性返回一个字符串，表示浏览器的首选语言。该属性只读。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Navigator.languages</code>属性返回一个数组，表示用户可以接受的语言。<code>Navigator.language</code>总是这个数组的第一个成员。HTTP 请求头信息的<code>Accept-Language</code>字段，就来自这个数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果这个属性发生变化，就会在<code>window</code>对象上触发<code>languagechange</code>事件。</p>\n<h4> Navigator.geolocation</h4>\n<p><code>Navigator.geolocation</code>属性返回一个 Geolocation 对象，包含用户地理位置的信息。注意，该 API 只有在 HTTPS 协议下可用，否则调用下面方法时会报错。</p>\n<p>Geolocation 对象提供下面三个方法。</p>\n<ul>\n<li>Geolocation.getCurrentPosition()：得到用户的当前位置</li>\n<li>Geolocation.watchPosition()：监听用户位置变化</li>\n<li>Geolocation.clearWatch()：取消<code>watchPosition()</code>方法指定的监听函数</li>\n</ul>\n<p>注意，调用这三个方法时，浏览器会跳出一个对话框，要求用户给予授权。</p>\n<h4> Navigator.cookieEnabled</h4>\n<p><code>navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器的 Cookie 功能是否打开。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，这个属性反映的是浏览器总的特性，与是否储存某个具体的网站的 Cookie 无关。用户可以设置某个网站不得储存 Cookie，这时<code>cookieEnabled</code>返回的还是<code>true</code>。</p>\n<h3> Navigator 对象的方法</h3>\n<h4> Navigator.javaEnabled()</h4>\n<p><code>navigator.javaEnabled()</code>方法返回一个布尔值，表示浏览器是否能运行 Java Applet 小程序。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Navigator.sendBeacon()</h4>\n<p><code>Navigator.sendBeacon()</code>方法用于向服务器异步发送数据，详见《XMLHttpRequest 对象》一章。</p>\n<h3> Navigator 的实验性属性</h3>\n<p>Navigator 对象有一些实验性属性，在部分浏览器可用。</p>\n<h4> Navigator.deviceMemory</h4>\n<p><code>navigator.deviceMemory</code>属性返回当前计算机的内存数量（单位为 GB）。该属性只读，只在 HTTPS 环境下可用。</p>\n<p>它的返回值是一个近似值，四舍五入到最接近的2的幂，通常是 0.25、0.5、1、2、4、8。实际内存超过 8GB，也返回<code>8</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面示例中，只有当前内存大于 1GB，才加载大型的脚本。</p>\n<h4> Navigator.hardwareConcurrency</h4>\n<p><code>navigator.hardwareConcurrency</code>属性返回用户计算机上可用的逻辑处理器的数量。该属性只读。</p>\n<p>现代计算机的 CPU 有多个物理核心，每个物理核心有时支持一次运行多个线程。因此，四核 CPU 可以提供八个逻辑处理器核心。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面示例中，可用的逻辑处理器大于4，才会加载大型脚本。</p>\n<p>该属性通过用于创建 Web Worker，每个可用的逻辑处理器都创建一个 Worker。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面示例中，有多少个可用的逻辑处理器，就创建多少个 Web Worker。</p>\n<h4> Navigator.connection</h4>\n<p><code>navigator.connection</code>属性返回一个对象，包含当前网络连接的相关信息。</p>\n<ul>\n<li>downlink：有效带宽估计值（单位：兆比特/秒，Mbps），四舍五入到每秒 25KB 的最接近倍数。</li>\n<li>downlinkMax：当前连接的最大下行链路速度（单位：兆比特每秒，Mbps）。</li>\n<li>effectiveType：返回连接的等效类型，可能的值为<code>slow-2g</code>、<code>2g</code>、<code>3g</code>、<code>4g</code>。</li>\n<li>rtt：当前连接的估计有效往返时间，四舍五入到最接近的25毫秒的倍数。</li>\n<li>saveData：用户是否设置了浏览器的减少数据使用量选项（比如不加载图片），返回<code>true</code>或者<code>false</code>。</li>\n<li>type：当前连接的介质类型，可能的值为<code>bluetooth</code>、<code>cellular</code>、<code>ethernet</code>、<code>none</code>、<code>wifi</code>、<code>wimax</code>、<code>other</code>、<code>unknown</code>。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面示例中，如果网络连接是 4G，则加载大型脚本。</p>\n<h3> Screen 对象</h3>\n<p>Screen 对象表示当前窗口所在的屏幕，提供显示设备的信息。<code>window.screen</code>属性指向这个对象。</p>\n<p>该对象有下面的属性。</p>\n<ul>\n<li><code>Screen.height</code>：浏览器窗口所在的屏幕的高度（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。显示器的分辨率与浏览器设置无关，缩放网页并不会改变分辨率。</li>\n<li><code>Screen.width</code>：浏览器窗口所在的屏幕的宽度（单位像素）。</li>\n<li><code>Screen.availHeight</code>：浏览器窗口可用的屏幕高度（单位像素）。因为部分空间可能不可用，比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区，这个属性等于<code>height</code>减去那些被系统组件的高度。</li>\n<li><code>Screen.availWidth</code>：浏览器窗口可用的屏幕宽度（单位像素）。</li>\n<li><code>Screen.pixelDepth</code>：整数，表示屏幕的色彩位数，比如<code>24</code>表示屏幕提供24位色彩。</li>\n<li><code>Screen.colorDepth</code>：<code>Screen.pixelDepth</code>的别名。严格地说，colorDepth 表示应用程序的颜色深度，pixelDepth 表示屏幕的颜色深度，绝大多数情况下，它们都是同一件事。</li>\n<li><code>Screen.orientation</code>：返回一个对象，表示屏幕的方向。该对象的<code>type</code>属性是一个字符串，表示屏幕的具体方向，<code>landscape-primary</code>表示横放，<code>landscape-secondary</code>表示颠倒的横放，<code>portrait-primary</code>表示竖放，<code>portrait-secondary</code>表示颠倒的竖放。</li>\n</ul>\n<p>下面是<code>Screen.orientation</code>的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面的例子保证屏幕分辨率大于 1024 x 768。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是根据屏幕的宽度，将用户导向不同网页的代码。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> Cookie</h2>\n<h3> 概述</h3>\n<p>Cookie 是服务器保存在浏览器的一小段文本信息，一般大小不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。</p>\n<p>Cookie 主要保存状态信息，以下是一些主要用途。</p>\n<ul>\n<li>对话（session）管理：保存登录、购物车等需要记录的信息。</li>\n<li>个性化信息：保存用户的偏好，比如网页的字体大小、背景色等等。</li>\n<li>追踪用户：记录和分析用户行为。</li>\n</ul>\n<p>Cookie 不是一种理想的客户端储存机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端储存应该使用 Web storage API 和 IndexedDB。只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。</p>\n<p>每个 Cookie 都有以下几方面的元数据。</p>\n<ul>\n<li>Cookie 的名字</li>\n<li>Cookie 的值（真正的数据写在这里面）</li>\n<li>到期时间（超过这个时间会失效）</li>\n<li>所属域名（默认为当前域名）</li>\n<li>生效的路径（默认为当前网址）</li>\n</ul>\n<p>举例来说，用户访问网址<code>www.example.com</code>，服务器在浏览器写入一个 Cookie。这个 Cookie 的所属域名为<code>www.example.com</code>，生效路径为根路径<code>/</code>。如果 Cookie 的生效路径设为<code>/forums</code>，那么这个 Cookie 只有在访问<code>www.example.com/forums</code>及其子路径时才有效。以后，浏览器访问某个路径之前，就会找出对该域名和路径有效，并且还没有到期的 Cookie，一起发送给服务器。</p>\n<p>用户可以设置浏览器不接受 Cookie，也可以设置不向服务器发送 Cookie。<code>window.navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器是否打开 Cookie 功能。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>document.cookie</code>属性返回当前网页的 Cookie。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>不同浏览器对 Cookie 数量和大小的限制，是不一样的。一般来说，单个域名设置的 Cookie 不应超过30个，每个 Cookie 的大小不能超过4KB。超过限制以后，Cookie 将被忽略，不会被设置。</p>\n<p>浏览器的同源政策规定，两个网址只要域名相同，就可以共享 Cookie（参见《同源政策》一章）。注意，这里不要求协议相同。也就是说，<code>http://example.com</code>设置的 Cookie，可以被<code>https://example.com</code>读取。</p>\n<h3> Cookie 与 HTTP 协议</h3>\n<p>Cookie 由 HTTP 协议生成，也主要是供 HTTP 协议使用。</p>\n<h4> HTTP 回应：Cookie 的生成</h4>\n<p>服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个<code>Set-Cookie</code>字段。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码会在浏览器保存一个名为<code>foo</code>的 Cookie，它的值为<code>bar</code>。</p>\n<p>HTTP 回应可以包含多个<code>Set-Cookie</code>字段，即在浏览器生成多个 Cookie。下面是一个例子。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>除了 Cookie 的值，<code>Set-Cookie</code>字段还可以附加 Cookie 的属性。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面的几个属性的含义，将在后文解释。</p>\n<p>一个<code>Set-Cookie</code>字段里面，可以同时包括多个属性，没有次序的要求。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>下面是一个例子。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的<code>key</code>、<code>domain</code>、<code>path</code>和<code>secure</code>都匹配。举例来说，如果原始的 Cookie 是用如下的<code>Set-Cookie</code>设置的。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>改变上面这个 Cookie 的值，就必须使用同样的<code>Set-Cookie</code>。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>只要有一个属性不同，就会生成一个全新的 Cookie，而不是替换掉原来那个 Cookie。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面的命令设置了一个全新的同名 Cookie，但是<code>path</code>属性不一样。下一次访问<code>example.com/blog</code>的时候，浏览器将向服务器发送两个同名的 Cookie。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码的两个 Cookie 是同名的，匹配越精确的 Cookie 排在越前面。</p>\n<h4> HTTP 请求：Cookie 的发送</h4>\n<p>浏览器向服务器发送 HTTP 请求时，每个请求都会带上相应的 Cookie。也就是说，把服务器早前保存在浏览器的这段信息，再发回服务器。这时要使用 HTTP 头信息的<code>Cookie</code>字段。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码会向服务器发送名为<code>foo</code>的 Cookie，值为<code>bar</code>。</p>\n<p><code>Cookie</code>字段可以包含多个 Cookie，使用分号（<code>;</code>）分隔。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>下面是一个例子。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>服务器收到浏览器发来的 Cookie 时，有两点是无法知道的。</p>\n<ul>\n<li>Cookie 的各种属性，比如何时过期。</li>\n<li>哪个域名设置的 Cookie，到底是一级域名设的，还是某一个二级域名设的。</li>\n</ul>\n<h3> Cookie 的属性</h3>\n<h4> Expires，Max-Age</h4>\n<p><code>Expires</code>属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式，可以使用<code>Date.prototype.toUTCString()</code>进行格式转换。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>如果不设置该属性，或者设为<code>null</code>，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。</p>\n<p><code>Max-Age</code>属性指定从现在开始 Cookie 存在的秒数，比如<code>60 * 60 * 24 * 365</code>（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。</p>\n<p>如果同时指定了<code>Expires</code>和<code>Max-Age</code>，那么<code>Max-Age</code>的值将优先生效。</p>\n<p>如果<code>Set-Cookie</code>字段没有指定<code>Expires</code>或<code>Max-Age</code>属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。</p>\n<h4> Domain，Path</h4>\n<p><code>Domain</code>属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前域名，这时子域名将不会附带这个 Cookie。比如，<code>example.com</code>不设置 Cookie 的<code>domain</code>属性，那么<code>sub.example.com</code>将不会附带这个 Cookie。如果指定了<code>domain</code>属性，那么子域名也会附带这个 Cookie。如果服务器指定的域名不属于当前域名，浏览器会拒绝这个 Cookie。</p>\n<p><code>Path</code>属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，<code>Path</code>属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，<code>PATH</code>属性是<code>/</code>，那么请求<code>/docs</code>路径也会包含该 Cookie。当然，前提是域名必须一致。</p>\n<h4> Secure，HttpOnly</h4>\n<p><code>Secure</code>属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。另一方面，如果当前协议是 HTTP，浏览器会自动忽略服务器发来的<code>Secure</code>属性。该属性只是一个开关，不需要指定值。如果通信是 HTTPS 协议，该开关自动打开。</p>\n<p><code>HttpOnly</code>属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是<code>document.cookie</code>属性、<code>XMLHttpRequest</code>对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面是跨站点载入的一个恶意脚本的代码，能够将当前网页的 Cookie 发往第三方服务器。如果设置了一个 Cookie 的<code>HttpOnly</code>属性，上面代码就不会读到该 Cookie。</p>\n<h4> SameSite</h4>\n<p>Chrome 51 开始，浏览器的 Cookie 新增加了一个<code>SameSite</code>属性，用来防止 CSRF 攻击和用户追踪。</p>\n<p>Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。举例来说，用户登陆了银行网站<code>your-bank.com</code>，银行服务器发来了一个 Cookie。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>用户后来又访问了恶意网站<code>malicious.com</code>，上面有一个表单。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>用户一旦被诱骗发送这个表单，银行网站就会收到带有正确 Cookie 的请求。为了防止这种攻击，表单一般都带有一个随机 token，告诉服务器这是真实请求。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>这种第三方网站引导发出的 Cookie，就称为第三方 Cookie。它除了用于 CSRF 攻击，还可以用于用户追踪。比如，Facebook 在第三方网站插入一张看不见的图片。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>浏览器加载上面代码时，就会向 Facebook 发出带有 Cookie 的请求，从而 Facebook 就会知道你是谁，访问了什么网站。</p>\n<p>Cookie 的<code>SameSite</code>属性用来限制第三方 Cookie，从而减少安全风险。它可以设置三个值。</p>\n<blockquote>\n<ul>\n<li>Strict</li>\n<li>Lax</li>\n<li>None</li>\n</ul>\n</blockquote>\n<p><strong>（1）Strict</strong></p>\n<p><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p>\n<p><strong>（2）Lax</strong></p>\n<p><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。</p>\n<table>\n<thead>\n<tr>\n<th>请求类型</th>\n<th style=\"text-align:center\">示例</th>\n<th style=\"text-align:right\">正常情况</th>\n<th>Lax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>链接</td>\n<td style=\"text-align:center\"><code>&lt;a href=\"...\"&gt;&lt;/a&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td>发送 Cookie</td>\n</tr>\n<tr>\n<td>预加载</td>\n<td style=\"text-align:center\"><code>&lt;link rel=\"prerender\" href=\"...\"/&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td>发送 Cookie</td>\n</tr>\n<tr>\n<td>GET 表单</td>\n<td style=\"text-align:center\"><code>&lt;form method=\"GET\" action=\"...\"&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td>发送 Cookie</td>\n</tr>\n<tr>\n<td>POST 表单</td>\n<td style=\"text-align:center\"><code>&lt;form method=\"POST\" action=\"...\"&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td>不发送</td>\n</tr>\n<tr>\n<td>iframe</td>\n<td style=\"text-align:center\"><code>&lt;iframe src=\"...\"&gt;&lt;/iframe&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td>不发送</td>\n</tr>\n<tr>\n<td>AJAX</td>\n<td style=\"text-align:center\"><code>$.get(\"...\")</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td>不发送</td>\n</tr>\n<tr>\n<td>Image</td>\n<td style=\"text-align:center\"><code>&lt;img src=\"...\"&gt;</code></td>\n<td style=\"text-align:right\">发送 Cookie</td>\n<td>不发送</td>\n</tr>\n</tbody>\n</table>\n<p>设置了<code>Strict</code>或<code>Lax</code>以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。</p>\n<p><strong>（3）None</strong></p>\n<p>Chrome 计划将<code>Lax</code>变为默认设置。这时，网站可以选择显式关闭<code>SameSite</code>属性，将其设为<code>None</code>。不过，前提是必须同时设置<code>Secure</code>属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p>\n<p>下面的设置无效。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>下面的设置有效。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><h3> document.cookie</h3>\n<p><code>document.cookie</code>属性用于读写当前网页的 Cookie。</p>\n<p>读取的时候，它会返回当前网页的所有 Cookie，前提是该 Cookie 不能有<code>HTTPOnly</code>属性。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码从<code>document.cookie</code>一次性读出两个 Cookie，它们之间使用分号分隔。必须手动还原，才能取出每一个 Cookie 的值。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p><code>document.cookie</code>属性是可写的，可以通过它为当前网站添加 Cookie。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>写入的时候，Cookie 的值必须写成<code>key=value</code>的形式。注意，等号两边不能有空格。另外，写入 Cookie 的时候，必须对分号、逗号和空格进行转义（它们都不允许作为 Cookie 的值），这可以用<code>encodeURIComponent</code>方法达到。</p>\n<p>但是，<code>document.cookie</code>一次只能写入一个 Cookie，而且写入并不是覆盖，而是添加。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p><code>document.cookie</code>读写行为的差异（一次可以读出全部 Cookie，但是只能写入一个 Cookie），与 HTTP 协议的 Cookie 通信格式有关。浏览器向服务器发送 Cookie 的时候，<code>Cookie</code>字段是使用一行将所有 Cookie 全部发送；服务器向浏览器设置 Cookie 的时候，<code>Set-Cookie</code>字段是一行设置一个 Cookie。</p>\n<p>写入 Cookie 的时候，可以一起写入 Cookie 的属性。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，写入 Cookie 的时候，同时设置了<code>expires</code>属性。属性值的等号两边，也是不能有空格的。</p>\n<p>各个属性的写入注意点如下。</p>\n<ul>\n<li><code>path</code>属性必须为绝对路径，默认为当前路径。</li>\n<li><code>domain</code>属性值必须是当前发送 Cookie 的域名的一部分。比如，当前域名是<code>example.com</code>，就不能将其设为<code>foo.com</code>。该属性默认为当前的一级域名（不含二级域名）。</li>\n<li><code>max-age</code>属性的值为秒数。</li>\n<li><code>expires</code>属性的值为 UTC 格式，可以使用<code>Date.prototype.toUTCString()</code>进行日期格式转换。</li>\n</ul>\n<p><code>document.cookie</code>写入 Cookie 的例子如下。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>Cookie 的属性一旦设置完成，就没有办法读取这些属性的值。</p>\n<p>删除一个现存 Cookie 的唯一方法，是设置它的<code>expires</code>属性为一个过去的日期。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，名为<code>fontSize</code>的 Cookie 的值为空，过期时间设为1970年1月1月零点，就等同于删除了这个 Cookie。</p>\n<h2> 同源限制</h2>\n<h3> 概述</h3>\n<h4> 含义</h4>\n<p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>\n<p>最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”。所谓“同源”指的是“三个相同”。</p>\n<blockquote>\n<ul>\n<li>协议相同</li>\n<li>域名相同</li>\n<li>端口相同（这点可以忽略，详见下文）</li>\n</ul>\n</blockquote>\n<p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略），它的同源情况如下。</p>\n<ul>\n<li><code>http://www.example.com/dir2/other.html</code>：同源</li>\n<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>\n<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>\n<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>\n<li><code>https://www.example.com/dir/page.html</code>：不同源（协议不同）</li>\n</ul>\n<p>注意，标准规定端口不同的网址不是同源（比如8000端口和8001端口不是同源），但是浏览器没有遵守这条规定。实际上，同一个网域的不同端口，是可以互相读取 Cookie 的。</p>\n<h4> 目的</h4>\n<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>\n<p>设想这样一种情况：A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私就泄漏了。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>\n<p>由此可见，同源政策是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>\n<h4> 限制范围</h4>\n<p>随着互联网的发展，同源政策越来越严格。目前，如果非同源，共有三种行为受到限制。</p>\n<blockquote>\n<p>（1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。</p>\n<p>（2） 无法接触非同源网页的 DOM。</p>\n<p>（3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。</p>\n</blockquote>\n<p>另外，通过 JavaScript 脚本可以拿到其他窗口的<code>window</code>对象。如果是非同源的网页，目前允许一个窗口可以接触其他网页的<code>window</code>对象的九个属性和四个方法。</p>\n<ul>\n<li>window.closed</li>\n<li>window.frames</li>\n<li>window.length</li>\n<li>window.location</li>\n<li>window.opener</li>\n<li>window.parent</li>\n<li>window.self</li>\n<li>window.top</li>\n<li>window.window</li>\n<li>window.blur()</li>\n<li>window.close()</li>\n<li>window.focus()</li>\n<li>window.postMessage()</li>\n</ul>\n<p>上面的九个属性之中，只有<code>window.location</code>是可读写的，其他八个全部都是只读。而且，即使是<code>location</code>对象，非同源的情况下，也只允许调用<code>location.replace()</code>方法和写入<code>location.href</code>属性。</p>\n<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面介绍如何规避上面的限制。</p>\n<h3> Cookie</h3>\n<p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置<code>document.domain</code>共享 Cookie。</p>\n<p>举例来说，A 网页的网址是<code>http://w1.example.com/a.html</code>，B 网页的网址是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享 Cookie。因为浏览器通过<code>document.domain</code>属性来检查是否同源。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，A 和 B 两个网页都需要设置<code>document.domain</code>属性，才能达到同源的目的。因为设置<code>document.domain</code>的同时，会把端口重置为<code>null</code>，因此如果只设置一个网页的<code>document.domain</code>，会导致两个网址的端口不同，还是达不到同源的目的。</p>\n<p>现在，A 网页通过脚本设置一个 Cookie。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>B 网页就可以读到这个 Cookie。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexedDB 无法通过这种方法，规避同源政策，而要使用下文介绍 PostMessage API。</p>\n<p>另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如<code>.example.com</code>。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。</p>\n<h3> iframe 和多窗口通信</h3>\n<p><code>iframe</code>元素可以在当前网页之中，嵌入其他网页。每个<code>iframe</code>元素形成自己的窗口，即有自己的<code>window</code>对象。<code>iframe</code>窗口之中的脚本，可以获得父窗口和子窗口。但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。</p>\n<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面命令中，父窗口想获取子窗口的 DOM，因为跨域导致报错。</p>\n<p>反之亦然，子窗口获取主窗口的 DOM 也会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种情况不仅适用于<code>iframe</code>窗口，还适用于<code>window.open</code>方法打开的窗口，只要跨域，父窗口与子窗口之间就无法通信。</p>\n<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源政策，拿到 DOM。</p>\n<p>对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。</p>\n<blockquote>\n<ul>\n<li>片段识别符（fragment identifier）</li>\n<li>跨文档通信API（Cross-document messaging）</li>\n</ul>\n</blockquote>\n<h4> 片段识别符</h4>\n<p>片段标识符（fragment identifier）指的是，URL 的<code>#</code>号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>\n<p>父窗口可以把信息，写入子窗口的片段标识符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，父窗口把所要传递的信息，写入 iframe 窗口的片段标识符。</p>\n<p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>同样的，子窗口也可以改变父窗口的片段标识符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> window.postMessage()</h4>\n<p>上面的这种方法属于破解，HTML5 为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p>\n<p>这个 API 为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口<code>aaa.com</code>向子窗口<code>bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为<code>*</code>，表示不限制域名，向所有窗口发送。</p>\n<p>子窗口向父窗口发送消息的写法类似。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>message</code>事件的参数是事件对象<code>event</code>，提供以下三个属性。</p>\n<blockquote>\n<ul>\n<li><code>event.source</code>：发送消息的窗口</li>\n<li><code>event.origin</code>: 消息发向的网址</li>\n<li><code>event.data</code>: 消息内容</li>\n</ul>\n</blockquote>\n<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码有几个地方需要注意。首先，<code>receiveMessage</code>函数里面没有过滤信息的来源，任意网址发来的信息都会被处理。其次，<code>postMessage</code>方法中指定的目标窗口的网址是一个星号，表示该信息可以向任意网址发送。通常来说，这两种做法是不推荐的，因为不够安全，可能会被恶意利用。</p>\n<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> LocalStorage</h4>\n<p>通过<code>window.postMessage</code>，读写其他窗口的 LocalStorage 也成为了可能。</p>\n<p>下面是一个例子，主窗口写入 iframe 子窗口的<code>localStorage</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，子窗口将父窗口发来的消息，写入自己的 LocalStorage。</p>\n<p>父窗口发送消息的代码如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>加强版的子窗口接收消息的代码如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>加强版的父窗口发送消息代码如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> AJAX</h3>\n<p>同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。</p>\n<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>\n<blockquote>\n<ul>\n<li>JSONP</li>\n<li>WebSocket</li>\n<li>CORS</li>\n</ul>\n</blockquote>\n<h4> JSONP</h4>\n<p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单易用，没有兼容性问题，老式浏览器全部支持，服务端改造非常小。</p>\n<p>它的做法如下。</p>\n<p>第一步，网页添加一个<code>&lt;script&gt;</code>元素，向服务器请求一个脚本，这不受同源政策限制，可以跨域请求。</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>注意，请求的脚本网址有一个<code>callback</code>参数（<code>?callback=bar</code>），用来告诉服务器，客户端的回调函数名称（<code>bar</code>）。</p>\n<p>第二步，服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数名里面，作为字符串返回（<code>bar({...})</code>）。</p>\n<p>第三步，客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是<code>&lt;script&gt;</code>标签请求的脚本内容。这时，客户端只要定义了<code>bar()</code>函数，就能在该函数体内，拿到服务器返回的 JSON 数据。</p>\n<p>下面看一个实例。首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨域网址发出请求。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于 JSONP 是必需的。</p>\n<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>\n<h4> WebSocket</h4>\n<p>WebSocket 是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>\n<p>下面是一个例子，浏览器发出的 WebSocket 请求的头信息（摘自<a href=\"https://en.wikipedia.org/wiki/WebSocket\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a>）。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>\n<p>正是因为有了<code>Origin</code>这个字段，所以 WebSocket 才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> CORS</h4>\n<p>CORS 是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。相比 JSONP 只能发<code>GET</code>请求，CORS 允许任何类型的请求。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "24.编程风格",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses24.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses24.html",
      "summary": "概述 “编程风格”（programming style）指的是编写代码的样式规则。不同的程序员，往往有不同的编程风格。 有人说，编译器的规范叫做“语法规则”（grammar），这是程序员必须遵守的；而编译器忽略的部分，就叫“编程风格”（programming style），这是程序员可以自由选择的。这种说法不完全正确，程序员固然可以自由选择编程风格，但...",
      "content_html": "<h1> 编程风格</h1>\n<h2> 概述</h2>\n<p>“编程风格”（programming style）指的是编写代码的样式规则。不同的程序员，往往有不同的编程风格。</p>\n<p>有人说，编译器的规范叫做“语法规则”（grammar），这是程序员必须遵守的；而编译器忽略的部分，就叫“编程风格”（programming style），这是程序员可以自由选择的。这种说法不完全正确，程序员固然可以自由选择编程风格，但是好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。</p>\n<p>所以，编程风格的选择不应该基于个人爱好、熟悉程度、打字量等因素，而要考虑如何尽量使代码清晰易读、减少出错。你选择的，不是你喜欢的风格，而是一种能够清晰表达你的意图的风格。这一点，对于 JavaScript 这种语法自由度很高的语言尤其重要。</p>\n<p>必须牢记的一点是，如果你选定了一种“编程风格”，就应该坚持遵守，切忌多种风格混用。如果你加入他人的项目，就应该遵守现有的风格。</p>\n<h2> 缩进</h2>\n<p>行首的空格和 Tab 键，都可以产生代码缩进效果（indent）。</p>\n<p>Tab 键可以节省击键次数，但不同的文本编辑器对 Tab 的显示不尽相同，有的显示四个空格，有的显示两个空格，所以有人觉得，空格键可以使得显示效果更统一。</p>\n<p>无论你选择哪一种方法，都是可以接受的，要做的就是始终坚持这一种选择。不要一会使用 Tab 键，一会使用空格键。</p>\n<h2> 区块</h2>\n<p>如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的原意可能是下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是，实际效果却是下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>因此，建议总是使用大括号表示区块。</p>\n<p>另外，区块起首的大括号的位置，有许多不同的写法。最流行的有两种，一种是起首的大括号另起一行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一种是起首的大括号跟在关键字的后面。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>一般来说，这两种写法都可以接受。但是，JavaScript 要使用后一种，因为 JavaScript 会自动添加句末的分号，导致一些难以察觉的错误。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的代码的原意，是要返回一个对象，但实际上返回的是<code>undefined</code>，因为 JavaScript 自动在<code>return</code>语句后面添加了分号。为了避免这一类错误，需要写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>因此，表示区块起首的大括号，不要另起一行。</p>\n<h2> 圆括号</h2>\n<p>圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>建议可以用空格，区分这两种不同的括号。</p>\n<blockquote>\n<ol>\n<li>表示函数调用时，函数名与左括号之间没有空格。</li>\n<li>表示函数定义时，函数名与左括号之间没有空格。</li>\n<li>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。</li>\n</ol>\n</blockquote>\n<p>按照上面的规则，下面的写法都是不规范的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的最后一行是一个匿名函数，<code>function</code>是语法关键字，不是函数名，所以与左括号之间应该要有一个空格。</p>\n<h2> 行尾的分号</h2>\n<p>分号表示一条语句的结束。JavaScript 允许省略行尾的分号。事实上，确实有一些开发者行尾从来不写分号。但是，由于下面要讨论的原因，建议还是不要省略这个分号。</p>\n<h3> 不使用分号的情况</h3>\n<p>首先，以下三种情况，语法规定本来就不需要在结尾添加分号。</p>\n<p><strong>（1）for 和 while 循环</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>do...while</code>循环是有分号的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）分支语句：if，switch，try</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（3）函数的声明语句</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，函数表达式仍然要使用分号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>以上三种情况，如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句。</p>\n<h3> 分号的自动添加</h3>\n<p>除了上一节的三种情况，所有语句都应该使用分号。但是，如果没有使用分号，大多数情况下，JavaScript 会自动添加。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种语法特性被称为“分号的自动添加”（Automatic Semicolon Insertion，简称 ASI）。</p>\n<p>因此，有人提倡省略句尾的分号。麻烦的是，如果下一行的开始可以与本行的结尾连在一起解释，JavaScript 就不会自动添加分号。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码都会多行放在一起解释，不会每一行自动添加分号。这些例子还是比较容易看出来的，但是下面这个例子就不那么容易看出来了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是更多不会自动添加分号的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>只有下一行的开始与本行的结尾，无法放在一起解释，JavaScript 引擎才会自动添加分号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另外，如果一行的起首是“自增”（<code>++</code>）或“自减”（<code>--</code>）运算符，则它们的前面会自动添加分号。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码之所以会得到<code>1 2 0</code>的结果，原因是自增和自减运算符前，自动加上了分号。上面的代码实际上等同于下面的形式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果<code>continue</code>、<code>break</code>、<code>return</code>和<code>throw</code>这四个语句后面，直接跟换行符，则会自动添加分号。这意味着，如果<code>return</code>语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。</p>\n<p>不应该省略结尾的分号，还有一个原因。有些 JavaScript 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果。</p>\n<p>另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。</p>\n<h2> 全局变量</h2>\n<p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。</p>\n<p>因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如<code>UPPER_CASE</code>。</p>\n<h2> 变量声明</h2>\n<p>JavaScript 会自动将变量声明“提升”（hoist）到代码块（block）的头部。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这意味着，变量<code>x</code>是<code>if</code>代码块之前就存在了。为了避免可能出现的问题，最好把变量声明都放在代码块的头部。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面这样的写法，就容易看出存在一个全局的循环变量<code>i</code>。</p>\n<p>另外，所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。</p>\n<h2> with 语句</h2>\n<p><code>with</code>可以减少代码的书写，但是会造成混淆。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码，可以有四种运行结果：</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这四种结果都可能发生，取决于不同的变量是否有定义。因此，不要使用<code>with</code>语句。</p>\n<h2> 相等和严格相等</h2>\n<p>JavaScript 有两个表示相等的运算符：“相等”（<code>==</code>）和“严格相等”（<code>===</code>）。</p>\n<p>相等运算符会自动转换变量类型，造成很多意想不到的情况。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>因此，建议不要使用相等运算符（<code>==</code>），只使用严格相等运算符（<code>===</code>）。</p>\n<h2> 语句的合并</h2>\n<p>有些程序员追求简洁，喜欢合并不同目的的语句。比如，原来的语句是</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>他喜欢写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>虽然语句少了一行，但是可读性大打折扣，而且会造成误读，让别人误解这行代码的意思是下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>建议不要将不同目的的语句，合并成一行。</p>\n<h2> 自增和自减运算符</h2>\n<p>自增（<code>++</code>）和自减（<code>--</code>）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。事实上，所有的<code>++</code>运算符都可以用<code>+= 1</code>代替。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>改用<code>+= 1</code>，代码变得更清晰了。</p>\n<p>建议自增（<code>++</code>）和自减（<code>--</code>）运算符尽量使用<code>+=</code>和<code>-=</code>代替。</p>\n<h2> switch...case 结构</h2>\n<p><code>switch...case</code>结构要求，在每一个<code>case</code>的最后一行必须是<code>break</code>语句，否则会接着运行下一个<code>case</code>。这样不仅容易忘记，还会造成代码的冗长。</p>\n<p>而且，<code>switch...case</code>不使用大括号，不利于代码形式的统一。此外，这种结构类似于<code>goto</code>语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的代码建议改写成对象结构。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因此，建议<code>switch...case</code>结构可以用对象结构代替。</p>\n<h2> 块级作用域</h2>\n<p>从本节开始，将探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>\n<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href=\"https://github.com/airbnb/javascript\" target=\"_blank\" rel=\"noopener noreferrer\">Airbnb</a> 公司的 JavaScript 风格规范。</p>\n<h3> let 取代 var</h3>\n<p>ES6 提出了两个新的声明变量的命令：<code>let</code>和<code>const</code>。其中，<code>let</code>完全可以取代<code>var</code>，因为两者语义相同，而且<code>let</code>没有副作用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码如果用<code>var</code>替代<code>let</code>，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，<code>var</code>命令做不到这一点。</p>\n<p><code>var</code>命令存在变量提升效用，<code>let</code>命令没有这个问题。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码如果使用<code>var</code>替代<code>let</code>，<code>console.log</code>那一行就不会报错，而是会输出<code>undefined</code>，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。</p>\n<p>所以，建议不再使用<code>var</code>命令，而是使用<code>let</code>命令取代。</p>\n<h3> 全局常量和线程安全</h3>\n<p>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量。</p>\n<p><code>const</code>优于<code>let</code>有几个原因。一个是<code>const</code>可以提醒阅读程序的人，这个变量不应该改变；另一个是<code>const</code>比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对<code>const</code>进行优化，所以多使用<code>const</code>，有利于提高程序的运行效率，也就是说<code>let</code>和<code>const</code>的本质区别，其实是编译器内部的处理不同。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>const</code>声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。</p>\n<p>所有的函数都应该设置为常量。</p>\n<p>长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时<code>let</code>表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p>\n<h2> 字符串</h2>\n<p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 解构赋值</h2>\n<p>使用数组成员对变量赋值时，优先使用解构赋值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>函数的参数如果是对象的成员，优先使用解构赋值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 对象</h2>\n<p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，对象<code>obj</code>的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建<code>obj</code>的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。</p>\n<p>另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 数组</h2>\n<p>使用扩展运算符（...）拷贝数组。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用 Array.from 方法，将类似数组的对象转为数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 函数</h2>\n<p>立即执行函数可以写成箭头函数的形式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>箭头函数取代<code>Function.prototype.bind</code>，不应再用 self/_this/that 绑定 this。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</p>\n<p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用默认值语法设置函数参数的默认值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> Map 结构</h2>\n<p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要<code>key: value</code>的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Class</h2>\n<p>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用<code>extends</code>实现继承，因为这样更简单，不会有破坏<code>instanceof</code>运算的危险。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 模块</h2>\n<p>首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用<code>import</code>取代<code>require</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>使用<code>export</code>取代<code>module.exports</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果模块只有一个输出值，就使用<code>export default</code>，如果模块有多个输出值，就不使用<code>export default</code>，<code>export default</code>与普通的<code>export</code>不要同时使用。</p>\n<p>不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果模块默认输出一个函数，函数名的首字母应该小写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果模块默认输出一个对象，对象名的首字母应该大写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> ESLint 的使用</h2>\n<p>ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</p>\n<p>首先，在项目的根目录安装 ESLint。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>最后，在项目的根目录下新建一个<code>.eslintrc</code>文件，配置 ESLint。</p>\n<div class=\"language-json\" data-ext=\"json\"></div><p>现在就可以检查，当前项目的代码是否符合预设的规则。</p>\n<p><code>index.js</code>文件的代码如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>使用 ESLint 检查这个文件，就会报出错误。</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>上面代码说明，原文件有五个错误，其中两个是不应该使用<code>var</code>命令，而要使用<code>let</code>或<code>const</code>；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "25.正则表达式",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses25.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses25.html",
      "summary": "概述 正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。 新建正则表达式有两种方法。一种是...",
      "content_html": "<h1> 正则表达式</h1>\n<h2> 概述</h2>\n<p>正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。</p>\n<p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一种是使用<code>RegExp</code>构造函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面两种写法是等价的，都新建了一个内容为<code>xyz</code>的正则表达式对象。它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p>\n<p><code>RegExp</code>构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，正则表达式<code>/xyz/</code>有一个修饰符<code>i</code>。</p>\n<h2> RegExp 构造函数</h2>\n<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>ES6 改变了这种行为。如果<code>RegExp</code>构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，原有正则对象的修饰符是<code>ig</code>，它会被第二个参数<code>i</code>覆盖。</p>\n<h2> 实例属性</h2>\n<p>正则对象的实例属性分成两类。</p>\n<p>一类是修饰符相关，用于了解设置了什么修饰符。</p>\n<ul>\n<li><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符。</li>\n<li><code>RegExp.prototype.global</code>：返回一个布尔值，表示是否设置了<code>g</code>修饰符。</li>\n<li><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符。</li>\n<li><code>RegExp.prototype.flags</code>：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。</li>\n</ul>\n<p>上面四个属性都是只读的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一类是与修饰符无关的属性，主要是下面两个。</p>\n<ul>\n<li><code>RegExp.prototype.lastIndex</code>：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。</li>\n<li><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 实例方法</h2>\n<h3> RegExp.prototype.test()</h3>\n<p>正则实例对象的<code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码验证参数字符串之中是否包含<code>cat</code>，结果返回<code>true</code>。</p>\n<p>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是全局搜索，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是上一次匹配的后一个位置。</p>\n<p>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码指定从字符串的第五个位置开始搜索，这个位置为空，所以返回<code>false</code>。同时，<code>lastIndex</code>属性重置为<code>0</code>，所以第二次执行<code>r.test(s)</code>会返回<code>true</code>。</p>\n<p>注意，带有<code>g</code>修饰符时，正则表达式内部会记住上一次的<code>lastIndex</code>属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，由于正则表达式<code>r</code>是从上一次的<code>lastIndex</code>位置开始匹配，导致第二次执行<code>test</code>方法时出现预期以外的结果。</p>\n<p><code>lastIndex</code>属性只对同一个正则表达式有效，所以下面这样写是错误的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码会导致无限循环，因为<code>while</code>循环的每次匹配条件都是一个新的正则表达式，导致<code>lastIndex</code>属性总是等于0。</p>\n<p>如果正则模式是一个空字符串，则匹配所有字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> RegExp.prototype.exec()</h3>\n<p>正则实例对象的<code>exec()</code>方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，正则对象<code>r1</code>匹配成功，返回一个数组，成员是匹配结果；正则对象<code>r2</code>匹配失败，返回<code>null</code>。</p>\n<p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的<code>length</code>属性等于组匹配的数量再加1。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>exec()</code>方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。</p>\n<p><code>exec()</code>方法的返回数组还包含以下两个属性：</p>\n<ul>\n<li><code>input</code>：整个原字符串。</li>\n<li><code>index</code>：模式匹配成功的开始位置（从0开始计数）。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中的<code>index</code>属性等于1，是因为从原字符串的第二个位置开始匹配成功。</p>\n<p>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec()</code>方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码连续用了四次<code>exec()</code>方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回<code>null</code>，正则实例对象的<code>lastIndex</code>属性也重置为<code>0</code>，意味着第四次匹配将从头开始。</p>\n<p>利用<code>g</code>修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，只要<code>exec()</code>方法不返回<code>null</code>，就会一直循环下去，每次输出匹配的位置和匹配的文本。</p>\n<p>正则实例对象的<code>lastIndex</code>属性不仅可读，还可写。设置了<code>g</code>修饰符的时候，只要手动设置了<code>lastIndex</code>的值，就会从指定位置开始匹配。</p>\n<h2> 字符串的实例方法</h2>\n<h3> 概述</h3>\n<p>字符串的实例方法之中，有4种与正则表达式有关。</p>\n<ul>\n<li>\n<p><code>String.prototype.match()</code>：返回一个数组，成员是所有匹配的子字符串。</p>\n</li>\n<li>\n<p><code>String.prototype.search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</p>\n</li>\n<li>\n<p><code>String.prototype.replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串。</p>\n</li>\n<li>\n<p><code>String.prototype.split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</p>\n</li>\n</ul>\n<p>ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>\n<p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p>\n<ul>\n<li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li>\n<li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li>\n<li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li>\n<li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li>\n</ul>\n<h3> String.prototype.match()</h3>\n<p>字符串实例对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>从上面代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法非常类似：匹配成功返回一个数组，匹配失败返回<code>null</code>。</p>\n<p>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>设置正则表达式的<code>lastIndex</code>属性，对<code>match</code>方法无效，匹配总是从字符串的第一个字符开始。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码表示，设置正则对象的<code>lastIndex</code>属性是无效的。</p>\n<h3> String.prototype.search()</h3>\n<p>字符串对象的<code>search</code>方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回<code>-1</code>。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，第一个匹配结果出现在字符串的<code>1</code>号位置。</p>\n<h3> String.prototype.replace()</h3>\n<p>字符串对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，最后一个正则表达式使用了<code>g</code>修饰符，导致所有的<code>a</code>都被替换掉了。</p>\n<p><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容。</p>\n<ul>\n<li><code>$&amp;</code>：匹配的子字符串。</li>\n<li>`$``：匹配结果前面的文本。</li>\n<li><code>$'</code>：匹配结果后面的文本。</li>\n<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。</li>\n<li><code>$$</code>：指代美元符号<code>$</code>。</li>\n</ul>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，第一个例子是将匹配的组互换位置，第二个例子是改写匹配的值。</p>\n<p><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>作为<code>replace</code>方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用<code>$1</code>到<code>$4</code>表示。匹配函数的作用是将价格插入模板中。</p>\n<h3> String.prototype.split()</h3>\n<p>字符串对象的<code>split</code>方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码的分割规则是0次或多次的<code>a</code>，由于正则默认是贪婪匹配，所以例一的第一个分隔符是<code>aaa</code>，第二个分割符是<code>a</code>，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是<code>aaa</code>，第二个分隔符是0个<code>a</code>（即空字符），第三个分隔符是<code>a</code>，所以将字符串分成四个部分。</p>\n<p>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码的正则表达式使用了括号，第一个组匹配是<code>aaa</code>，第二个组匹配是<code>a</code>，它们都作为数组成员返回。</p>\n<h2> 匹配规则</h2>\n<p>正则表达式的规则很复杂，下面一一介绍这些规则。</p>\n<h3> 字面量字符和元字符</h3>\n<p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，所以<code>/dog/</code>匹配<code>old dog</code>，因为它就表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起。</p>\n<p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。</p>\n<p><strong>（1）点字符（.)</strong></p>\n<p>点字符（<code>.</code>）匹配除回车（<code>\\r</code>）、换行(<code>\\n</code>) 、行分隔符（<code>\\u2028</code>）和段分隔符（<code>\\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code>。</p>\n<p><strong>（2）位置字符</strong></p>\n<p>位置字符用来提示字符所处的位置，主要有两个字符。</p>\n<ul>\n<li><code>^</code> 表示字符串的开始位置</li>\n<li><code>$</code> 表示字符串的结束位置</li>\n</ul>\n<div class=\"language-text\" data-ext=\"text\"></div><p><strong>（3）选择符（<code>|</code>）</strong></p>\n<p>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，正则表达式指定必须匹配<code>11</code>或<code>22</code>。</p>\n<p>多个选择符可以联合使用。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。</p>\n<p>其他的元字符还包括<code>\\</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>{}</code>等，将在下文解释。</p>\n<h3> 转义符</h3>\n<p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\\+</code>。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。</p>\n<p>正则表达式中，需要反斜杠转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\\</code>。需要特别注意的是，如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，<code>RegExp</code>作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。</p>\n<h3> 特殊字符</h3>\n<p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>\n<ul>\n<li><code>\\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li>\n<li><code>[\\b]</code> 匹配退格键(U+0008)，不要与<code>\\b</code>混淆。</li>\n<li><code>\\n</code> 匹配换行键。</li>\n<li><code>\\r</code> 匹配回车键。</li>\n<li><code>\\t</code> 匹配制表符 tab（U+0009）。</li>\n<li><code>\\v</code> 匹配垂直制表符（U+000B）。</li>\n<li><code>\\f</code> 匹配换页符（U+000C）。</li>\n<li><code>\\0</code> 匹配<code>null</code>字符（U+0000）。</li>\n<li><code>\\xhh</code> 匹配一个以两位十六进制数（<code>\\x00</code>-<code>\\xFF</code>）表示的字符。</li>\n<li><code>\\uhhhh</code> 匹配一个以四位十六进制数（<code>\\u0000</code>-<code>\\uFFFF</code>）表示的 Unicode 字符。</li>\n</ul>\n<h3> 字符类</h3>\n<p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如<code>[xyz]</code> 表示<code>x</code>、<code>y</code>、<code>z</code>之中任选一个匹配。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，字符串<code>hello world</code>不包含<code>a</code>、<code>b</code>、<code>c</code>这三个字母中的任一个，所以返回<code>false</code>；字符串<code>apple</code>包含字母<code>a</code>，所以返回<code>true</code>。</p>\n<p>有两个字符在字符类中有特殊含义。</p>\n<p><strong>（1）脱字符（^）</strong></p>\n<p>如果方括号内的第一个字符是<code>[^]</code>，则表示除了字符类之中的字符，其他字符都可以匹配。比如，<code>[^xyz]</code>表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，字符串<code>bbc news</code>包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>true</code>；字符串<code>bbc</code>不包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>false</code>。</p>\n<p>如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，字符串<code>s</code>含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式<code>[^]</code>包含一切字符，所以匹配成功。</p>\n<blockquote>\n<p>注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</p>\n</blockquote>\n<p><strong>（2）连字符（-）</strong></p>\n<p>某些情况下，对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围。比如，<code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符<code>b</code>。只有当连字号用在方括号之中，才表示连续的字符序列。</p>\n<p>以下都是合法的字符类简写形式。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中最后一个字符类<code>[1-31]</code>，不代表<code>1</code>到<code>31</code>，只代表<code>1</code>到<code>3</code>。</p>\n<p>连字符还可以用来指定 Unicode 字符的范围。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，<code>\\u0128-\\uFFFF</code>表示匹配码点在<code>0128</code>到<code>FFFF</code>之间的所有字符。</p>\n<p>另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是<code>[A-z]</code>，表面上它是选中从大写的<code>A</code>到小写的<code>z</code>之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，由于反斜杠（''）的ASCII码在大写字母与小写字母之间，结果会被选中。</p>\n<h3> 预定义模式</h3>\n<p>预定义模式指的是某些常见模式的简写方式。</p>\n<ul>\n<li><code>\\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>\n<li><code>\\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>\n<li><code>\\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>\n<li><code>\\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>\n<li><code>\\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \\t\\r\\n\\v\\f]</code>。</li>\n<li><code>\\S</code> 匹配非空格的字符，相当于<code>[^ \\t\\r\\n\\v\\f]</code>。</li>\n<li><code>\\b</code> 匹配词的边界。</li>\n<li><code>\\B</code> 匹配非词边界，即在词的内部。</li>\n</ul>\n<p>下面是一些例子。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>\\s</code>表示空格，所以匹配结果会包括空格。<code>\\b</code>表示词的边界，所以<code>world</code>的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\\B</code>表示非词的边界，只有<code>world</code>的词首不独立，才会匹配。</p>\n<p>通常，正则表达式遇到换行符（<code>\\n</code>）就会停止匹配。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，字符串<code>html</code>包含一个换行符，结果点字符（<code>.</code>）不匹配换行符，导致匹配结果可能不符合原意。这时使用<code>\\s</code>字符类，就能包括换行符。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，<code>[\\S\\s]</code>指代一切字符。</p>\n<h3> 重复类</h3>\n<p>模式的精确匹配次数，使用大括号（<code>{}</code>）表示。<code>{n}</code>表示恰好重复<code>n</code>次，<code>{n,}</code>表示至少重复<code>n</code>次，<code>{n,m}</code>表示重复不少于<code>n</code>次，不多于<code>m</code>次。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，第一个模式指定<code>o</code>连续出现2次，第二个模式指定<code>o</code>连续出现2次到5次之间。</p>\n<h3> 量词符</h3>\n<p>量词符用来设定某个模式出现的次数。</p>\n<ul>\n<li><code>?</code> 问号表示某个模式出现0次或1次，等同于<code>{0, 1}</code>。</li>\n<li><code>*</code> 星号表示某个模式出现0次或多次，等同于<code>{0,}</code>。</li>\n<li><code>+</code> 加号表示某个模式出现1次或多次，等同于<code>{1,}</code>。</li>\n</ul>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 贪婪模式</h3>\n<p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配到下一个字符不满足匹配规则为止。这被称为贪婪模式。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，模式是<code>/a+/</code>，表示匹配1个<code>a</code>或多个<code>a</code>，那么到底会匹配几个<code>a</code>呢？因为默认是贪婪模式，会一直匹配到字符<code>a</code>不出现为止，所以匹配结果是3个<code>a</code>。</p>\n<p>除了贪婪模式，还有非贪婪模式，即最小可能匹配。只要一发现匹配，就返回结果，不要往下检查。如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面例子中，模式结尾添加了一个问号<code>/a+?/</code>，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配，<code>+?</code>表示只要发现一个<code>a</code>，就不再往下匹配了。</p>\n<p>除了非贪婪模式的加号（<code>+?</code>），还有非贪婪模式的星号（<code>*?</code>）和非贪婪模式的问号（<code>??</code>）。</p>\n<ul>\n<li><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</li>\n<li><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</li>\n<li><code>??</code>：表格某个模式出现0次或1次，匹配时采用非贪婪模式。</li>\n</ul>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面例子中，<code>/ab*/</code>表示如果<code>a</code>后面有多个<code>b</code>，那么匹配尽可能多的<code>b</code>；<code>/ab*?/</code>表示匹配尽可能少的<code>b</code>，也就是0个<code>b</code>。</p>\n<h3> 修饰符</h3>\n<p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p>\n<p>修饰符可以单个使用，也可以多个一起使用。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p><strong>（1）g 修饰符</strong></p>\n<p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，正则模式不含<code>g</code>修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回<code>true</code>。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，正则模式含有<code>g</code>修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串<code>abba</code>只有两个<code>b</code>，所以前两次匹配结果为<code>true</code>，第三次匹配结果为<code>false</code>。</p>\n<p><strong>（2）i 修饰符</strong></p>\n<p>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符以后表示忽略大小写（ignoreCase）。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码表示，加了<code>i</code>修饰符以后，不考虑大小写，所以模式<code>abc</code>匹配字符串<code>ABC</code>。</p>\n<p><strong>（3）m 修饰符</strong></p>\n<p><code>m</code>修饰符表示多行模式（multiline），会修改<code>^</code>和<code>$</code>的行为。默认情况下（即不加<code>m</code>修饰符时），<code>^</code>和<code>$</code>匹配字符串的开始处和结尾处，加上<code>m</code>修饰符以后，<code>^</code>和<code>$</code>还会匹配行首和行尾，即<code>^</code>和<code>$</code>会识别换行符（<code>\\n</code>）。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面的代码中，字符串结尾处有一个换行符。如果不加<code>m</code>修饰符，匹配不成功，因为字符串的结尾不是<code>world</code>；加上以后，<code>$</code>可以匹配行尾。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码要求匹配行首的<code>b</code>，如果不加<code>m</code>修饰符，就相当于<code>b</code>只能处在字符串的开始处。加上<code>m</code>修饰符以后，换行符<code>\\n</code>也会被认为是一行的开始。</p>\n<h3> 组匹配</h3>\n<p><strong>（1）概述</strong></p>\n<p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，第一个模式没有括号，结果<code>+</code>只表示重复字母<code>d</code>，第二个模式有括号，结果<code>+</code>就表示匹配<code>fred</code>这个词。</p>\n<p>下面是另外一个分组捕获的例子。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获<code>a</code>，第二个括号捕获<code>c</code>。</p>\n<p>注意，使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码使用带<code>g</code>修饰符的正则表达式，结果<code>match</code>方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的<code>exec</code>方法，配合循环，才能读到每一轮匹配的组捕获。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>正则表达式内部，还可以用<code>\\n</code>引用括号匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的括号。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面的代码中，<code>\\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>\n<p>下面是另外一个例子。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>括号还可以嵌套。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，<code>\\1</code>指向外层括号，<code>\\2</code>指向内层括号。</p>\n<p>组匹配非常有用，下面是一个匹配网页标签的例子。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，圆括号匹配尖括号之中的标签，而<code>\\1</code>就表示对应的闭合标签。</p>\n<p>上面代码略加修改，就能捕获带有属性的标签。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>（2）非捕获组</strong></p>\n<p><code>(?:x)</code>称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p>\n<p>非捕获组的作用请考虑这样一个场景，假定需要匹配<code>foo</code>或者<code>foofoo</code>，正则表达式就应该写成<code>/(foo){1, 2}/</code>，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为<code>/(?:foo){1, 2}/</code>，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。</p>\n<p>请看下面的例子。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。</p>\n<p>下面是用来分解网址的正则表达式。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>\n<p><strong>（3）先行断言</strong></p>\n<p><code>x(?=y)</code>称为先行断言（Positive look-ahead），<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/\\d+(?=%)/</code>。</p>\n<p>“先行断言”中，括号里的部分是不会返回的。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面的代码使用了先行断言，<code>b</code>在<code>c</code>前面所以被匹配，但是括号对应的<code>c</code>不会被返回。</p>\n<p><strong>（4）先行否定断言</strong></p>\n<p><code>x(?!y)</code>称为先行否定断言（Negative look-ahead），<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/\\d+(?!%)/</code>。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是<code>14</code>。</p>\n<p>“先行否定断言”中，括号里的部分是不会返回的。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面的代码使用了先行否定断言，<code>b</code>不在<code>c</code>前面所以被匹配，而且括号对应的<code>d</code>不会被返回。</p>\n<h2> 总结</h2>\n<h3> 正则符号</h3>\n<p>方括号：用于查找某个范围内的字符</p>\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[abc]</td>\n<td>查找方括号之间的任何字符。</td>\n</tr>\n<tr>\n<td>[^abc]</td>\n<td>查找任何不在方括号之间的字符。,只要一个字符串中有除了abc以外的字母就会返回true</td>\n</tr>\n<tr>\n<td>[0-9]</td>\n<td>查找任何从 0 至 9 的数字。</td>\n</tr>\n<tr>\n<td>[a-z]</td>\n<td>查找任何从小写 a 到小写 z 的字符。</td>\n</tr>\n<tr>\n<td>[A-Z]</td>\n<td>查找任何从大写 A 到大写 Z 的字符。</td>\n</tr>\n<tr>\n<td>[A-z]</td>\n<td>查找任何从大写 A 到小写 z 的字符。</td>\n</tr>\n<tr>\n<td>[adgk]</td>\n<td>查找给定集合内的任何字符。</td>\n</tr>\n<tr>\n<td>[^adgk]</td>\n<td>查找给定集合外的任何字符。</td>\n</tr>\n<tr>\n<td>(red|blue|green)</td>\n<td>查找任何指定的选项。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>元字符：是拥有特殊含义的字符</p>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td>查找单个字符，除了换行和行结束符。</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>查找单词字符。</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>查找非单词字符。</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>查找数字。</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>查找非数字字符。</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>查找空白字符。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>查找非空白字符。</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配单词边界。一个单词旁边必须是有空白字符作为边界。比如判断是否含有child单词,用/\\bchild\\b/ 判断是否有一个独立的单词</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配非单词边界。单词左右两边没有空白字符</td>\n</tr>\n<tr>\n<td>\\0</td>\n<td>查找 NULL 字符。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>查找换行符。</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>查找换页符。</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>查找回车符。</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>查找制表符。</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>查找垂直制表符。</td>\n</tr>\n<tr>\n<td>\\xxx</td>\n<td>查找以八进制数 xxx 规定的字符。</td>\n</tr>\n<tr>\n<td>\\xdd</td>\n<td>查找以十六进制数 dd 规定的字符。</td>\n</tr>\n<tr>\n<td>\\uxxxx</td>\n<td>查找以十六进制数 xxxx 规定的 Unicode 字符。</td>\n</tr>\n</tbody>\n</table>\n<p>注意:</p>\n<ol>\n<li>\n<p><strong>在正则表达式中\\表示转义字符，但是js中任何地方\\都是转义字符，所以要验证\\也必须输入两个(字面量中)</strong> **如:**正则表达式.表示任意字符/./只会表示是否有任意字符，如果要判断有没有.(点这个符号),需要用/\\ ./来表示</p>\n</li>\n<li>\n<p><strong>如果用构造函数的方法，由于它的参数是一个字符串，而\\是字符串中的转义字符，如果要使用\\则需要使用\\ \\代替(相当于用了三个\\ )，这样相当于把他们先化为字面量，再自变量转换，而因为\\ .其实就是.，所以没有作用</strong></p>\n</li>\n</ol>\n<p>量词：通过量词可以设置一个内容出现的次数用{}里面写需要的数量,量词只对它前边的一个内容起作用</p>\n<table>\n<thead>\n<tr>\n<th>量词</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>n+</td>\n<td>匹配任何包含至少一个 n 的字符串。例如，/a+/ 匹配 \"candy\" 中的 \"a\"，\"caaaaaaandy\" 中所有的 \"a\"。</td>\n</tr>\n<tr>\n<td>n*</td>\n<td>匹配任何包含零个或多个 n 的字符串。例如，/bo*/ 匹配 \"A ghost booooed\" 中的 \"boooo\"，\"A bird warbled\" 中的 \"b\"，但是不匹配 \"A goat grunted\"。</td>\n</tr>\n<tr>\n<td>n?</td>\n<td>匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 \"angel\" 中的 \"el\"，\"angle\" 中的 \"le\"。</td>\n</tr>\n<tr>\n<td>n{X}</td>\n<td>匹配包含 X 个 n 的序列的字符串。例如，/a{2}/ 不匹配 \"candy,\" 中的 \"a\"，但是匹配 \"caandy,\" 中的两个 \"a\"，且匹配 \"caaandy.\" 中的前两个 \"a\"。</td>\n</tr>\n<tr>\n<td>n{X,}</td>\n<td>X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，/a{2,}/ 不匹配 \"candy\" 中的 \"a\"，但是匹配 \"caandy\" 和 \"caaaaaaandy.\" 中所有的 \"a\"。</td>\n</tr>\n<tr>\n<td>n{X,Y}</td>\n<td>X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，/a{1,3}/ 不匹配 \"cndy\"，匹配 \"candy,\" 中的 \"a\"，\"caandy,\" 中的两个 \"a\"，匹配 \"caaaaaaandy\" 中的前面三个 \"a\"。注意，当匹配 \"caaaaaaandy\" 时，即使原始字符串拥有更多的 \"a\"，匹配项也是 \"aaa\"。</td>\n</tr>\n<tr>\n<td>n$</td>\n<td>匹配任何结尾为 n 的字符串。</td>\n</tr>\n<tr>\n<td>^n</td>\n<td>匹配任何开头为 n 的字符串。注意与[^]作对比</td>\n</tr>\n<tr>\n<td>?=n</td>\n<td>匹配任何其后紧接指定字符串 n 的字符串。</td>\n</tr>\n<tr>\n<td>?!n</td>\n<td>匹配任何其后没有紧接指定字符串 n 的字符串。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注：在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>子集：用圆括号()包起来的属于一个整体,叫做一个子集</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><div class=\"language-javascript\" data-ext=\"js\"></div><h3> 正则断言</h3>\n<p><strong>所谓断言，就是指明某个字符串前边或者后边，将会出现满足某种规律的字符串</strong></p>\n<p>在将断言前.先将子集的捕获与捕获,一般的子集通过()括住都会被捕获,这时可以通过$1等来使用被捕获的子集,而如果不想要子集被捕获,只是用做一个匹配模式,就可以让子集不被捕获到,一般是通过(?:)来括住一个子集</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>(?:X)</td>\n<td>不捕获匹配,不能通过$符号进行捕获到该子集,包括下面的所有都是捕获匹配。</td>\n</tr>\n<tr>\n<td>(?=X )</td>\n<td>零宽度正先行断言。仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。例如，\\w+(?=\\d) 与后跟数字的单词匹配，而不与该数字匹配。此构造不会回溯。</td>\n</tr>\n<tr>\n<td>(?!X)</td>\n<td>零宽度负先行断言。仅当子表达式 X 不在 此位置的右侧匹配时才继续匹配。例如，例如，\\w+(?!\\d) 与后不跟数字的单词匹配，而不与该数字匹配 。</td>\n</tr>\n<tr>\n<td>(?&lt;=X)</td>\n<td>零宽度正后发断言。仅当子表达式 X 在 此位置的左侧匹配时才继续匹配。例如，(?&lt;=19)99 与跟在 19 后面的 99 的实例匹配。此构造不会回溯。</td>\n</tr>\n<tr>\n<td>(?&lt;!X)</td>\n<td>零宽度负后发断言。仅当子表达式 X 不在此位置的左侧匹配时才继续匹配。例如，(?&lt;!19)99 与不跟在 19 后面的 99 的实例匹配</td>\n</tr>\n</tbody>\n</table>\n<p><strong>例子:是否为浮点数</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>例子:手机号规则</strong></p>\n<ul>\n<li>以1开头</li>\n<li>第二位3-9任意数字</li>\n<li>三位以后任意数字9位</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>例子:邮箱格式</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> u 修饰符</h2>\n<p>ES6 对正则表达式添加了<code>u</code>修饰符，含义为“Unicode 模式”，用来正确处理大于<code>\\uFFFF</code>的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>\\uD83D\\uDC2A</code>是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>。加了<code>u</code>修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为<code>false</code>。</p>\n<p>一旦加上<code>u</code>修饰符号，就会修改下面这些正则表达式的行为。</p>\n<p><strong>（1）点字符</strong></p>\n<p>点（<code>.</code>）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于<code>0xFFFF</code>的 Unicode 字符，点字符不能识别，必须加上<code>u</code>修饰符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，如果不添加<code>u</code>修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p>\n<p><strong>（2）Unicode 字符表示法</strong></p>\n<p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别当中的大括号，否则会被解读为量词。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，如果不加<code>u</code>修饰符，正则表达式无法识别<code>\\u{61}</code>这种表示法，只会认为这匹配 61 个连续的<code>u</code>。</p>\n<p><strong>（3）量词</strong></p>\n<p>使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（4）预定义模式</strong></p>\n<p><code>u</code>修饰符也影响到预定义模式，能否正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>\\S</code>是预定义模式，匹配所有非空白字符。只有加了<code>u</code>修饰符，它才能正确匹配码点大于<code>0xFFFF</code>的 Unicode 字符。</p>\n<p>利用这一点，可以写出一个正确返回字符串长度的函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（5）i 修饰符</strong></p>\n<p>有些 Unicode 字符的编码不同，但是字型很相近，比如，<code>\\u004B</code>与<code>\\u212A</code>都是大写的<code>K</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，不加<code>u</code>修饰符，就无法识别非规范的<code>K</code>字符。</p>\n<p><strong>（6）转义</strong></p>\n<p>没有<code>u</code>修饰符的情况下，正则中没有定义的转义（如逗号的转义<code>\\,</code>）无效，而在<code>u</code>模式会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，没有<code>u</code>修饰符时，逗号前面的反斜杠是无效的，加了<code>u</code>修饰符就报错。</p>\n<h2> RegExp.prototype.unicode 属性</h2>\n<p>正则实例对象新增<code>unicode</code>属性，表示是否设置了<code>u</code>修饰符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，正则表达式是否设置了<code>u</code>修饰符，可以从<code>unicode</code>属性看出来。</p>\n<h2> y 修饰符</h2>\n<p>除了<code>u</code>修饰符，ES6 还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符。</p>\n<p><code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码有两个正则表达式，一个使用<code>g</code>修饰符，另一个使用<code>y</code>修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是<code>_aa_a</code>。由于<code>g</code>修饰没有位置要求，所以第二次执行会返回结果，而<code>y</code>修饰符要求匹配必须从头部开始，所以返回<code>null</code>。</p>\n<p>如果改一下正则表达式，保证每次都能头部匹配，<code>y</code>修饰符就会返回结果了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码每次匹配，都是从剩余字符串的头部开始。</p>\n<p>使用<code>lastIndex</code>属性，可以更好地说明<code>y</code>修饰符。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>lastIndex</code>属性指定每次搜索的开始位置，<code>g</code>修饰符从这个位置开始向后搜索，直到发现匹配为止。</p>\n<p><code>y</code>修饰符同样遵守<code>lastIndex</code>属性，但是要求必须在<code>lastIndex</code>指定的位置发现匹配。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实际上，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码由于不能保证头部匹配，所以返回<code>null</code>。<code>y</code>修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效。</p>\n<p>下面是字符串对象的<code>replace</code>方法的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，最后一个<code>a</code>因为不是出现在下一次匹配的头部，所以不会被替换。</p>\n<p>单单一个<code>y</code>修饰符对<code>match</code>方法，只能返回第一个匹配，必须与<code>g</code>修饰符联用，才能返回所有匹配。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>y</code>修饰符的一个应用，是从字符串提取 token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，如果字符串里面没有非法字符，<code>y</code>修饰符与<code>g</code>修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>g</code>修饰符会忽略非法字符，而<code>y</code>修饰符不会，这样就很容易发现错误。</p>\n<h2> RegExp.prototype.sticky 属性</h2>\n<p>与<code>y</code>修饰符相匹配，ES6 的正则实例对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> RegExp.prototype.flags 属性</h2>\n<p>ES6 为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> s 修饰符：dotAll 模式</h2>\n<p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）。</p>\n<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p>\n<ul>\n<li>U+000A 换行符（<code>\\n</code>）</li>\n<li>U+000D 回车符（<code>\\r</code>）</li>\n<li>U+2028 行分隔符（line separator）</li>\n<li>U+2029 段分隔符（paragraph separator）</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，因为<code>.</code>不匹配<code>\\n</code>，所以正则表达式返回<code>false</code>。</p>\n<p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种解决方案毕竟不太符合直觉，ES2018 <a href=\"https://github.com/tc39/proposal-regexp-dotall-flag\" target=\"_blank\" rel=\"noopener noreferrer\">引入</a><code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这被称为<code>dotAll</code>模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个<code>dotAll</code>属性，返回一个布尔值，表示该正则表达式是否处在<code>dotAll</code>模式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>/s</code>修饰符和多行修饰符<code>/m</code>不冲突，两者一起使用的情况下，<code>.</code>匹配所有字符，而<code>^</code>和<code>$</code>匹配每一行的行首和行尾。</p>\n<h2> 后行断言</h2>\n<p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入<a href=\"https://github.com/tc39/proposal-regexp-lookbehind\" target=\"_blank\" rel=\"noopener noreferrer\">后行断言</a>，V8 引擎 4.9 版（Chrome 62）已经支持。</p>\n<p>“先行断言”指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code>。比如，只匹配百分号之前的数字，要写成<code>/\\d+(?=%)/</code>。“先行否定断言”指的是，<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code>。比如，只匹配不在百分号之前的数字，要写成<code>/\\d+(?!%)/</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（<code>(?=%)</code>），是不计入返回结果的。</p>\n<p>“后行断言”正好与“先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\\$)\\d+/</code>。“后行否定断言”则与“先行否定断言”相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\\$)\\d+/</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的例子中，“后行断言”的括号之中的部分（<code>(?&lt;=\\$)</code>），也是不计入返回结果。</p>\n<p>下面的例子是使用后行断言进行字符串替换。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，只有在美元符号后面的<code>foo</code>才会被替换。</p>\n<p>“后行断言”的实现，需要先匹配<code>/(?&lt;=y)x/</code>的<code>x</code>，然后再回到左边，匹配<code>y</code>的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p>\n<p>首先，后行断言的组匹配，与正常情况下结果是不一样的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是<code>105</code>和<code>3</code>。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是<code>1</code>和<code>053</code>。</p>\n<p>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果后行断言的反斜杠引用（<code>\\1</code>）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</p>\n<h2> Unicode 属性类</h2>\n<p>ES2018 <a href=\"https://github.com/tc39/proposal-regexp-unicode-property-escapes\" target=\"_blank\" rel=\"noopener noreferrer\">引入</a>了一种新的类的写法<code>\\p{...}</code>和<code>\\P{...}</code>，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>\\p{Script=Greek}</code>指定匹配一个希腊文字母，所以匹配<code>π</code>成功。</p>\n<p>Unicode 属性类要指定属性名和属性值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>对于某些属性，可以只写属性名，或者只写属性值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>\\P{…}</code>是<code>\\p{…}</code>的反向匹配，即匹配不满足条件的字符。</p>\n<p>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上<code>u</code>修饰符。如果不加<code>u</code>修饰符，正则表达式使用<code>\\p</code>和<code>\\P</code>会报错，ECMAScript 预留了这两个类。</p>\n<p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p>\n<p><code>\\p{Number}</code>甚至能匹配罗马数字。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是其他一些例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 具名组匹配</h2>\n<h3> 简介</h3>\n<p>正则表达式使用圆括号进行组匹配。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，正则表达式里面有三组圆括号。使用<code>exec</code>方法，就可以将这三组匹配结果提取出来。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如<code>matchObj[1]</code>）引用，要是组的顺序变了，引用的时候就必须修改序号。</p>\n<p>ES2018 引入了<a href=\"https://github.com/tc39/proposal-regexp-named-groups\" target=\"_blank\" rel=\"noopener noreferrer\">具名组匹配</a>（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（<code>?&lt;year&gt;</code>），然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名。同时，数字序号（<code>matchObj[1]</code>）依然有效。</p>\n<p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p>\n<p>如果具名组没有匹配，那么对应的<code>groups</code>对象属性会是<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，具名组<code>as</code>没有找到匹配，那么<code>matchObj.groups.as</code>属性值就是<code>undefined</code>，并且<code>as</code>这个键名在<code>groups</code>是始终存在的。</p>\n<h3> 解构赋值和替换</h3>\n<p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>字符串替换时，使用<code>$&lt;组名&gt;</code>引用具名组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>replace</code>方法的第二个参数是一个字符串，而不是正则表达式。</p>\n<p><code>replace</code>方法的第二个参数也可以是函数，该函数的参数序列如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p>\n<h3> 引用</h3>\n<p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用<code>\\k&lt;组名&gt;</code>的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>数字引用（<code>\\1</code>）依然有效。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这两种引用语法还可以同时使用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 正则匹配索引</h2>\n<p>正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的<code>exec()</code>方法，返回结果有一个<code>index</code>属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。</p>\n<p>现在有一个<a href=\"https://github.com/tc39/proposal-regexp-match-Indices\" target=\"_blank\" rel=\"noopener noreferrer\">第三阶段提案</a>，为<code>exec()</code>方法的返回结果加上<code>indices</code>属性，在这个属性上面可以拿到匹配的开始位置和结束位置。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，<code>exec()</code>方法的返回结果<code>result</code>，它的<code>index</code>属性是整个匹配结果（<code>ab</code>）的开始位置，而它的<code>indices</code>属性是一个数组，成员是每个匹配的开始位置和结束位置的数组。由于该例子的正则表达式没有组匹配，所以<code>indices</code>数组只有一个成员，表示整个匹配的开始位置是<code>1</code>，结束位置是<code>3</code>。</p>\n<p>注意，开始位置包含在匹配结果之中，但是结束位置不包含在匹配结果之中。比如，匹配结果为<code>ab</code>，分别是原始字符串的第1位和第2位，那么结束位置就是第3位。</p>\n<p>如果正则表达式包含组匹配，那么<code>indices</code>属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，正则表达式包含一个组匹配，那么<code>indices</code>属性数组就有两个成员，第一个成员是整个匹配结果（<code>abbcd</code>）的开始位置和结束位置，第二个成员是组匹配（<code>cd</code>）的开始位置和结束位置。</p>\n<p>下面是多个组匹配的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，正则表达式包含两个组匹配，所以<code>indices</code>属性数组就有三个成员。</p>\n<p>如果正则表达式包含具名组匹配，<code>indices</code>属性数组还会有一个<code>groups</code>属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，<code>exec()</code>方法返回结果的<code>indices.groups</code>属性是一个对象，提供具名组匹配<code>Z</code>的开始位置和结束位置。</p>\n<p>如果获取组匹配不成功，<code>indices</code>属性数组的对应成员则为<code>undefined</code>，<code>indices.groups</code>属性对象的对应成员也是<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，由于组匹配不成功，所以<code>indices</code>属性数组和<code>indices.groups</code>属性对象对应的组匹配成员都是<code>undefined</code>。</p>\n<h2> String.prototype.matchAll()</h2>\n<p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用<code>g</code>修饰符或<code>y</code>修饰符，在循环里面逐一取出。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>while</code>循环取出每一轮的正则匹配，一共三轮。</p>\n<p><a href=\"https://github.com/tc39/proposal-string-matchall\" target=\"_blank\" rel=\"noopener noreferrer\">ES2020</a> 增加了<code>String.prototype.matchAll()</code>方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，由于<code>string.matchAll(regex)</code>返回的是遍历器，所以可以用<code>for...of</code>循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p>\n<p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "26.标准对象库",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses26.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses26.html",
      "summary": "console 对象与控制台 console 对象的静态方法 console对象提供的各种静态方法，用来与控制台窗口互动。 console.log()，console.info()，console.debug() console.log方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。 console.log方法会自动在每次输出的...",
      "content_html": "<h1> 标准对象库</h1>\n<h2> console 对象与控制台</h2>\n<h3> console 对象的静态方法</h3>\n<p><code>console</code>对象提供的各种静态方法，用来与控制台窗口互动。</p>\n<h4> console.log()，console.info()，console.debug()</h4>\n<p><code>console.log</code>方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>console.log</code>方法会自动在每次输出的结尾，添加换行符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果第一个参数是格式字符串（使用了格式占位符），<code>console.log</code>方法将依次用后面的参数替换占位符，然后再进行输出。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>console.log</code>方法的第一个参数有三个占位符（<code>%s</code>），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。</p>\n<p><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符。</p>\n<ul>\n<li><code>%s</code> 字符串</li>\n<li><code>%d</code> 整数</li>\n<li><code>%i</code> 整数</li>\n<li><code>%f</code> 浮点数</li>\n<li><code>%o</code> 对象的链接</li>\n<li><code>%c</code> CSS 格式字符串</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，第二个参数是数值，对应的占位符是<code>%d</code>，第三个参数是字符串，对应的占位符是<code>%s</code>。</p>\n<p>使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码运行后，输出的内容将显示为黄底红字。</p>\n<p><code>console.log</code>方法的两种参数格式，可以结合在一起使用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果参数是一个对象，<code>console.log</code>会显示该对象的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码输出<code>Date</code>对象的值，结果为一个构造函数。</p>\n<p><strong><code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个蓝色图标。</strong></p>\n<p><strong><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示。</strong></p>\n<p><code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，使用自定义的<code>console.log</code>方法，可以在显示结果添加当前时间。</p>\n<h4> console.warn()，console.error()</h4>\n<p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；<code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p>\n<p><strong>这两个方法均不会阻止程序的正常运行。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>可以这样理解，<code>log</code>方法是写入标准输出（<code>stdout</code>），<code>warn</code>方法和<code>error</code>方法是写入标准错误（<code>stderr</code>）。</p>\n<h4> console.table()</h4>\n<p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>language</code>变量，转为表格显示如下。</p>\n<table>\n<thead>\n<tr>\n<th>(index)</th>\n<th>name</th>\n<th>fileExtension</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>\"JavaScript\"</td>\n<td>\".js\"</td>\n</tr>\n<tr>\n<td>1</td>\n<td>\"TypeScript\"</td>\n<td>\".ts\"</td>\n</tr>\n<tr>\n<td>2</td>\n<td>\"CoffeeScript\"</td>\n<td>\".coffee\"</td>\n</tr>\n</tbody>\n</table>\n<p>下面是显示表格内容的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>language</code>，转为表格显示如下。</p>\n<table>\n<thead>\n<tr>\n<th>(index)</th>\n<th>name</th>\n<th>paradigm</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>csharp</td>\n<td>\"C#\"</td>\n<td>\"object-oriented\"</td>\n</tr>\n<tr>\n<td>fsharp</td>\n<td>\"F#\"</td>\n<td>\"functional\"</td>\n</tr>\n</tbody>\n</table>\n<h4> console.count()</h4>\n<p><code>count</code>方法用于计数，输出它被调用了多少次。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码每次调用<code>greet</code>函数，内部的<code>console.count</code>方法就输出执行次数。</p>\n<p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次。</p>\n<h4> console.dir()，console.dirxml()</h4>\n<p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码显示<code>dir</code>方法的输出结果，比<code>log</code>方法更易读，信息也更丰富。</p>\n<p>该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>Node 环境之中，还可以指定以代码高亮的形式输出。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code>console.dirxml</code>等同于<code>console.dir</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> console.assert()</h4>\n<p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，<strong>如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</strong></p>\n<p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面是一个例子，判断子节点的个数是否大于等于500。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。</p>\n<h4> console.time()，console.timeEnd()</h4>\n<p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p>\n<h4> console.group()，console.groupEnd()，console.groupCollapsed()</h4>\n<p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。</p>\n<p><code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。</p>\n<h4> console.trace()，console.clear()</h4>\n<p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用。</p>\n<p><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示。</p>\n<p><code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，使用自定义的<code>console.log</code>方法，可以在显示结果添加当前时间。</p>\n<h3> 控制台命令行 API</h3>\n<p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法。</p>\n<p>（1）<code>$_</code></p>\n<p><code>$_</code>属性返回上一个表达式的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>（2）<code>$0</code> - <code>$4</code></p>\n<p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。</p>\n<p>（3）<code>$(selector)</code></p>\n<p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。</p>\n<p>（4）<code>$$(selector)</code></p>\n<p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。</p>\n<p>（5）<code>$x(path)</code></p>\n<p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。</p>\n<p>（6）<code>inspect(object)</code></p>\n<p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code>。</p>\n<p>（7）<code>getEventListeners(object)</code></p>\n<p><code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p>\n<p>（8）<code>keys(object)</code>，<code>values(object)</code></p>\n<p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。</p>\n<p><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>（9）<code>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</code></p>\n<p><code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码分别表示单个事件和多个事件的监听方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示如何停止监听。</p>\n<p><code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p>\n<ul>\n<li>mouse：\"mousedown\", \"mouseup\", \"click\", \"dblclick\", \"mousemove\", \"mouseover\", \"mouseout\", \"mousewheel\"</li>\n<li>key：\"keydown\", \"keyup\", \"keypress\", \"textInput\"</li>\n<li>touch：\"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\"</li>\n<li>control：\"resize\", \"scroll\", \"zoom\", \"focus\", \"blur\", \"select\", \"change\", \"submit\", \"reset\"</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示监听所有<code>key</code>大类的事件。</p>\n<p>（10）其他方法</p>\n<p>命令行 API 还提供以下方法。</p>\n<ul>\n<li><code>clear()</code>：清除控制台的历史。</li>\n<li><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li>\n<li><code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li>\n<li><code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li>\n</ul>\n<h3> debugger 语句</h3>\n<p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p>\n<p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p>\n<h2> Date 对象</h2>\n<h3> 简介</h3>\n<p><code>Date</code>对象是 JavaScript 原生的时间库。它以国际标准时间（UTC）1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。</p>\n<h3> 普通函数的用法</h3>\n<p><code>Date</code>对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，即使带有参数，<code>Date</code>作为普通函数使用时，返回的还是当前时间。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码说明，无论有没有参数，直接调用<code>Date</code>总是返回当前时间。</p>\n<h3> 构造函数的用法</h3>\n<p><code>Date</code>还可以当作构造函数使用。对它使用<code>new</code>命令，会返回一个<code>Date</code>对象的实例。如果不加参数，实例代表的就是当前时间。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Date</code>实例有一个独特的地方。其他对象求值的时候，都是默认调用<code>.valueOf()</code>方法，但是<code>Date</code>实例求值的时候，默认调用的是<code>toString()</code>方法。这导致对<code>Date</code>实例求值，返回的是一个字符串，代表该实例对应的时间。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>today</code>是<code>Date</code>的实例，直接求值等同于调用<code>toString</code>方法。</p>\n<p>作为构造函数时，<code>Date</code>对象可以接受多种格式的参数，返回一个该参数对应的时间实例。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于<code>Date</code>构造函数的参数，有几点说明。</p>\n<p>第一点，参数可以是负整数，代表1970年元旦之前的时间。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>第二点，只要是能被<code>Date.parse()</code>方法解析的字符串，都可以当作参数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面多种日期字符串的写法，返回的都是同一个时间。</p>\n<p>第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，<code>Date</code>会将其解释为毫秒数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，2013被解释为毫秒数，而不是年份。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，不管有几个参数，返回的都是2013年1月1日零点。</p>\n<p>最后，各个参数的取值范围如下。</p>\n<ul>\n<li>年：使用四位数年份，比如<code>2000</code>。如果写成两位数或个位数，则加上<code>1900</code>，即<code>10</code>代表1910年。如果是负数，表示公元前。</li>\n<li>月：<code>0</code>表示一月，依次类推，<code>11</code>表示12月。</li>\n<li>日：<code>1</code>到<code>31</code>。</li>\n<li>小时：<code>0</code>到<code>23</code>。</li>\n<li>分钟：<code>0</code>到<code>59</code>。</li>\n<li>秒：<code>0</code>到<code>59</code></li>\n<li>毫秒：<code>0</code>到<code>999</code>。</li>\n</ul>\n<p>注意，月份从<code>0</code>开始计算，但是，天数从<code>1</code>开始计算。另外，除了日期的默认值为<code>1</code>，小时、分钟、秒钟和毫秒的默认值都是<code>0</code>。</p>\n<p>这些参数如果超出了正常范围，会被自动折算。比如，如果月设为<code>15</code>，就折算为下一年的4月。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的第二个例子，日期设为<code>0</code>，就代表上个月的最后一天。</p>\n<p>参数还可以使用负数，表示扣去的时间。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，分别对月和日使用了负数，表示从基准日扣去相应的时间。</p>\n<h3> 日期的运算</h3>\n<p>类型自动转换时，<code>Date</code>实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 静态方法</h3>\n<h4> Date.now()</h4>\n<p><code>Date.now</code>方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Date.parse()</h4>\n<p><code>Date.parse</code>方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。</p>\n<p>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>格式，其中最后的<code>Z</code>表示时区。但是，其他格式也可以被解析，请看下面的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的日期字符串都可以解析。</p>\n<p>如果解析失败，返回<code>NaN</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Date.UTC()</h4>\n<p><code>Date.UTC</code>方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法的参数用法与<code>Date</code>构造函数完全一致，比如月从<code>0</code>开始计算，日期从<code>1</code>开始计算。区别在于<code>Date.UTC</code>方法的参数，会被解释为 UTC 时间（世界标准时间），<code>Date</code>构造函数的参数会被解释为当前时区的时间。</p>\n<h3> 实例方法</h3>\n<p><code>Date</code>的实例对象，有几十个自己的方法，除了<code>valueOf</code>和<code>toString</code>，可以分为以下三类。</p>\n<ul>\n<li><code>to</code>类：从<code>Date</code>对象返回一个字符串，表示指定的时间。</li>\n<li><code>get</code>类：获取<code>Date</code>对象的日期和时间。</li>\n<li><code>set</code>类：设置<code>Date</code>对象的日期和时间。</li>\n</ul>\n<h4> Date.prototype.valueOf()</h4>\n<p><code>valueOf</code>方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于<code>getTime</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>预期为数值的场合，<code>Date</code>实例会自动调用该方法，所以可以用下面的方法计算时间的间隔。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> to 类方法</h4>\n<p><strong>（1）Date.prototype.toString()</strong></p>\n<p><code>toString</code>方法返回一个完整的日期字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>因为<code>toString</code>是默认的调用方法，所以如果直接读取<code>Date</code>实例，就相当于调用这个方法。</p>\n<p><strong>（2）Date.prototype.toUTCString()</strong></p>\n<p><code>toUTCString</code>方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（3）Date.prototype.toISOString()</strong></p>\n<p><code>toISOString</code>方法返回对应时间的 ISO8601 写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>toISOString</code>方法返回的总是 UTC 时区的时间。</p>\n<p><strong>（4）Date.prototype.toJSON()</strong></p>\n<p><code>toJSON</code>方法返回一个符合 JSON 格式的 ISO 日期字符串，与<code>toISOString</code>方法的返回结果完全相同。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（5）Date.prototype.toDateString()</strong></p>\n<p><code>toDateString</code>方法返回日期字符串（不含小时、分和秒）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（6）Date.prototype.toTimeString()</strong></p>\n<p><code>toTimeString</code>方法返回时间字符串（不含年月日）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（7）本地时间</strong></p>\n<p>以下三种方法，可以将 Date 实例转为表示本地时间的字符串。</p>\n<ul>\n<li><code>Date.prototype.toLocaleString()</code>：完整的本地时间。</li>\n<li><code>Date.prototype.toLocaleDateString()</code>：本地日期（不含小时、分和秒）。</li>\n<li><code>Date.prototype.toLocaleTimeString()</code>：本地时间（不含年月日）。</li>\n</ul>\n<p>下面是用法实例。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这三个方法都有两个可选的参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这两个参数中，<code>locales</code>是一个指定所用语言的字符串，<code>options</code>是一个配置对象。下面是<code>locales</code>的例子，分别采用<code>en-US</code>和<code>zh-CN</code>语言设定。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>options</code>配置对象有以下属性。</p>\n<ul>\n<li><code>dateStyle</code>：可能的值为<code>full</code>、<code>long</code>、<code>medium</code>、<code>short</code>。</li>\n<li><code>timeStyle</code>：可能的值为<code>full</code>、<code>long</code>、<code>medium</code>、<code>short</code>。</li>\n<li><code>month</code>：可能的值为<code>numeric</code>、<code>2-digit</code>、<code>long</code>、<code>short</code>、<code>narrow</code>。</li>\n<li><code>year</code>：可能的值为<code>numeric</code>、<code>2-digit</code>。</li>\n<li><code>weekday</code>：可能的值为<code>long</code>、<code>short</code>、<code>narrow</code>。</li>\n<li><code>day</code>、<code>hour</code>、<code>minute</code>、<code>second</code>：可能的值为<code>numeric</code>、<code>2-digit</code>。</li>\n<li><code>timeZone</code>：可能的值为 IANA 的时区数据库。</li>\n<li><code>timeZooneName</code>：可能的值为<code>long</code>、<code>short</code>。</li>\n<li><code>hour12</code>：24小时周期还是12小时周期，可能的值为<code>true</code>、<code>false</code>。</li>\n</ul>\n<p>下面是用法实例。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> get 类方法</h4>\n<p><code>Date</code>对象提供了一系列<code>get*</code>方法，用来获取实例对象某个方面的值。</p>\n<ul>\n<li><code>getTime()</code>：返回实例距离1970年1月1日00:00:00的毫秒数，等同于<code>valueOf</code>方法。</li>\n<li><code>getDate()</code>：返回实例对象对应每个月的几号（从1开始）。</li>\n<li><code>getDay()</code>：返回星期几，星期日为0，星期一为1，以此类推。</li>\n<li><code>getFullYear()</code>：返回四位的年份。</li>\n<li><code>getMonth()</code>：返回月份（0表示1月，11表示12月）。</li>\n<li><code>getHours()</code>：返回小时（0-23）。</li>\n<li><code>getMilliseconds()</code>：返回毫秒（0-999）。</li>\n<li><code>getMinutes()</code>：返回分钟（0-59）。</li>\n<li><code>getSeconds()</code>：返回秒（0-59）。</li>\n<li><code>getTimezoneOffset()</code>：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。</li>\n</ul>\n<p>所有这些<code>get*</code>方法返回的都是整数，不同方法返回值的范围不一样。</p>\n<ul>\n<li>分钟和秒：0 到 59</li>\n<li>小时：0 到 23</li>\n<li>星期：0（星期天）到 6（星期六）</li>\n<li>日期：1 到 31</li>\n<li>月份：0（一月）到 11（十二月）</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，最后一行返回<code>-480</code>，即 UTC 时间减去当前时间，单位是分钟。<code>-480</code>表示 UTC 比当前时间少480分钟，即当前时区比 UTC 早8个小时。</p>\n<p>下面是一个例子，计算本年度还剩下多少天。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面这些<code>get*</code>方法返回的都是当前时区的时间，<code>Date</code>对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。</p>\n<ul>\n<li><code>getUTCDate()</code></li>\n<li><code>getUTCFullYear()</code></li>\n<li><code>getUTCMonth()</code></li>\n<li><code>getUTCDay()</code></li>\n<li><code>getUTCHours()</code></li>\n<li><code>getUTCMinutes()</code></li>\n<li><code>getUTCSeconds()</code></li>\n<li><code>getUTCMilliseconds()</code></li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，实例对象<code>d</code>表示当前时区（东八时区）的1月6日0点0分0秒，这个时间对于当前时区来说是1月6日，所以<code>getDate</code>方法返回6，对于 UTC 时区来说是1月5日，所以<code>getUTCDate</code>方法返回5。</p>\n<h4> set 类方法</h4>\n<p><code>Date</code>对象提供了一系列<code>set*</code>方法，用来设置实例对象的各个方面。</p>\n<ul>\n<li><code>setDate(date)</code>：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。</li>\n<li><code>setFullYear(year [, month, date])</code>：设置四位年份。</li>\n<li><code>setHours(hour [, min, sec, ms])</code>：设置小时（0-23）。</li>\n<li><code>setMilliseconds()</code>：设置毫秒（0-999）。</li>\n<li><code>setMinutes(min [, sec, ms])</code>：设置分钟（0-59）。</li>\n<li><code>setMonth(month [, date])</code>：设置月份（0-11）。</li>\n<li><code>setSeconds(sec [, ms])</code>：设置秒（0-59）。</li>\n<li><code>setTime(milliseconds)</code>：设置毫秒时间戳。</li>\n</ul>\n<p>这些方法基本是跟<code>get*</code>方法一一对应的，但是没有<code>setDay</code>方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从0开始算的，即<code>0</code>是1月，<code>11</code>是12月。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>set*</code>方法的参数都会自动折算。以<code>setDate()</code>为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>d1.setDate(32)</code>将日期设为1月份的32号，因为1月份只有31号，所以自动折算为2月1日。<code>d2.setDate(-1)</code>表示设为上个月的倒数第二天，即12月30日。</p>\n<p><code>set</code>类方法和<code>get</code>类方法，可以结合使用，得到相对时间。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>set*</code>系列方法除了<code>setTime()</code>，都有对应的 UTC 版本，即设置 UTC 时区的时间。</p>\n<ul>\n<li><code>setUTCDate()</code></li>\n<li><code>setUTCFullYear()</code></li>\n<li><code>setUTCHours()</code></li>\n<li><code>setUTCMilliseconds()</code></li>\n<li><code>setUTCMinutes()</code></li>\n<li><code>setUTCMonth()</code></li>\n<li><code>setUTCSeconds()</code></li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，本地时区（东八时区）的1月6日0点0分，是 UTC 时区的前一天下午16点。设为 UTC 时区的22点以后，就变为本地时区的上午6点。</p>\n<h2> JSON 对象</h2>\n<h3> JSON 格式</h3>\n<p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。</p>\n<p>相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。</p>\n<p>每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值。</p>\n<p>JSON 对值的类型和格式有严格的规定。</p>\n<blockquote>\n<ol>\n<li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li>\n<li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</li>\n<li>字符串必须使用双引号表示，不能使用单引号。</li>\n<li>对象的键名必须放在双引号里面。</li>\n<li>数组或对象最后一个成员的后面，不能加逗号。</li>\n</ol>\n</blockquote>\n<p>以下都是合法的 JSON。</p>\n<div class=\"language-json\" data-ext=\"json\"></div><p>以下都是不合法的 JSON。</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，<code>null</code>、空数组和空对象都是合法的 JSON 值。</p>\n<h3> JSON 对象</h3>\n<p><code>JSON</code>对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：<code>JSON.stringify()</code>和<code>JSON.parse()</code>。</p>\n<h3> JSON.stringify()</h3>\n<h4> 基本用法</h4>\n<p><code>JSON.stringify()</code>方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>JSON.parse()</code>方法还原。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码将各种类型的值，转成 JSON 字符串。</p>\n<p>注意，对于原始类型的字符串，转换结果会带双引号。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，字符串<code>foo</code>，被转成了<code>\"\\\"foo\\\"\"</code>。这是因为将来还原的时候，内层双引号可以让 JavaScript 引擎知道，这是一个字符串，而不是其他类型的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果不是内层的双引号，将来还原的时候，引擎就无法知道原始值是布尔值还是字符串。</p>\n<p>如果对象的属性是<code>undefined</code>、函数或 XML 对象，该属性会被<code>JSON.stringify()</code>过滤。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>obj</code>的<code>a</code>属性是<code>undefined</code>，而<code>b</code>属性是一个函数，结果都被<code>JSON.stringify</code>过滤。</p>\n<p>如果数组的成员是<code>undefined</code>、函数或 XML 对象，则这些值被转成<code>null</code>。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，数组<code>arr</code>的成员是<code>undefined</code>和函数，它们都被转成了<code>null</code>。</p>\n<p>正则对象会被转成空对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>JSON.stringify()</code>方法会忽略对象的不可遍历的属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>bar</code>是<code>obj</code>对象的不可遍历属性，<code>JSON.stringify</code>方法会忽略这个属性。</p>\n<h4> 第二个参数</h4>\n<p><code>JSON.stringify()</code>方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>JSON.stringify()</code>方法的第二个参数指定，只转<code>prop1</code>和<code>prop2</code>两个属性。</p>\n<p>这个类似白名单的数组，只对对象的属性有效，对数组无效。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，第二个参数指定 JSON 格式只转<code>0</code>号属性，实际上对数组是无效的，只对对象有效。</p>\n<p>第二个参数还可以是一个函数，用来更改<code>JSON.stringify()</code>的返回值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中的<code>f</code>函数，接受两个参数，分别是被转换的对象的键名和键值。如果键值是数值，就将它乘以<code>2</code>，否则就原样返回。</p>\n<p>注意，这个处理函数是递归处理所有的键。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，对象<code>obj</code>一共会被<code>f</code>函数处理三次，输出的最后那行是<code>JSON.stringify()</code>的默认输出。第一次键名为空，键值是整个对象<code>obj</code>；第二次键名为<code>a</code>，键值是<code>{b: 1}</code>；第三次键名为<code>b</code>，键值为1。</p>\n<p>递归处理中，每一次处理的对象，都是前一次返回的值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>f</code>函数修改了对象<code>obj</code>，接着<code>JSON.stringify()</code>方法就递归处理修改后的对象<code>obj</code>。</p>\n<p>如果处理函数返回<code>undefined</code>或没有返回值，则该属性会被忽略。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>a</code>属性经过处理后，返回<code>undefined</code>，于是该属性被忽略了。</p>\n<h4> 第三个参数</h4>\n<p><code>JSON.stringify()</code>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。</p>\n<p>默认返回的是单行字符串，对于大型的 JSON 对象，可读性非常差。第三个参数使得每个属性单独占据一行，并且将每个属性前面添加指定的前缀（不超过10个字符）。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面例子中，第三个属性<code>\\t</code>在每个属性前面添加一个制表符，然后分行显示。</p>\n<p>第三个属性如果是一个数字，则表示每个属性前面添加的空格（最多不超过10个）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 参数对象的 toJSON() 方法</h4>\n<p>如果参数对象有自定义的<code>toJSON()</code>方法，那么<code>JSON.stringify()</code>会使用这个方法的返回值作为参数，而忽略原对象的其他属性。</p>\n<p>下面是一个普通的对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在，为这个对象加上<code>toJSON()</code>方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>JSON.stringify()</code>发现参数对象有<code>toJSON()</code>方法，就直接使用这个方法的返回值作为参数，而忽略原对象的其他参数。</p>\n<p><code>Date</code>对象就有一个自己的<code>toJSON()</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>JSON.stringify()</code>发现处理的是<code>Date</code>对象实例，就会调用这个实例对象的<code>toJSON()</code>方法，将该方法的返回值作为参数。</p>\n<p><code>toJSON()</code>方法的一个应用是，将正则对象自动转为字符串。因为<code>JSON.stringify()</code>默认不能转换正则对象，但是设置了<code>toJSON()</code>方法以后，就可以转换正则对象了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码在正则对象的原型上面部署了<code>toJSON()</code>方法，将其指向<code>toString()</code>方法，因此转换成 JSON 格式时，正则对象就先调用<code>toJSON()</code>方法转为字符串，然后再被<code>JSON.stringify()</code>方法处理。</p>\n<h3> JSON.parse()</h3>\n<p><code>JSON.parse()</code>方法用于将 JSON 字符串转换成对应的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果传入的字符串不是有效的 JSON 格式，<code>JSON.parse()</code>方法将报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，双引号字符串中是一个单引号字符串，因为单引号字符串不符合 JSON 格式，所以报错。</p>\n<p>为了处理解析错误，可以将<code>JSON.parse()</code>方法放在<code>try...catch</code>代码块中。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>JSON.parse()</code>方法可以接受一个处理函数，作为第二个参数，用法与<code>JSON.stringify()</code>方法类似。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>JSON.parse()</code>的第二个参数是一个函数，如果键名是<code>a</code>，该函数会将键值加上10。</p>\n<h2> Math 对象</h2>\n<h3> 静态属性</h3>\n<p><code>Math</code>对象的静态属性，提供以下一些数学常数。</p>\n<ul>\n<li><code>Math.E</code>：常数<code>e</code>。</li>\n<li><code>Math.LN2</code>：2 的自然对数。</li>\n<li><code>Math.LN10</code>：10 的自然对数。</li>\n<li><code>Math.LOG2E</code>：以 2 为底的<code>e</code>的对数。</li>\n<li><code>Math.LOG10E</code>：以 10 为底的<code>e</code>的对数。</li>\n<li><code>Math.PI</code>：常数<code>π</code>。</li>\n<li><code>Math.SQRT1_2</code>：0.5 的平方根。</li>\n<li><code>Math.SQRT2</code>：2 的平方根。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这些属性都是只读的，不能修改。</p>\n<h3> 静态方法</h3>\n<p><code>Math</code>对象提供以下一些静态方法。</p>\n<ul>\n<li><code>Math.abs()</code>：绝对值</li>\n<li><code>Math.ceil()</code>：向上取整</li>\n<li><code>Math.floor()</code>：向下取整</li>\n<li><code>Math.max()</code>：最大值</li>\n<li><code>Math.min()</code>：最小值</li>\n<li><code>Math.pow()</code>：幂运算</li>\n<li><code>Math.sqrt()</code>：平方根</li>\n<li><code>Math.log()</code>：自然对数</li>\n<li><code>Math.exp()</code>：<code>e</code>的指数</li>\n<li><code>Math.round()</code>：四舍五入</li>\n<li><code>Math.random()</code>：随机数</li>\n</ul>\n<h4> Math.abs()</h4>\n<p><code>Math.abs</code>方法返回参数值的绝对值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Math.max()，Math.min()</h4>\n<p><code>Math.max</code>方法返回参数之中最大的那个值，<code>Math.min</code>返回最小的那个值。如果参数为空, <code>Math.min</code>返回<code>Infinity</code>, <code>Math.max</code>返回<code>-Infinity</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Math.floor()，Math.ceil()</h4>\n<p><code>Math.floor</code>方法返回小于或等于参数值的最大整数（地板值）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Math.ceil</code>方法返回大于或等于参数值的最小整数（天花板值）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这两个方法可以结合起来，实现一个总是返回数值的整数部分的函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，不管正数或负数，<code>ToInteger</code>函数总是返回一个数值的整数部分。</p>\n<h4> Math.round()</h4>\n<p><code>Math.round</code>方法用于四舍五入。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，它对负数的处理（主要是对<code>0.5</code>的处理）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Math.pow()</h4>\n<p><code>Math.pow</code>方法返回以第一个参数为底数、第二个参数为指数的幂运算值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是计算圆面积的方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Math.sqrt()</h4>\n<p><code>Math.sqrt</code>方法返回参数值的平方根。如果参数是一个负值，则返回<code>NaN</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Math.log()</h4>\n<p><code>Math.log</code>方法返回以<code>e</code>为底的自然对数值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果要计算以10为底的对数，可以先用<code>Math.log</code>求出自然对数，然后除以<code>Math.LN10</code>；求以2为底的对数，可以除以<code>Math.LN2</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Math.exp()</h4>\n<p><code>Math.exp</code>方法返回常数<code>e</code>的参数次方。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Math.random()</h4>\n<p><code>Math.random()</code>返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>任意范围的随机数生成函数如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>任意范围的随机整数生成函数如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>返回随机字符的例子如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>random_str</code>函数接受一个整数作为参数，返回变量<code>ALPHABET</code>内的随机字符所组成的指定长度的字符串。</p>\n<h4> 三角函数方法</h4>\n<p><code>Math</code>对象还提供一系列三角函数方法。</p>\n<ul>\n<li><code>Math.sin()</code>：返回参数的正弦（参数为弧度值）</li>\n<li><code>Math.cos()</code>：返回参数的余弦（参数为弧度值）</li>\n<li><code>Math.tan()</code>：返回参数的正切（参数为弧度值）</li>\n<li><code>Math.asin()</code>：返回参数的反正弦（返回值为弧度值）</li>\n<li><code>Math.acos()</code>：返回参数的反余弦（返回值为弧度值）</li>\n<li><code>Math.atan()</code>：返回参数的反正切（返回值为弧度值）</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> ArrayBuffer 对象</h2>\n<h3> 简介</h3>\n<p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>\n<p>这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 JavaScript 脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像 C 语言那样，直接操作字节，将 4 个字节的 32 位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。</p>\n<p>二进制数组就是在这种背景下诞生的。它很像 C 语言的数组，允许开发者以数组下标的形式，直接操作内存，大大增强了 JavaScript 处理二进制数据的能力，使得开发者有可能通过 JavaScript 与操作系统的原生接口进行二进制通信。</p>\n<p>二进制数组由三类对象组成。</p>\n<p><strong>（1）<code>ArrayBuffer</code>对象</strong>：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。</p>\n<p><strong>（2）<code>TypedArray</code>视图</strong>：共包括 9 种类型的视图，比如<code>Uint8Array</code>（无符号 8 位整数）数组视图, <code>Int16Array</code>（16 位整数）数组视图, <code>Float32Array</code>（32 位浮点数）数组视图等等。</p>\n<p><strong>（3）<code>DataView</code>视图</strong>：可以自定义复合格式的视图，比如第一个字节是 Uint8（无符号 8 位整数）、第二、三个字节是 Int16（16 位整数）、第四个字节开始是 Float32（32 位浮点数）等等，此外还可以自定义字节序。</p>\n<p>简单说，<code>ArrayBuffer</code>对象代表原始的二进制数据，<code>TypedArray</code>视图用来读写简单类型的二进制数据，<code>DataView</code>视图用来读写复杂类型的二进制数据。</p>\n<p><code>TypedArray</code>视图支持的数据类型一共有 9 种（<code>DataView</code>视图支持除<code>Uint8C</code>以外的其他 8 种）。</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>字节长度</th>\n<th>含义</th>\n<th>对应的 C 语言类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Int8</td>\n<td>1</td>\n<td>8 位带符号整数</td>\n<td>signed char</td>\n</tr>\n<tr>\n<td>Uint8</td>\n<td>1</td>\n<td>8 位不带符号整数</td>\n<td>unsigned char</td>\n</tr>\n<tr>\n<td>Uint8C</td>\n<td>1</td>\n<td>8 位不带符号整数（自动过滤溢出）</td>\n<td>unsigned char</td>\n</tr>\n<tr>\n<td>Int16</td>\n<td>2</td>\n<td>16 位带符号整数</td>\n<td>short</td>\n</tr>\n<tr>\n<td>Uint16</td>\n<td>2</td>\n<td>16 位不带符号整数</td>\n<td>unsigned short</td>\n</tr>\n<tr>\n<td>Int32</td>\n<td>4</td>\n<td>32 位带符号整数</td>\n<td>int</td>\n</tr>\n<tr>\n<td>Uint32</td>\n<td>4</td>\n<td>32 位不带符号的整数</td>\n<td>unsigned int</td>\n</tr>\n<tr>\n<td>Float32</td>\n<td>4</td>\n<td>32 位浮点数</td>\n<td>float</td>\n</tr>\n<tr>\n<td>Float64</td>\n<td>8</td>\n<td>64 位浮点数</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p>注意，二进制数组并不是真正的数组，而是类似数组的对象。</p>\n<p>很多浏览器操作的 API，用到了二进制数组操作二进制数据，下面是其中的几个。</p>\n<ul>\n<li><a href=\"https://wangdoc.com/es6/arraybuffer.html#canvas\" target=\"_blank\" rel=\"noopener noreferrer\">Canvas</a></li>\n<li><a href=\"https://wangdoc.com/es6/arraybuffer.html#fetch-api\" target=\"_blank\" rel=\"noopener noreferrer\">Fetch API</a></li>\n<li><a href=\"https://wangdoc.com/es6/arraybuffer.html#file-api\" target=\"_blank\" rel=\"noopener noreferrer\">File API</a></li>\n<li><a href=\"https://wangdoc.com/es6/arraybuffer.html#websocket\" target=\"_blank\" rel=\"noopener noreferrer\">WebSockets</a></li>\n<li><a href=\"https://wangdoc.com/es6/arraybuffer.html#ajax\" target=\"_blank\" rel=\"noopener noreferrer\">XMLHttpRequest</a></li>\n</ul>\n<h3> ArrayBuffer 概述</h3>\n<p><code>ArrayBuffer</code>对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（<code>TypedArray</code>视图和<code>DataView</code>视图)来读写，视图的作用是以指定格式解读二进制数据。</p>\n<p><code>ArrayBuffer</code>也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码生成了一段 32 字节的内存区域，每个字节的值默认都是 0。可以看到，<code>ArrayBuffer</code>构造函数的参数是所需要的内存大小（单位字节）。</p>\n<p>为了读写这段内容，需要为它指定视图。<code>DataView</code>视图的创建，需要提供<code>ArrayBuffer</code>对象实例作为参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码对一段 32 字节的内存，建立<code>DataView</code>视图，然后以不带符号的 8 位整数格式，从头读取 8 位二进制数据，结果得到 0，因为原始内存的<code>ArrayBuffer</code>对象，默认所有位都是 0。</p>\n<p>另一种<code>TypedArray</code>视图，与<code>DataView</code>视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码对同一段内存，分别建立两种视图：32 位带符号整数（<code>Int32Array</code>构造函数）和 8 位不带符号整数（<code>Uint8Array</code>构造函数）。由于两个视图对应的是同一段内存，一个视图修改底层内存，会影响到另一个视图。</p>\n<p><code>TypedArray</code>视图的构造函数，除了接受<code>ArrayBuffer</code>实例作为参数，还可以接受普通数组作为参数，直接分配内存生成底层的<code>ArrayBuffer</code>实例，并同时完成对这段内存的赋值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码使用<code>TypedArray</code>视图的<code>Uint8Array</code>构造函数，新建一个不带符号的 8 位整数视图。可以看到，<code>Uint8Array</code>直接使用普通数组作为参数，对底层内存的赋值同时完成。</p>\n<h4> ArrayBuffer.prototype.byteLength</h4>\n<p><code>ArrayBuffer</code>实例的<code>byteLength</code>属性，返回所分配的内存区域的字节长度。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> ArrayBuffer.prototype.slice()</h4>\n<p><code>ArrayBuffer</code>实例有一个<code>slice</code>方法，允许将内存区域的一部分，拷贝生成一个新的<code>ArrayBuffer</code>对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码拷贝<code>buffer</code>对象的前 3 个字节（从 0 开始，到第 3 个字节前面结束），生成一个新的<code>ArrayBuffer</code>对象。<code>slice</code>方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个<code>ArrayBuffer</code>对象拷贝过去。</p>\n<p><code>slice</code>方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原<code>ArrayBuffer</code>对象的结尾。</p>\n<p>除了<code>slice</code>方法，<code>ArrayBuffer</code>对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p>\n<h4> ArrayBuffer.isView()</h4>\n<p><code>ArrayBuffer</code>有一个静态方法<code>isView</code>，返回一个布尔值，表示参数是否为<code>ArrayBuffer</code>的视图实例。这个方法大致相当于判断参数，是否为<code>TypedArray</code>实例或<code>DataView</code>实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> TypedArray 视图</h3>\n<h4> 概述</h4>\n<p><code>ArrayBuffer</code>对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view）。<code>ArrayBuffer</code>有两种视图，一种是<code>TypedArray</code>视图，另一种是<code>DataView</code>视图。前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。</p>\n<p>目前，<code>TypedArray</code>视图一共包括 9 种类型，每一种视图都是一种构造函数。</p>\n<ul>\n<li><strong><code>Int8Array</code></strong>：8 位有符号整数，长度 1 个字节。</li>\n<li><strong><code>Uint8Array</code></strong>：8 位无符号整数，长度 1 个字节。</li>\n<li><strong><code>Uint8ClampedArray</code></strong>：8 位无符号整数，长度 1 个字节，溢出处理不同。</li>\n<li><strong><code>Int16Array</code></strong>：16 位有符号整数，长度 2 个字节。</li>\n<li><strong><code>Uint16Array</code></strong>：16 位无符号整数，长度 2 个字节。</li>\n<li><strong><code>Int32Array</code></strong>：32 位有符号整数，长度 4 个字节。</li>\n<li><strong><code>Uint32Array</code></strong>：32 位无符号整数，长度 4 个字节。</li>\n<li><strong><code>Float32Array</code></strong>：32 位浮点数，长度 4 个字节。</li>\n<li><strong><code>Float64Array</code></strong>：64 位浮点数，长度 8 个字节。</li>\n</ul>\n<p>这 9 个构造函数生成的数组，统称为<code>TypedArray</code>视图。它们很像普通数组，都有<code>length</code>属性，都能用方括号运算符（<code>[]</code>）获取单个元素，所有数组的方法，在它们上面都能使用。普通数组与 TypedArray 数组的差异主要在以下方面。</p>\n<ul>\n<li>TypedArray 数组的所有成员，都是同一种类型。</li>\n<li>TypedArray 数组的成员是连续的，不会有空位。</li>\n<li>TypedArray 数组成员的默认值为 0。比如，<code>new Array(10)</code>返回一个普通数组，里面没有任何成员，只是 10 个空位；<code>new Uint8Array(10)</code>返回一个 TypedArray 数组，里面 10 个成员都是 0。</li>\n<li>TypedArray 数组只是一层视图，本身不储存数据，它的数据都储存在底层的<code>ArrayBuffer</code>对象之中，要获取底层对象必须使用<code>buffer</code>属性。</li>\n</ul>\n<h4> 构造函数</h4>\n<p>TypedArray 数组提供 9 种构造函数，用来生成相应类型的数组实例。</p>\n<p>构造函数有多种用法。</p>\n<p><strong>（1）TypedArray(buffer, byteOffset=0, length?)</strong></p>\n<p>同一个<code>ArrayBuffer</code>对象之上，可以根据不同的数据类型，建立多个视图。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码在一段长度为 8 个字节的内存（<code>b</code>）之上，生成了三个视图：<code>v1</code>、<code>v2</code>和<code>v3</code>。</p>\n<p>视图的构造函数可以接受三个参数：</p>\n<ul>\n<li>第一个参数（必需）：视图对应的底层<code>ArrayBuffer</code>对象。</li>\n<li>第二个参数（可选）：视图开始的字节序号，默认从 0 开始。</li>\n<li>第三个参数（可选）：视图包含的数据个数，默认直到本段内存区域结束。</li>\n</ul>\n<p>因此，<code>v1</code>、<code>v2</code>和<code>v3</code>是重叠的：<code>v1[0]</code>是一个 32 位整数，指向字节 0 ～字节 3；<code>v2[0]</code>是一个 8 位无符号整数，指向字节 2；<code>v3[0]</code>是一个 16 位整数，指向字节 2 ～字节 3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p>\n<p>注意，<code>byteOffset</code>必须与所要建立的数据类型一致，否则会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，新生成一个 8 个字节的<code>ArrayBuffer</code>对象，然后在这个对象的第一个字节，建立带符号的 16 位整数视图，结果报错。因为，带符号的 16 位整数需要两个字节，所以<code>byteOffset</code>参数必须能够被 2 整除。</p>\n<p>如果想从任意字节开始解读<code>ArrayBuffer</code>对象，必须使用<code>DataView</code>视图，因为<code>TypedArray</code>视图只提供 9 种固定的解读格式。</p>\n<p><strong>（2）TypedArray(length)</strong></p>\n<p>视图还可以不通过<code>ArrayBuffer</code>对象，直接分配内存而生成。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码生成一个 8 个成员的<code>Float64Array</code>数组（共 64 字节），然后依次对每个成员赋值。这时，视图构造函数的参数就是成员的个数。可以看到，视图数组的赋值操作与普通数组的操作毫无两样。</p>\n<p><strong>（3）TypedArray(typedArray)</strong></p>\n<p>TypedArray 数组的构造函数，可以接受另一个<code>TypedArray</code>实例作为参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Int8Array</code>构造函数接受一个<code>Uint8Array</code>实例作为参数。</p>\n<p>注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，数组<code>y</code>是以数组<code>x</code>为模板而生成的，当<code>x</code>变动的时候，<code>y</code>并没有变动。</p>\n<p>如果想基于同一段内存，构造不同的视图，可以采用下面的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（4）TypedArray(arrayLikeObject)</strong></p>\n<p>构造函数的参数也可以是一个普通数组，然后直接生成<code>TypedArray</code>实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，这时<code>TypedArray</code>视图会重新开辟内存，不会在原数组的内存上建立视图。</p>\n<p>上面代码从一个普通的数组，生成一个 8 位无符号整数的<code>TypedArray</code>实例。</p>\n<p>TypedArray 数组也可以转换回普通数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 数组方法</h4>\n<p>普通数组的操作方法和属性，对 TypedArray 数组完全适用。</p>\n<ul>\n<li><code>TypedArray.prototype.copyWithin(target, start[, end = this.length])</code></li>\n<li><code>TypedArray.prototype.entries()</code></li>\n<li><code>TypedArray.prototype.every(callbackfn, thisArg?)</code></li>\n<li><code>TypedArray.prototype.fill(value, start=0, end=this.length)</code></li>\n<li><code>TypedArray.prototype.filter(callbackfn, thisArg?)</code></li>\n<li><code>TypedArray.prototype.find(predicate, thisArg?)</code></li>\n<li><code>TypedArray.prototype.findIndex(predicate, thisArg?)</code></li>\n<li><code>TypedArray.prototype.forEach(callbackfn, thisArg?)</code></li>\n<li><code>TypedArray.prototype.indexOf(searchElement, fromIndex=0)</code></li>\n<li><code>TypedArray.prototype.join(separator)</code></li>\n<li><code>TypedArray.prototype.keys()</code></li>\n<li><code>TypedArray.prototype.lastIndexOf(searchElement, fromIndex?)</code></li>\n<li><code>TypedArray.prototype.map(callbackfn, thisArg?)</code></li>\n<li><code>TypedArray.prototype.reduce(callbackfn, initialValue?)</code></li>\n<li><code>TypedArray.prototype.reduceRight(callbackfn, initialValue?)</code></li>\n<li><code>TypedArray.prototype.reverse()</code></li>\n<li><code>TypedArray.prototype.slice(start=0, end=this.length)</code></li>\n<li><code>TypedArray.prototype.some(callbackfn, thisArg?)</code></li>\n<li><code>TypedArray.prototype.sort(comparefn)</code></li>\n<li><code>TypedArray.prototype.toLocaleString(reserved1?, reserved2?)</code></li>\n<li><code>TypedArray.prototype.toString()</code></li>\n<li><code>TypedArray.prototype.values()</code></li>\n</ul>\n<p>上面所有方法的用法，请参阅数组方法的介绍，这里不再重复了。</p>\n<p>注意，TypedArray 数组没有<code>concat</code>方法。如果想要合并多个 TypedArray 数组，可以用下面这个函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，TypedArray 数组与普通数组一样，部署了 Iterator 接口，所以可以被遍历。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 字节序</h4>\n<p>字节序指的是数值在内存中的表示方式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码生成一个 16 字节的<code>ArrayBuffer</code>对象，然后在它的基础上，建立了一个 32 位整数的视图。由于每个 32 位整数占据 4 个字节，所以一共可以写入 4 个整数，依次为 0，2，4，6。</p>\n<p>如果在这段数据上接着建立一个 16 位整数的视图，则可以读出完全不一样的结果。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由于每个 16 位整数占据 2 个字节，所以整个<code>ArrayBuffer</code>对象现在分成 8 段。然后，由于 x86 体系的计算机都采用小端字节序（little endian），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，所以就得到了上面的结果。</p>\n<p>比如，一个占据四个字节的 16 进制数<code>0x12345678</code>，决定其大小的最重要的字节是“12”，最不重要的是“78”。小端字节序将最不重要的字节排在前面，储存顺序就是<code>78563412</code>；大端字节序则完全相反，将最重要的字节排在前面，储存顺序就是<code>12345678</code>。目前，所有个人电脑几乎都是小端字节序，所以 TypedArray 数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数据。</p>\n<p>这并不意味大端字节序不重要，事实上，很多网络设备和特定的操作系统采用的是大端字节序。这就带来一个严重的问题：如果一段数据是大端字节序，TypedArray 数组将无法正确解析，因为它只能处理小端字节序！为了解决这个问题，JavaScript 引入<code>DataView</code>对象，可以设定字节序，下文会详细介绍。</p>\n<p>下面是另一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面的函数可以用来判断，当前视图是小端字节序，还是大端字节序。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>总之，与普通数组相比，TypedArray 数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速度快得多。</p>\n<h4> BYTES_PER_ELEMENT 属性</h4>\n<p>每一种视图的构造函数，都有一个<code>BYTES_PER_ELEMENT</code>属性，表示这种数据类型占据的字节数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这个属性在<code>TypedArray</code>实例上也能获取，即有<code>TypedArray.prototype.BYTES_PER_ELEMENT</code>。</p>\n<h4> ArrayBuffer 与字符串的互相转换</h4>\n<p><code>ArrayBuffer</code> 和字符串的相互转换，使用原生 <code>TextEncoder</code> 和 <code>TextDecoder</code> 方法。为了便于说明用法，下面的代码都按照 TypeScript 的用法，给出了类型签名。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>ab2str()</code>的第二个参数<code>outputEncoding</code>给出了输出编码的编码，一般保持默认值（<code>utf-8</code>），其他可选值参见<a href=\"https://encoding.spec.whatwg.org/\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a>或 <a href=\"https://nodejs.org/api/util.html#util_whatwg_supported_encodings\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js 文档</a>。</p>\n<h4> 溢出</h4>\n<p>不同的视图类型，所能容纳的数值范围是确定的。超出这个范围，就会出现溢出。比如，8 位视图只能容纳一个 8 位的二进制值，如果放入一个 9 位的值，就会溢出。</p>\n<p>TypedArray 数组的溢出处理规则，简单来说，就是抛弃溢出的位，然后按照视图类型进行解释。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>uint8</code>是一个 8 位视图，而 256 的二进制形式是一个 9 位的值<code>100000000</code>，这时就会发生溢出。根据规则，只会保留后 8 位，即<code>00000000</code>。<code>uint8</code>视图的解释规则是无符号的 8 位整数，所以<code>00000000</code>就是<code>0</code>。</p>\n<p>负数在计算机内部采用“2 的补码”表示，也就是说，将对应的正数值进行否运算，然后加<code>1</code>。比如，<code>-1</code>对应的正值是<code>1</code>，进行否运算以后，得到<code>11111110</code>，再加上<code>1</code>就是补码形式<code>11111111</code>。<code>uint8</code>按照无符号的 8 位整数解释<code>11111111</code>，返回结果就是<code>255</code>。</p>\n<p>一个简单转换规则，可以这样表示。</p>\n<ul>\n<li>正向溢出（overflow）：当输入值大于当前数据类型的最大值，结果等于当前数据类型的最小值加上余值，再减去 1。</li>\n<li>负向溢出（underflow）：当输入值小于当前数据类型的最小值，结果等于当前数据类型的最大值减去余值的绝对值，再加上 1。</li>\n</ul>\n<p>上面的“余值”就是模运算的结果，即 JavaScript 里面的<code>%</code>运算符的结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，12 除以 4 是没有余值的，而除以 5 会得到余值 2。</p>\n<p>请看下面的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，<code>int8</code>是一个带符号的 8 位整数视图，它的最大值是 127，最小值是-128。输入值为<code>128</code>时，相当于正向溢出<code>1</code>，根据“最小值加上余值（128 除以 127 的余值是 1），再减去 1”的规则，就会返回<code>-128</code>；输入值为<code>-129</code>时，相当于负向溢出<code>1</code>，根据“最大值减去余值的绝对值（-129 除以-128 的余值的绝对值是 1），再加上 1”的规则，就会返回<code>127</code>。</p>\n<p><code>Uint8ClampedArray</code>视图的溢出规则，与上面的规则不同。它规定，凡是发生正向溢出，该值一律等于当前数据类型的最大值，即 255；如果发生负向溢出，该值一律等于当前数据类型的最小值，即 0。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，<code>uint8C</code>是一个<code>Uint8ClampedArray</code>视图，正向溢出时都返回 255，负向溢出都返回 0。</p>\n<h4> TypedArray.prototype.buffer</h4>\n<p><code>TypedArray</code>实例的<code>buffer</code>属性，返回整段内存区域对应的<code>ArrayBuffer</code>对象。该属性为只读属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>a</code>视图对象和<code>b</code>视图对象，对应同一个<code>ArrayBuffer</code>对象，即同一段内存。</p>\n<h4> TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset</h4>\n<p><code>byteLength</code>属性返回 TypedArray 数组占据的内存长度，单位为字节。<code>byteOffset</code>属性返回 TypedArray 数组从底层<code>ArrayBuffer</code>对象的哪个字节开始。这两个属性都是只读属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> TypedArray.prototype.length</h4>\n<p><code>length</code>属性表示 <code>TypedArray</code> 数组含有多少个成员。注意将 <code>length</code> 属性和 <code>byteLength</code> 属性区分，前者是成员长度，后者是字节长度。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> TypedArray.prototype.set()</h4>\n<p>TypedArray 数组的<code>set</code>方法用于复制数组（普通数组或 TypedArray 数组），也就是将一段内容完全复制到另一段内存。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码复制<code>a</code>数组的内容到<code>b</code>数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。</p>\n<p><code>set</code>方法还可以接受第二个参数，表示从<code>b</code>对象的哪一个成员开始复制<code>a</code>对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>b</code>数组比<code>a</code>数组多两个成员，所以从<code>b[2]</code>开始复制。</p>\n<h4> TypedArray.prototype.subarray()</h4>\n<p><code>subarray</code>方法是对于 TypedArray 数组的一部分，再建立一个新的视图。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>subarray</code>方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的<code>a.subarray(2,3)</code>，意味着 b 只包含<code>a[2]</code>一个成员，字节长度为 2。</p>\n<h4> TypedArray.prototype.slice()</h4>\n<p>TypeArray 实例的<code>slice</code>方法，可以返回一个指定位置的新的<code>TypedArray</code>实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>ui8</code>是 8 位无符号整数数组视图的一个实例。它的<code>slice</code>方法可以从当前视图之中，返回一个新的视图实例。</p>\n<p><code>slice</code>方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1 为倒数第一个位置，-2 表示倒数第二个位置，以此类推。</p>\n<h4> TypedArray.of()</h4>\n<p>TypedArray 数组的所有构造函数，都有一个静态方法<code>of</code>，用于将参数转为一个<code>TypedArray</code>实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面三种方法都会生成同样一个 TypedArray 数组。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> TypedArray.from()</h4>\n<p>静态方法<code>from</code>接受一个可遍历的数据结构（比如数组）作为参数，返回一个基于这个结构的<code>TypedArray</code>实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这个方法还可以将一种<code>TypedArray</code>实例，转为另一种。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>from</code>方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似<code>map</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的例子中，<code>from</code>方法没有发生溢出，这说明遍历不是针对原来的 8 位整数数组。也就是说，<code>from</code>会将第一个参数指定的 TypedArray 数组，拷贝到另一段内存之中，处理之后再将结果转成指定的数组格式。</p>\n<h3> 复合视图</h3>\n<p>由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这叫做“复合视图”。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将一个 24 字节长度的<code>ArrayBuffer</code>对象，分成三个部分：</p>\n<ul>\n<li>字节 0 到字节 3：1 个 32 位无符号整数</li>\n<li>字节 4 到字节 19：16 个 8 位整数</li>\n<li>字节 20 到字节 23：1 个 32 位浮点数</li>\n</ul>\n<p>这种数据结构可以用如下的 C 语言描述：</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> DataView 视图</h3>\n<p>如果一段数据包括多种类型（比如服务器传来的 HTTP 数据），这时除了建立<code>ArrayBuffer</code>对象的复合视图以外，还可以通过<code>DataView</code>视图进行操作。</p>\n<p><code>DataView</code>视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，<code>ArrayBuffer</code>对象的各种<code>TypedArray</code>视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而<code>DataView</code>视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>\n<p><code>DataView</code>视图本身也是构造函数，接受一个<code>ArrayBuffer</code>对象作为参数，生成视图。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>DataView</code>实例有以下属性，含义与<code>TypedArray</code>实例的同名方法相同。</p>\n<ul>\n<li><code>DataView.prototype.buffer</code>：返回对应的 ArrayBuffer 对象</li>\n<li><code>DataView.prototype.byteLength</code>：返回占据的内存字节长度</li>\n<li><code>DataView.prototype.byteOffset</code>：返回当前视图从对应的 ArrayBuffer 对象的哪个字节开始</li>\n</ul>\n<p><code>DataView</code>实例提供 8 个方法读取内存。</p>\n<ul>\n<li><strong><code>getInt8</code></strong>：读取 1 个字节，返回一个 8 位整数。</li>\n<li><strong><code>getUint8</code></strong>：读取 1 个字节，返回一个无符号的 8 位整数。</li>\n<li><strong><code>getInt16</code></strong>：读取 2 个字节，返回一个 16 位整数。</li>\n<li><strong><code>getUint16</code></strong>：读取 2 个字节，返回一个无符号的 16 位整数。</li>\n<li><strong><code>getInt32</code></strong>：读取 4 个字节，返回一个 32 位整数。</li>\n<li><strong><code>getUint32</code></strong>：读取 4 个字节，返回一个无符号的 32 位整数。</li>\n<li><strong><code>getFloat32</code></strong>：读取 4 个字节，返回一个 32 位浮点数。</li>\n<li><strong><code>getFloat64</code></strong>：读取 8 个字节，返回一个 64 位浮点数。</li>\n</ul>\n<p>这一系列<code>get</code>方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码读取了<code>ArrayBuffer</code>对象的前 5 个字节，其中有一个 8 位整数和两个十六位整数。</p>\n<p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，<code>DataView</code>的<code>get</code>方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在<code>get</code>方法的第二个参数指定<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>DataView 视图提供 8 个方法写入内存。</p>\n<ul>\n<li><strong><code>setInt8</code></strong>：写入 1 个字节的 8 位整数。</li>\n<li><strong><code>setUint8</code></strong>：写入 1 个字节的 8 位无符号整数。</li>\n<li><strong><code>setInt16</code></strong>：写入 2 个字节的 16 位整数。</li>\n<li><strong><code>setUint16</code></strong>：写入 2 个字节的 16 位无符号整数。</li>\n<li><strong><code>setInt32</code></strong>：写入 4 个字节的 32 位整数。</li>\n<li><strong><code>setUint32</code></strong>：写入 4 个字节的 32 位无符号整数。</li>\n<li><strong><code>setFloat32</code></strong>：写入 4 个字节的 32 位浮点数。</li>\n<li><strong><code>setFloat64</code></strong>：写入 8 个字节的 64 位浮点数。</li>\n</ul>\n<p>这一系列<code>set</code>方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，<code>false</code>或者<code>undefined</code>表示使用大端字节序写入，<code>true</code>表示使用小端字节序写入。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果返回<code>true</code>，就是小端字节序；如果返回<code>false</code>，就是大端字节序。</p>\n<h3> 二进制数组的应用</h3>\n<p>大量的 Web API 用到了<code>ArrayBuffer</code>对象和它的视图对象。</p>\n<h4> AJAX</h4>\n<p>传统上，服务器通过 AJAX 操作只能返回文本数据，即<code>responseType</code>属性默认为<code>text</code>。<code>XMLHttpRequest</code>第二版<code>XHR2</code>允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（<code>responseType</code>）设为<code>arraybuffer</code>；如果不知道，就设为<code>blob</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果知道传回来的是 32 位整数，可以像下面这样处理。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> Canvas</h4>\n<p>网页<code>Canvas</code>元素输出的二进制像素数据，就是 TypedArray 数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>需要注意的是，上面代码的<code>uint8ClampedArray</code>虽然是一个 TypedArray 数组，但是它的视图类型是一种针对<code>Canvas</code>元素的专有类型<code>Uint8ClampedArray</code>。这个视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的 8 位整数，即只能取值 0 ～ 255，而且发生运算的时候自动过滤高位溢出。这为图像处理带来了巨大的方便。</p>\n<p>举例来说，如果把像素的颜色值设为<code>Uint8Array</code>类型，那么乘以一个 gamma 值的时候，就必须这样计算：</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>因为<code>Uint8Array</code>类型对于大于 255 的运算结果（比如<code>0xFF+1</code>），会自动变为<code>0x00</code>，所以图像处理必须要像上面这样算。这样做很麻烦，而且影响性能。如果将颜色值设为<code>Uint8ClampedArray</code>类型，计算就简化许多。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Uint8ClampedArray</code>类型确保将小于 0 的值设为 0，将大于 255 的值设为 255。注意，IE 10 不支持该类型。</p>\n<h4> WebSocket</h4>\n<p><code>WebSocket</code>可以通过<code>ArrayBuffer</code>，发送或接收二进制数据。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> Fetch API</h4>\n<p>Fetch API 取回的数据，就是<code>ArrayBuffer</code>对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> File API</h4>\n<p>如果知道一个文件的二进制数据类型，也可以将这个文件读取为<code>ArrayBuffer</code>对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面以处理 bmp 文件为例。假定<code>file</code>变量是一个指向 bmp 文件的文件对象，首先读取文件。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>然后，定义处理图像的回调函数：先在二进制数据之上建立一个<code>DataView</code>视图，再建立一个<code>bitmap</code>对象，用于存放处理后的数据，最后将图像展示在<code>Canvas</code>元素之中。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>具体处理图像数据时，先处理 bmp 的文件头。具体每个文件头的格式和定义，请参阅有关资料。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>接着处理图像元信息部分。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后处理图像本身的像素信息。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>至此，图像文件的数据全部处理完成。下一步，可以根据需要，进行图像变形，或者转换格式，或者展示在<code>Canvas</code>网页元素之中。</p>\n<h3> SharedArrayBuffer</h3>\n<p>JavaScript 是单线程的，Web worker 引入了多线程：主线程用来与用户互动，Worker 线程用来承担计算任务。每个线程的数据都是隔离的，通过<code>postMessage()</code>通信。下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，主线程新建了一个 Worker 线程。该线程与主线程之间会有一个通信渠道，主线程通过<code>w.postMessage</code>向 Worker 线程发消息，同时通过<code>message</code>事件监听 Worker 线程的回应。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，主线程先发一个消息<code>hi</code>，然后在监听到 Worker 线程的回应后，就将其打印出来。</p>\n<p>Worker 线程也是通过监听<code>message</code>事件，来获取主线程发来的消息，并作出反应。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>线程之间的数据交换可以是各种格式，不仅仅是字符串，也可以是二进制数据。这种交换采用的是复制机制，即一个进程将需要分享的数据复制一份，通过<code>postMessage</code>方法交给另一个进程。如果数据量比较大，这种通信的效率显然比较低。很容易想到，这时可以留出一块内存区域，由主线程与 Worker 线程共享，两方都可以读写，那么就会大大提高效率，协作起来也会比较简单（不像<code>postMessage</code>那么麻烦）。</p>\n<p>ES2017 引入<a href=\"https://github.com/tc39/ecmascript_sharedmem/blob/master/TUTORIAL.md\" target=\"_blank\" rel=\"noopener noreferrer\"><code>SharedArrayBuffer</code></a>，允许 Worker 线程与主线程共享同一块内存。<code>SharedArrayBuffer</code>的 API 与<code>ArrayBuffer</code>一模一样，唯一的区别是后者无法共享数据。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>postMessage</code>方法的参数是<code>SharedArrayBuffer</code>对象。</p>\n<p>Worker 线程从事件的<code>data</code>属性上面取到数据。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>共享内存也可以在 Worker 线程创建，发给主线程。</p>\n<p><code>SharedArrayBuffer</code>与<code>ArrayBuffer</code>一样，本身是无法读写的，必须在上面建立视图，然后通过视图读写。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Worker 线程收到数据后的处理如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Atomics 对象</h3>\n<p>多线程共享内存，最大的问题就是如何防止两个线程同时修改某个地址，或者说，当一个线程修改共享内存以后，必须有一个机制让其他线程同步。SharedArrayBuffer API 提供<code>Atomics</code>对象，保证所有共享内存的操作都是“原子性”的，并且可以在所有线程内同步。</p>\n<p>什么叫“原子性操作”呢？现代编程语言中，一条普通的命令被编译器处理以后，会变成多条机器指令。如果是单线程运行，这是没有问题的；多线程环境并且共享内存时，就会出问题，因为这一组机器指令的运行期间，可能会插入其他线程的指令，从而导致运行结果出错。请看下面的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，主线程的原始顺序是先对 42 号位置赋值，再对 37 号位置赋值。但是，编译器和 CPU 为了优化，可能会改变这两个操作的执行顺序（因为它们之间互不依赖），先对 37 号位置赋值，再对 42 号位置赋值。而执行到一半的时候，Worker 线程可能就会来读取数据，导致打印出<code>123456</code>和<code>191</code>。</p>\n<p>下面是另一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，Worker 线程直接改写共享内存<code>ia[112]++</code>是不正确的。因为这行语句会被编译成多条机器指令，这些指令之间无法保证不会插入其他进程的指令。请设想如果两个线程同时<code>ia[112]++</code>，很可能它们得到的结果都是不正确的。</p>\n<p><code>Atomics</code>对象就是为了解决这个问题而提出，它可以保证一个操作所对应的多条机器指令，一定是作为一个整体运行的，中间不会被打断。也就是说，它所涉及的操作都可以看作是原子性的单操作，这可以避免线程竞争，提高多线程共享内存时的操作安全。所以，<code>ia[112]++</code>要改写成<code>Atomics.add(ia, 112, 1)</code>。</p>\n<p><code>Atomics</code>对象提供多种方法。</p>\n<p><strong>（1）Atomics.store()，Atomics.load()</strong></p>\n<p><code>store()</code>方法用来向共享内存写入数据，<code>load()</code>方法用来从共享内存读出数据。比起直接的读写操作，它们的好处是保证了读写操作的原子性。</p>\n<p>此外，它们还用来解决一个问题：多个线程使用共享内存的某个位置作为开关（flag），一旦该位置的值变了，就执行特定操作。这时，必须保证该位置的赋值操作，一定是在它前面的所有可能会改写内存的操作结束后执行；而该位置的取值操作，一定是在它后面所有可能会读取该位置的操作开始之前执行。<code>store()</code>方法和<code>load()</code>方法就能做到这一点，编译器不会为了优化，而打乱机器指令的执行顺序。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>store()</code>方法接受三个参数：<code>typedArray</code>对象（SharedArrayBuffer 的视图）、位置索引和值，返回<code>typedArray[index]</code>的值。<code>load()</code>方法只接受两个参数：<code>typedArray</code>对象（SharedArrayBuffer 的视图）和位置索引，也是返回<code>typedArray[index]</code>的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，主线程的<code>Atomics.store()</code>向 42 号位置的赋值，一定是早于 37 位置的赋值。只要 37 号位置等于 163，Worker 线程就不会终止循环，而对 37 号位置和 42 号位置的取值，一定是在<code>Atomics.load()</code>操作之后。</p>\n<p>下面是另一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，主线程用<code>Atomics.store()</code>方法写入数据。下面是 Worker 线程用<code>Atomics.load()</code>方法读取数据。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）Atomics.exchange()</strong></p>\n<p>Worker 线程如果要写入数据，可以使用上面的<code>Atomics.store()</code>方法，也可以使用<code>Atomics.exchange()</code>方法。它们的区别是，<code>Atomics.store()</code>返回写入的值，而<code>Atomics.exchange()</code>返回被替换的值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码将共享内存的偶数位置的值改成<code>1</code>，奇数位置的值改成<code>2</code>。</p>\n<p><strong>（3）Atomics.wait()，Atomics.notify()</strong></p>\n<p>使用<code>while</code>循环等待主线程的通知，不是很高效，如果用在主线程，就会造成卡顿，<code>Atomics</code>对象提供了<code>wait()</code>和<code>notify()</code>两个方法用于等待通知。这两个方法相当于锁内存，即在一个线程进行操作时，让其他线程休眠（建立锁），等到操作结束，再唤醒那些休眠的线程（解除锁）。</p>\n<p><code>Atomics.notify()</code>方法以前叫做<code>Atomics.wake()</code>，后来进行了改名。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Atomics.wait()</code>方法等同于告诉 Worker 线程，只要满足给定条件（<code>sharedArray</code>的<code>0</code>号位置等于<code>50</code>），就在这一行 Worker 线程进入休眠。</p>\n<p>主线程一旦更改了指定位置的值，就可以唤醒 Worker 线程。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>sharedArray</code>的<code>0</code>号位置改为<code>100</code>，然后就执行<code>Atomics.notify()</code>方法，唤醒在<code>sharedArray</code>的<code>0</code>号位置休眠队列里的一个线程。</p>\n<p><code>Atomics.wait()</code>方法的使用格式如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>它的四个参数含义如下。</p>\n<ul>\n<li>sharedArray：共享内存的视图数组。</li>\n<li>index：视图数据的位置（从0开始）。</li>\n<li>value：该位置的预期值。一旦实际值等于预期值，就进入休眠。</li>\n<li>timeout：整数，表示过了这个时间以后，就自动唤醒，单位毫秒。该参数可选，默认值是<code>Infinity</code>，即无限期的休眠，只有通过<code>Atomics.notify()</code>方法才能唤醒。</li>\n</ul>\n<p><code>Atomics.wait()</code>的返回值是一个字符串，共有三种可能的值。如果<code>sharedArray[index]</code>不等于<code>value</code>，就返回字符串<code>not-equal</code>，否则就进入休眠。如果<code>Atomics.notify()</code>方法唤醒，就返回字符串<code>ok</code>；如果因为超时唤醒，就返回字符串<code>timed-out</code>。</p>\n<p><code>Atomics.notify()</code>方法的使用格式如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>它的三个参数含义如下。</p>\n<ul>\n<li>sharedArray：共享内存的视图数组。</li>\n<li>index：视图数据的位置（从0开始）。</li>\n<li>count：需要唤醒的 Worker 线程的数量，默认为<code>Infinity</code>。</li>\n</ul>\n<p><code>Atomics.notify()</code>方法一旦唤醒休眠的 Worker 线程，就会让它继续往下运行。</p>\n<p>请看一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，视图数组<code>ia</code>的第 37 号位置，原来的值是<code>163</code>。Worker 线程使用<code>Atomics.wait()</code>方法，指定只要<code>ia[37]</code>等于<code>163</code>，就进入休眠状态。主线程使用<code>Atomics.store()</code>方法，将<code>123456</code>写入<code>ia[37]</code>，然后使用<code>Atomics.notify()</code>方法唤醒 Worker 线程。</p>\n<p>另外，基于<code>wait</code>和<code>notify</code>这两个方法的锁内存实现，可以看 Lars T Hansen 的 <a href=\"https://github.com/lars-t-hansen/js-lock-and-condition\" target=\"_blank\" rel=\"noopener noreferrer\">js-lock-and-condition</a> 这个库。</p>\n<p>注意，浏览器的主线程不宜设置休眠，这会导致用户失去响应。而且，主线程实际上会拒绝进入休眠。</p>\n<p><strong>（4）运算方法</strong></p>\n<p>共享内存上面的某些运算是不能被打断的，即不能在运算过程中，让其他线程改写内存上面的值。Atomics 对象提供了一些运算方法，防止数据被改写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Atomics.add</code>用于将<code>value</code>加到<code>sharedArray[index]</code>，返回<code>sharedArray[index]</code>旧的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Atomics.sub</code>用于将<code>value</code>从<code>sharedArray[index]</code>减去，返回<code>sharedArray[index]</code>旧的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Atomics.and</code>用于将<code>value</code>与<code>sharedArray[index]</code>进行位运算<code>and</code>，放入<code>sharedArray[index]</code>，并返回旧的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Atomics.or</code>用于将<code>value</code>与<code>sharedArray[index]</code>进行位运算<code>or</code>，放入<code>sharedArray[index]</code>，并返回旧的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Atomic.xor</code>用于将<code>vaule</code>与<code>sharedArray[index]</code>进行位运算<code>xor</code>，放入<code>sharedArray[index]</code>，并返回旧的值。</p>\n<p><strong>（5）其他方法</strong></p>\n<p><code>Atomics</code>对象还有以下方法。</p>\n<ul>\n<li><code>Atomics.compareExchange(sharedArray, index, oldval, newval)</code>：如果<code>sharedArray[index]</code>等于<code>oldval</code>，就写入<code>newval</code>，返回<code>oldval</code>。</li>\n<li><code>Atomics.isLockFree(size)</code>：返回一个布尔值，表示<code>Atomics</code>对象是否可以处理某个<code>size</code>的内存锁定。如果返回<code>false</code>，应用程序就需要自己来实现锁定。</li>\n</ul>\n<p><code>Atomics.compareExchange</code>的一个用途是，从 SharedArrayBuffer 读取一个值，然后对该值进行某个操作，操作结束以后，检查一下 SharedArrayBuffer 里面原来那个值是否发生变化（即被其他线程改写过）。如果没有改写过，就将它写回原来的位置，否则读取新的值，再重头进行一次操作。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "3.数据类型的检验和转换",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses3.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses3.html",
      "summary": "数据类型的检验 概述 JavaScript 有三种方法，可以确定一个值到底是什么类型。 typeof运算符; instanceof运算符; Object.prototype.toString方法; 三种方法各有不同，我们将一一介绍。 typeof 运算符 基本用法 typeof运算符可以返回一个值的数据类型。 数值、字符串、布尔值分别返回number、...",
      "content_html": "<h1> 数据类型的检验和转换</h1>\n<h2> 数据类型的检验</h2>\n<h3> 概述</h3>\n<p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p>\n<ul>\n<li><code>typeof</code>运算符</li>\n<li><code>instanceof</code>运算符</li>\n<li><code>Object.prototype.toString</code>方法</li>\n</ul>\n<p>三种方法各有不同，我们将一一介绍。</p>\n<h3> typeof 运算符</h3>\n<h4> 基本用法</h4>\n<p><code>typeof</code>运算符可以返回一个值的数据类型。</p>\n<p>数值、字符串、布尔值分别返回<code>number</code>、<code>string</code>、<code>boolean</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>函数返回<code>function</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>undefined</code>返回<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>null</code>返回<code>object</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>null</code>的类型是<code>object</code>，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑<code>null</code>，只把它当作<code>object</code>的一种特殊值。后来<code>null</code>独立出来，作为一种单独的数据类型，为了兼容以前的代码，<code>typeof null</code>返回<code>object</code>就没法改变了。</p>\n<p>对象返回<code>object</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，数组和空数组（<code>[]</code>）的类型也是<code>object</code>，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。</p>\n<h4> 应用</h4>\n<p><code>typeof</code>可以用来检查一个没有声明的变量，而不报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，变量<code>v</code>没有用<code>var</code>命令声明，直接使用就会报错。但是，放在<code>typeof</code>后面，就不报错了，而是返回<code>undefined</code>。</p>\n<p>实际编程中，这个特点通常用在判断语句。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 总结</h4>\n<p><code>typeof</code>可以用来判断和区分<code>number</code>、<code>string</code>、<code>boolean</code>、<code>function</code>，但<code>null</code>、<code>Arrray</code>、<code>Object</code>一律判断成<code>Object</code>类型。</p>\n<h3> instanceof 运算符</h3>\n<h4> 基本用法</h4>\n<p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>v</code>是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>。</p>\n<p><strong><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。</strong></p>\n<p>因此，下面两种写法是等价的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Vehicle</code>是对象<code>v</code>的构造函数，它的原型对象是<code>Vehicle.prototype</code>，<code>isPrototypeOf()</code>方法是 JavaScript 提供的原生方法，用于检查某个对象是否为另一个对象的原型，详细解释见后文。</p>\n<p><strong>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>。</p>\n<h4> 注意点</h4>\n<p><strong><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。</strong></p>\n<p>有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create()</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。这是唯一的<code>instanceof</code>运算符判断会失真的情况（一个对象的原型是<code>null</code>）。</p>\n<h4> 判断值的类型</h4>\n<p><code>instanceof</code>运算符的一个用处，是判断值的类型。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象。</p>\n<p>注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>。</p>\n<p>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 其他应用</h4>\n<p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，忘了加<code>new</code>命令的问题。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p>\n<h4> 总结</h4>\n<p><code>instanceof</code>运算符只能用于对象，用来区分<code>Array</code>、<code>Object</code>、<code>null</code>，不能用来判断原始类型。</p>\n<h3> Object.prototype.toString()</h3>\n<h4> toString() 方法作用</h4>\n<p><strong><code>toString</code>方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，对于一个对象调用<code>toString</code>方法，会返回字符串<code>[object Object]</code>，该字符串说明对象的类型。</p>\n<p>字符串<code>[object Object]</code>本身没有太大的用处，但是通过自定义<code>toString</code>方法，可以让对象在自动类型转换时，得到想要的字符串形式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，当对象用于字符串加法时，会自动调用<code>toString</code>方法。由于自定义了<code>toString</code>方法，所以返回字符串<code>hello world</code>。</p>\n<p><strong>数组、字符串、函数、Date 对象都分别部署了自定义的<code>toString</code>方法，覆盖了<code>Object.prototype.toString</code>方法。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，数组、字符串、函数、Date 对象调用<code>toString</code>方法，并不会返回<code>[object Object]</code>，因为它们都自定义了<code>toString</code>方法，覆盖原始方法。</p>\n<h4> 用作判断数据类型</h4>\n<p><strong><code>Object.prototype.toString</code>方法返回对象的类型字符串，因此可以用来判断一个值的类型。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码调用空对象的<code>toString</code>方法，结果返回一个字符串<code>object Object</code>，其中第二个<code>Object</code>表示该值的构造函数。</strong></p>\n<p>这是一个十分有用的判断数据类型的方法。</p>\n<p><strong>由于实例对象可能会自定义<code>toString</code>方法，覆盖掉<code>Object.prototype.toString</code>方法，所以为了得到类型字符串，最好直接使用<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示对<code>value</code>这个值调用<code>Object.prototype.toString</code>方法。</p>\n<p><strong>不同数据类型的<code>Object.prototype.toString</code>方法返回值如下：</strong></p>\n<ul>\n<li>数值：返回<code>[object Number]</code>。</li>\n<li>字符串：返回<code>[object String]</code>。</li>\n<li>布尔值：返回<code>[object Boolean]</code>。</li>\n<li>undefined：返回<code>[object Undefined]</code>。</li>\n<li>null：返回<code>[object Null]</code>。</li>\n<li>数组：返回<code>[object Array]</code>。</li>\n<li>arguments 对象：返回<code>[object Arguments]</code>。</li>\n<li>函数：返回<code>[object Function]</code>。</li>\n<li>Error 对象：返回<code>[object Error]</code>。</li>\n<li>Date 对象：返回<code>[object Date]</code>。</li>\n<li>RegExp 对象：返回<code>[object RegExp]</code>。</li>\n<li>其他对象：返回<code>[object Object]</code>。</li>\n</ul>\n<p>这就是说，<code>Object.prototype.toString</code>可以看出一个值到底是什么类型。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>利用这个特性，可以写出一个比<code>typeof</code>运算符更准确的类型判断函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面这个<code>type</code>函数的基础上，还可以加上专门判断某种类型数据的方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 总结</h4>\n<p>基于以上的分析和对比，如果需要判断出精确的数据类型，请务必使用<code>Object.prototype.toString</code>。</p>\n<h2> 数据类型的转换</h2>\n<h3> 概述</h3>\n<p>JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，变量<code>x</code>到底是数值还是字符串，取决于另一个变量<code>y</code>的值。<code>y</code>为<code>true</code>时，<code>x</code>是一个数值；<code>y</code>为<code>false</code>时，<code>x</code>是一个字符串。这意味着，<code>x</code>的类型没法在编译阶段就知道，必须等到运行时才能知道。</p>\n<p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，虽然是两个字符串相减，但是依然会得到结果数值<code>1</code>，原因就在于 JavaScript 将运算子自动转为了数值。</p>\n<p>本章讲解数据类型自动转换的规则。在此之前，先讲解如何手动强制转换数据类型。</p>\n<h3> 数值特有的转换与判断方法</h3>\n<h4> parseInt()</h4>\n<h5> 基本用法</h5>\n<p><strong><code>parseInt</code>方法用于将字符串转为整数。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>如果字符串头部有空格，空格会被自动去除。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>parseInt</code>的参数都是字符串，结果只返回字符串头部可以转为数字的部分。</p>\n<p><strong>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回<code>NaN</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>所以，<code>parseInt</code>的返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code>。</strong></p>\n<p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果字符串以<code>0</code>开头，将其按照10进制解析。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h5> 进制转换</h5>\n<p><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是转换指定进制的数的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码中，二进制、六进制、八进制的<code>1000</code>，分别等于十进制的8、216和512。这意味着，可以用<code>parseInt</code>方法进行进制的转换。</strong></p>\n<p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回<code>NaN</code>。如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回<code>NaN</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对于二进制来说，<code>1</code>是有意义的字符，<code>5</code>、<code>4</code>、<code>6</code>都是无意义的字符，所以第一行返回1，第二行返回<code>NaN</code>。</p>\n<p>前面说过，如果<code>parseInt</code>的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，十六进制的<code>0x11</code>会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串<code>17</code>，最后返回结果<code>43</code>和<code>1</code>。</p>\n<p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，第一行的<code>011</code>会被先转为字符串<code>9</code>，因为<code>9</code>不是二进制的有效字符，所以返回<code>NaN</code>。如果直接计算<code>parseInt('011', 2)</code>，<code>011</code>则是会被当作二进制处理，返回3。</p>\n<p><strong>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个<code>0</code>。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</strong></p>\n<h4> parseFloat()</h4>\n<h5> 基本用法</h5>\n<p><code>parseFloat</code>方法用于将一个字符串转为浮点数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果字符串符合科学计数法，则会进行相应的转换。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>parseFloat</code>方法会自动过滤字符串前导的空格。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h5> 注意点</h5>\n<p>尤其值得注意，<code>parseFloat</code>会将空字符串转为<code>NaN</code>。</p>\n<p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> isNaN()</h4>\n<p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值，请参见《数据类型转换》一章。</p>\n<p>因此，使用<code>isNaN</code>之前，最好判断一下数据类型。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> isFinite()</h4>\n<p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p>\n<h3> 强制转换</h3>\n<p>强制转换主要指使用<code>Number()</code>、<code>String()</code>和<code>Boolean()</code>三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。</p>\n<h4> Number()</h4>\n<h5> 转换规则</h5>\n<p><code>Number</code>背后的转换规则比较复杂。</p>\n<p><strong>第一步，调用对象自身的<code>valueOf</code>方法。如果返回原始类型的值，则直接对该值使用<code>Number</code>函数，不再进行后续步骤。</strong></p>\n<p><strong>第二步，如果<code>valueOf</code>方法返回的还是对象，则改为调用对象自身的<code>toString</code>方法。如果<code>toString</code>方法返回原始类型的值，则对该值使用<code>Number</code>函数，不再进行后续步骤。</strong></p>\n<p><strong>第三步，如果<code>toString</code>方法返回的是对象，就报错。</strong></p>\n<p>使用<code>Number</code>函数，可以将任意类型的值转化成数值。</p>\n<p>下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。</p>\n<h5> 原始类型值</h5>\n<p>原始类型值的转换规则如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Number</code>函数将字符串转为数值，要比<code>parseInt</code>函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>parseInt</code>逐个解析字符，而<code>Number</code>函数整体转换字符串的类型。</p>\n<p>另外，<code>parseInt</code>和<code>Number</code>函数都会自动过滤一个字符串前导和后缀的空格。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h5> 对象</h5>\n<p>简单的规则是，<code>Number</code>方法的参数是对象时，将返回<code>NaN</code>，除非是包含单个数值的数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>之所以会这样，是因为<code>Number</code>背后的转换规则比较复杂。</p>\n<p>第一步，调用对象自身的<code>valueOf</code>方法。如果返回原始类型的值，则直接对该值使用<code>Number</code>函数，不再进行后续步骤。</p>\n<p>第二步，如果<code>valueOf</code>方法返回的还是对象，则改为调用对象自身的<code>toString</code>方法。如果<code>toString</code>方法返回原始类型的值，则对该值使用<code>Number</code>函数，不再进行后续步骤。</p>\n<p>第三步，如果<code>toString</code>方法返回的是对象，就报错。</p>\n<p>请看下面的例子。</p>\n<div class=\"language-jw\" data-ext=\"jw\"></div><p>上面代码中，<code>Number</code>函数将<code>obj</code>对象转为数值。背后发生了一连串的操作，首先调用<code>obj.valueOf</code>方法, 结果返回对象本身；于是，继续调用<code>obj.toString</code>方法，这时返回字符串<code>[object Object]</code>，对这个字符串使用<code>Number</code>函数，得到<code>NaN</code>。</p>\n<p>默认情况下，对象的<code>valueOf</code>方法返回对象本身，所以一般总是会调用<code>toString</code>方法，而<code>toString</code>方法返回对象的类型字符串（比如<code>[object Object]</code>）。所以，会有下面的结果。</p>\n<div class=\"language-jw\" data-ext=\"jw\"></div><p>如果<code>toString</code>方法返回的不是原始类型的值，结果就会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的<code>valueOf</code>和<code>toString</code>方法，返回的都是对象，所以转成数值时会报错。</p>\n<p>从上例还可以看到，<code>valueOf</code>和<code>toString</code>方法，都是可以自定义的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码对三个对象使用<code>Number</code>函数。第一个对象返回<code>valueOf</code>方法的值，第二个对象返回<code>toString</code>方法的值，第三个对象表示<code>valueOf</code>方法先于<code>toString</code>方法执行。</p>\n<h4> String()</h4>\n<h5> 转换规则</h5>\n<p><code>String</code>方法背后的转换规则，与<code>Number</code>方法基本相同，只是互换了<code>valueOf</code>方法和<code>toString</code>方法的执行顺序。</p>\n<ol>\n<li>先调用对象自身的<code>toString</code>方法。如果返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>\n<li>如果<code>toString</code>方法返回的是对象，再调用原对象的<code>valueOf</code>方法。如果<code>valueOf</code>方法返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>\n<li>如果<code>valueOf</code>方法返回的是对象，就报错。</li>\n</ol>\n<p><code>String</code>函数可以将任意类型的值转化成字符串，转换规则如下。</p>\n<h5> 原始类型值</h5>\n<ul>\n<li><strong>数值</strong>：转为相应的字符串。</li>\n<li><strong>字符串</strong>：转换后还是原来的值。</li>\n<li><strong>布尔值</strong>：<code>true</code>转为字符串<code>\"true\"</code>，<code>false</code>转为字符串<code>\"false\"</code>。</li>\n<li><strong>undefined</strong>：转为字符串<code>\"undefined\"</code>。</li>\n<li><strong>null</strong>：转为字符串<code>\"null\"</code>。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h5> 对象</h5>\n<p><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>String</code>方法背后的转换规则，与<code>Number</code>方法基本相同，只是互换了<code>valueOf</code>方法和<code>toString</code>方法的执行顺序。</p>\n<ol>\n<li>先调用对象自身的<code>toString</code>方法。如果返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>\n<li>如果<code>toString</code>方法返回的是对象，再调用原对象的<code>valueOf</code>方法。如果<code>valueOf</code>方法返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>\n<li>如果<code>valueOf</code>方法返回的是对象，就报错。</li>\n</ol>\n<p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码先调用对象的<code>toString</code>方法，发现返回的是字符串<code>[object Object]</code>，就不再调用<code>valueOf</code>方法了。</p>\n<p>如果<code>toString</code>法和<code>valueOf</code>方法，返回的都是对象，就会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面是通过自定义<code>toString</code>方法，改变返回值的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码对三个对象使用<code>String</code>函数。第一个对象返回<code>toString</code>方法的值（数值3），第二个对象返回的还是<code>toString</code>方法的值（<code>[object Object]</code>），第三个对象表示<code>toString</code>方法先于<code>valueOf</code>方法执行。</p>\n<h4> Boolean()</h4>\n<p><code>Boolean()</code>函数可以将任意类型的值转为布尔值。</p>\n<p>它的转换规则相对简单：除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code>。</p>\n<ul>\n<li><code>undefined</code></li>\n<li><code>null</code></li>\n<li><code>0</code>（包含<code>-0</code>和<code>+0</code>）</li>\n<li><code>NaN</code></li>\n<li><code>''</code>（空字符串）</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>当然，<code>true</code>和<code>false</code>这两个布尔值不会发生变化。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，所有对象（包括空对象）的转换结果都是<code>true</code>，甚至连<code>false</code>对应的布尔对象<code>new Boolean(false)</code>也是<code>true</code>（详见《原始类型值的包装对象》一章）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>所有对象的布尔值都是<code>true</code>，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于<code>obj1 &amp;&amp; obj2</code>这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为<code>true</code>。</p>\n<h3> 自动转换</h3>\n<h4> 发生的场合</h4>\n<p>下面介绍自动转换，它是以强制转换为基础的。</p>\n<p>遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。</p>\n<p>第一种情况，不同类型的数据互相运算。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>第二种情况，对非布尔值类型的数据求布尔值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>第三种情况，对非数值类型的值使用一元运算符（即<code>+</code>和<code>-</code>）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用<code>String()</code>函数进行转换。如果该位置既可以是字符串，也可能是数值，那么默认转为数值。</p>\n<p>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>函数进行显式转换。</p>\n<h4> 自动转换为布尔值</h4>\n<p>JavaScript 遇到预期为布尔值的地方（比如<code>if</code>语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用<code>Boolean()</code>函数。</p>\n<p>因此除了以下五个值，其他都是自动转为<code>true</code>。</p>\n<ul>\n<li><code>undefined</code></li>\n<li><code>null</code></li>\n<li><code>+0</code>或<code>-0</code></li>\n<li><code>NaN</code></li>\n<li><code>''</code>（空字符串）</li>\n</ul>\n<p>下面这个例子中，条件部分的每个值都相当于<code>false</code>，使用否定运算符后，就变成了<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是<code>Boolean()</code>函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 自动转换为字符串</h4>\n<p>JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。<strong>具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。</strong></p>\n<p>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种自动转换很容易出错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，开发者可能期望返回<code>120</code>，但是由于自动转换，实际上返回了一个字符<code>10020</code>。</p>\n<h4> 自动转换为数值</h4>\n<p>JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用<code>Number()</code>函数。</p>\n<p>除了加法运算符（<code>+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，运算符两侧的运算子，都被转成了数值。</p>\n<blockquote>\n<p>注意：<code>null</code>转为数值时为<code>0</code>，而<code>undefined</code>转为数值时为<code>NaN</code>。</p>\n</blockquote>\n<p>一元运算符也会把运算子转成数值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "4.错误处理机制",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses4.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses4.html",
      "summary": "Error 实例对象 JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。 上面代码中，我们调用Error()构造函数，生成一个实例对象err。`Error()构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。抛...",
      "content_html": "<h1> 错误处理机制</h1>\n<h2> Error 实例对象</h2>\n<p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，我们调用<code>Error()</code>构造函数，生成一个实例对象<code>err</code>。<code>Error()</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数。抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。</p>\n<p>JavaScript 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p>\n<ul>\n<li><strong>message</strong>：错误提示信息</li>\n<li><strong>name</strong>：错误名称（非标准属性）</li>\n<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>\n</ul>\n<p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>stack</code>属性用来查看错误发生时的堆栈。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境。</p>\n<h2> 原生错误类型</h2>\n<p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在<code>Error</code>的6个派生对象。</p>\n<h3> SyntaxError 对象</h3>\n<p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。</p>\n<h3> ReferenceError 对象</h3>\n<p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码对函数<code>console.log</code>的运行结果赋值，结果引发了<code>ReferenceError</code>错误。</p>\n<h3> RangeError 对象</h3>\n<p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> TypeError 对象</h3>\n<p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p>\n<h3> URIError 对象</h3>\n<p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> EvalError 对象</h3>\n<p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p>\n<h3> 总结</h3>\n<p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 自定义错误</h2>\n<p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> throw 语句</h2>\n<p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果变量<code>x</code>小于等于<code>0</code>，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例。</p>\n<p><code>throw</code>也可以抛出自定义错误。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p>\n<p>实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>\n<h2> 异常捕获机制</h2>\n<h3> try...catch 结构</h3>\n<p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值。</p>\n<p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果函数<code>f</code>执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理。</p>\n<p><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行。</p>\n<p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>catch</code>代码之中又抛出了一个错误。</p>\n<p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理。</p>\n<h3> finally 代码块</h3>\n<p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，由于没有<code>catch</code>语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。而且，这个函数的返回值还是<code>result</code>。</p>\n<p>下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码说明，<code>return</code>语句里面的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了。</p>\n<p>下面是<code>finally</code>代码块用法的典型场景。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件。</p>\n<p>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块。</p>\n<p><code>catch</code>代码块之中，触发转入<code>finally</code>代码块的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了。</p>\n<p><code>try</code>代码块内部，还可以再使用<code>try</code>代码块。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错（<code>console</code>拼错了），这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "5.Array",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses5.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses5.html",
      "summary": "数组的本质 本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 上面代码表明，typeof运算符认为数组的类型就是对象。 数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2...）。 上面代码中，Object.keys方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。 由于数组成员的键名是固定的（...",
      "content_html": "<h1> Array</h1>\n<h2> 数组的本质</h2>\n<p>本质上，数组属于一种特殊的对象。<code>typeof</code>运算符会返回数组的类型是<code>object</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表明，<code>typeof</code>运算符认为数组的类型就是对象。</p>\n<p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2...）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Object.keys</code>方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。</p>\n<p>由于数组成员的键名是固定的（默认总是0、1、2...），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。</p>\n<p>注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，由于<code>1.00</code>转成字符串是<code>1</code>，所以通过数字键<code>1</code>可以读取值。</p>\n<p>对象有两种读取成员的方法：点结构（<code>object.key</code>）和方括号结构（<code>object[key]</code>）。但是，对于数值的键名，不能使用点结构。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>arr.0</code>的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号<code>arr[0]</code>表示（方括号是运算符，可以接受数值）。</p>\n<h2> 数组的几个关注点</h2>\n<h3> 构造函数的缺陷</h3>\n<p><code>Array()</code>构造函数有一个很大的缺陷，不同的参数个数会导致不一致的行为。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，<code>Array()</code>作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>或者使用<code>Array.of()</code>方法，该方法用于将一组值，转换为数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>\n<p>注意，如果生成数组时参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回<code>undefined</code>，但实际上该位置没有任何值。虽然这时可以读取到<code>length</code>属性，但是取不到键名。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>a</code>是<code>Array()</code>生成的一个长度为3的空数组，<code>b</code>是一个三个成员都是<code>undefined</code>的数组，这两个数组是不一样的。读取键值的时候，<code>a</code>和<code>b</code>都返回<code>undefined</code>，但是<code>a</code>的键名（成员的序号）都是空的，<code>b</code>的键名是有值的。</p>\n<h3> 数组的空位</h3>\n<h4> 基本介绍</h4>\n<p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表明，数组的空位不影响<code>length</code>属性。</p>\n<p>需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，数组最后一个成员后面有一个逗号，这不影响<code>length</code>属性的值，与没有这个逗号时效果一样。</p>\n<h4> 可读性</h4>\n<p>数组的空位是可以读取的，返回<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> delete 删除</h4>\n<p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码用<code>delete</code>命令删除了数组的第二个元素，这个位置就形成了空位，但是对<code>length</code>属性没有影响。也就是说，<code>length</code>属性不过滤空位。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心。</p>\n<h4> 遍历的区别</h4>\n<p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过。</strong></p>\n<h4> ES6 中的解释</h4>\n<p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Array(3)</code>返回一个具有 3 个空位的数组。</p>\n<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p>\n<p><strong>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</strong></p>\n<ul>\n<li><code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>\n<li><code>map()</code>会跳过空位，但会保留这个值</li>\n<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>ES6 则是明确将空位转为<code>undefined</code>。</strong></p>\n<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>copyWithin()</code>会连空位一起拷贝。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>fill()</code>会将空位视为正常的数组位置。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>for...of</code>循环也会遍历空位。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>\n<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>由于空位的处理规则非常不统一，所以建议避免出现空位。</strong></p>\n<h3> in 运算符</h3>\n<p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表明，数组存在键名为<code>2</code>的键。由于键名都是字符串，所以数值<code>2</code>会自动转成字符串。</p>\n<p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code>。</p>\n<h3> sort() 的排序稳定性</h3>\n<p>排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码对数组<code>arr</code>按照首字母进行排序。排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致，所以排序算法<code>stableSorting</code>是稳定排序。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，排序结果是<code>spork</code>在<code>straw</code>前面，跟原始顺序相反，所以排序算法<code>unstableSorting</code>是不稳定的。</p>\n<p>常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。</p>\n<p>早先的 ECMAScript 没有规定，<code>Array.prototype.sort()</code>的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。<strong><a href=\"https://github.com/tc39/ecma262/pull/1340\" target=\"_blank\" rel=\"noopener noreferrer\">ES2019</a> 明确规定，<code>Array.prototype.sort()</code>的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。</strong></p>\n<h2> 类似数组的对象</h2>\n<h3> 定义</h3>\n<p><strong>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错。</strong></p>\n<p><strong>“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组。</p>\n<p><strong>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组。</p>\n<h3> 转化成真数组</h3>\n<p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用。</p>\n<p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>还有一种更为简介的转化方法，是ES6中提供的<code>Array.from()</code>方法，将在后文中详细讲述。</p>\n<h2> 数组的静态方法</h2>\n<h3> Array.isArray()</h3>\n<p><code>Array.isArray</code>方法返回一个布尔值，表示参数是否为数组。它可以弥补<code>typeof</code>运算符的不足。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>typeof</code>运算符只能显示数组的类型是<code>Object</code>，而<code>Array.isArray</code>方法可以识别数组。</p>\n<h3> Array.from()</h3>\n<h4> 作用</h4>\n<p><strong><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</strong></p>\n<p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用<code>filter</code>方法。</p>\n<h4> 基本用法</h4>\n<p><strong>只要是部署了 Iterator 接口的数据结构，<code>Array.from</code>都能将其转为数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被<code>Array.from</code>转为真正的数组。</p>\n<p>如果参数是一个真正的数组，<code>Array.from</code>会返回一个一模一样的新数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>值得提醒的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。<code>Array.from</code>方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是<code>undefined</code>。扩展运算符转换不了这个对象。</p>\n<p><strong>对于还没有部署该方法的浏览器，可以用<code>Array.prototype.slice</code>方法替代。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 第二个参数的使用</h4>\n<p><strong><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面的例子是取出一组 DOM 节点的文本内容。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面的例子将数组中布尔值为<code>false</code>的成员转为<code>0</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一个例子是返回各种数据的类型。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from</code>的第三个参数，用来绑定<code>this</code>。</p>\n<p><code>Array.from()</code>可以将各种值转为真正的数组，并且还提供<code>map</code>功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Array.from</code>的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p>\n<p><code>Array.from()</code>的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于<code>\\uFFFF</code>的 Unicode 字符，算作两个字符的 bug。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Array.of()</h3>\n<p><code>Array.of()</code>方法用于将一组值，转换为数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Array()</code>方法没有参数、一个参数、三个参数时，返回的结果都不一样。</p>\n<p>只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数只有一个正整数时，实际上是指定数组的长度。</p>\n<p><strong><code>Array.of()</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>Array.of()</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</strong></p>\n<p><code>Array.of()</code>方法可以用下面的代码模拟实现。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 数组的实例方法</h2>\n<h3> valueOf()，toString()</h3>\n<p><code>valueOf</code>方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的<code>valueOf</code>方法不尽一致，数组的<code>valueOf</code>方法返回数组本身。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>toString</code>方法也是对象的通用方法，数组的<code>toString</code>方法返回数组的字符串形式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> push()，pop()</h3>\n<p><strong><code>push</code>方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码使用<code>push</code>方法，往数组中添加了四个成员。</p>\n<p><strong><code>pop</code>方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>对空数组使用<code>pop</code>方法，不会报错，而是返回<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的栈结构（stack）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>3</code>是最后进入数组的，但是最早离开数组。</p>\n<h3> shift()，unshift()</h3>\n<p><strong><code>shift()</code>方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，使用<code>shift()</code>方法以后，原数组就变了。</p>\n<p><code>shift()</code>方法可以遍历并清空一个数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码通过<code>list.shift()</code>方法每次取出一个元素，从而遍历数组。它的前提是数组元素不能是<code>0</code>或任何布尔值等于<code>false</code>的元素，因此这样的遍历不是很可靠。</p>\n<p><strong><code>push()</code>和<code>shift()</code>结合使用，就构成了“先进先出”的队列结构（queue）。</strong></p>\n<p><strong><code>unshift()</code>方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>unshift()</code>方法可以接受多个参数，这些参数都会添加到目标数组头部。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> join()</h3>\n<p><strong><code>join()</code>方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回</strong>。如果不提供参数，默认用逗号分隔。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p><strong>如果数组成员是<code>undefined</code>或<code>null</code>或空位，会被转成空字符串。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>通过<code>call</code>方法，这个方法也可以用于字符串或类似数组的对象。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> concat()</h3>\n<p><strong><code>concat</code>方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除了数组作为参数，<code>concat</code>也接受其他类型的值作为参数，添加到目标数组尾部。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，原数组包含一个对象，<code>concat</code>方法生成的新数组包含这个对象的引用。所以，改变原对象以后，新数组跟着改变。</p>\n<h3> reverse()</h3>\n<p><strong><code>reverse</code>方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> slice()</h3>\n<p><strong><code>slice()</code>方法用于提取目标数组的一部分，返回一个新数组，原数组不变。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，最后一个例子<code>slice()</code>没有参数，实际上等于返回一个原数组的拷贝。</p>\n<p><strong>如果<code>slice()</code>方法的参数是负数，则表示倒数计算的位置。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>-2</code>表示倒数计算的第二个位置，<code>-1</code>表示倒数计算的第一个位置。</p>\n<p>如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>slice()</code>方法的一个重要应用，是将类似数组的对象转为真正的数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的参数都不是数组，但是通过<code>call</code>方法，在它们上面调用<code>slice()</code>方法，就可以把它们转为真正的数组。</p>\n<h3> splice()</h3>\n<p><strong><code>splice()</code>方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>splice</code>的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码从原数组4号位置，删除了两个数组成员。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码除了删除成员，还插入了两个新成员。</p>\n<p>起始位置如果是负数，就表示从倒数位置开始删除。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，从倒数第四个位置<code>c</code>开始删除两个成员。</p>\n<p>如果只是单纯地插入元素，<code>splice</code>方法的第二个参数可以设为<code>0</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> sort()</h3>\n<p><code>sort</code>方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的最后两个例子，需要特殊注意。<code>sort()</code>方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以<code>101</code>排在<code>11</code>的前面。</p>\n<p>如果想让<code>sort</code>方法按照自定义方式排序，可以传入一个函数作为参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>sort</code>的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于<code>0</code>，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>注意，自定义的排序函数应该返回数值，否则不同的浏览器可能有不同的实现，不能保证结果都一致。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码中，前一种排序算法返回的是布尔值，这是不推荐使用的。后一种是数值，才是更好的写法。</strong></p>\n<h3> map()</h3>\n<p><strong><code>map()</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>numbers</code>数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。</p>\n<p><strong><code>map()</code>方法接受一个函数作为参数。该函数调用时，<code>map()</code>方法向它传入三个参数：当前成员、当前位置和数组本身。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>map()</code>方法的回调函数有三个参数，<code>elem</code>为当前成员的值，<code>index</code>为当前成员的位置，<code>arr</code>为原数组（<code>[1, 2, 3]</code>）。</p>\n<p><code>map()</code>方法还可以接受第二个参数，用来绑定回调函数内部的<code>this</code>变量）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码通过<code>map()</code>方法的第二个参数，将回调函数内部的<code>this</code>对象，指向<code>arr</code>数组。</strong></p>\n<p>如果数组有空位，<code>map()</code>方法的回调函数在这个位置不会执行，会跳过数组的空位。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>map()</code>方法不会跳过<code>undefined</code>和<code>null</code>，但是会跳过空位。</p>\n<h3> forEach()</h3>\n<p><code>forEach()</code>方法与<code>map()</code>方法很相似，也是对数组的所有成员依次执行参数函数。但是，<strong><code>forEach()</code>方法不返回值，只用来操作数据</strong>。这就是说，如果数组遍历的目的是为了得到返回值，那么使用<code>map()</code>方法，否则使用<code>forEach()</code>方法。</p>\n<p><code>forEach()</code>的用法与<code>map()</code>方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>forEach()</code>遍历数组不是为了得到返回值，而是为了在屏幕输出内容，所以不必使用<code>map()</code>方法。</p>\n<p><strong><code>forEach()</code>方法也可以接受第二个参数，绑定参数函数的<code>this</code>变量。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，空数组<code>out</code>是<code>forEach()</code>方法的第二个参数，结果，回调函数内部的<code>this</code>关键字就指向<code>out</code>。</p>\n<p>注意，<code>forEach()</code>方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用<code>for</code>循环。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，执行到数组的第二个成员时，就会中断执行。<code>forEach()</code>方法做不到这一点。</p>\n<p><code>forEach()</code>方法也会跳过数组的空位。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>forEach()</code>方法不会跳过<code>undefined</code>和<code>null</code>，但会跳过空位。</p>\n<h3> filter()</h3>\n<p><strong><code>filter()</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</strong></p>\n<p><strong>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。该方法不会改变原数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将大于<code>3</code>的数组成员，作为一个新数组返回。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>filter()</code>方法返回数组<code>arr</code>里面所有布尔值为<code>true</code>的成员。</p>\n<p><strong><code>filter()</code>方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码返回偶数位置的成员组成的新数组。</p>\n<p><code>filter()</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，过滤器<code>myFilter()</code>内部有<code>this</code>变量，它可以被<code>filter()</code>方法的第二个参数<code>obj</code>绑定，返回大于<code>3</code>的成员。</p>\n<h3> reduce()，reduceRight()</h3>\n<p><strong><code>reduce</code>方法和<code>reduceRight</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>reduce</code>方法求出数组所有成员的和。</p>\n<p>第一次执行，<code>a</code>是数组的第一个成员<code>1</code>，<code>b</code>是数组的第二个成员<code>2</code>。</p>\n<p>第二次执行，<code>a</code>为上一轮的返回值<code>3</code>，<code>b</code>为第三个成员<code>3</code>。</p>\n<p>第三次执行，<code>a</code>为上一轮的返回值<code>6</code>，<code>b</code>为第四个成员<code>4</code>。</p>\n<p>第四次执行，<code>a</code>为上一轮返回值<code>10</code>，<code>b</code>为第五个成员<code>5</code>。</p>\n<p>至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值<code>15</code>。</p>\n<p><strong><code>reduce</code>方法和<code>reduceRight</code>方法的第一个参数都是一个函数。该函数接受以下四个参数。</strong></p>\n<ol>\n<li><strong>累积变量，默认为数组的第一个成员</strong></li>\n<li><strong>当前变量，默认为数组的第二个成员</strong></li>\n<li><strong>当前位置（从0开始）</strong></li>\n<li><strong>原数组</strong></li>\n</ol>\n<p><strong>这四个参数之中，只有前两个是必须的，后两个则是可选的。</strong></p>\n<p>如果要对累积变量指定初值，可以把它放在<code>reduce</code>方法和<code>reduceRight</code>方法的第二个参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码指定参数<code>a</code>的初值为10，所以数组从10开始累加，最终结果为25。注意，这时<code>b</code>是从数组的第一个成员开始遍历。</p>\n<p>上面的第二个参数相当于设定了默认值，处理空数组时尤其有用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，由于空数组取不到初始值，<code>reduce</code>方法会报错。这时，加上第二个参数，就能保证总是会返回一个值。</p>\n<p>下面是一个<code>reduceRight</code>方法的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>reduce</code>方法相当于<code>3</code>减去<code>2</code>再减去<code>1</code>，<code>reduceRight</code>方法相当于<code>1</code>减去<code>2</code>再减去<code>3</code>。</p>\n<p>由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>reduce</code>的参数函数会将字符长度较长的那个数组成员，作为累积值。这导致遍历所有成员之后，累积值就是字符长度最长的那个成员。</p>\n<h3> indexOf()，lastIndexOf()</h3>\n<p><strong><code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>indexOf</code>方法还可以接受第二个参数，表示搜索的开始位置。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码从1号位置开始搜索字符<code>a</code>，结果为<code>-1</code>，表示没有搜索到。</p>\n<p><strong><code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>注意，这两个方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这是因为这两个方法内部，使用严格相等运算符（<code>===</code>）进行比较，而<code>NaN</code>是唯一一个不等于自身的值。</p>\n<h3> some()，every()</h3>\n<p>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</p>\n<p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</p>\n<p><strong><code>some</code>方法是只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果数组<code>arr</code>有一个成员大于等于3，<code>some</code>方法就返回<code>true</code>。</p>\n<p><strong><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，数组<code>arr</code>并非所有成员大于等于<code>3</code>，所以返回<code>false</code>。</p>\n<p>注意，对于空数组，<code>some</code>方法返回<code>false</code>，<code>every</code>方法返回<code>true</code>，回调函数都不会执行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>some</code>和<code>every</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</strong></p>\n<h3> copyWithin()</h3>\n<p><strong>数组实例的<code>copyWithin()</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>它接受三个参数。</strong></p>\n<ul>\n<li><strong>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</strong></li>\n<li><strong>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</strong></li>\n<li><strong>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</strong></li>\n</ul>\n<p><strong>这三个参数都应该是数值，如果不是，会自动转为数值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p>\n<p>下面是更多例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> find()，findIndex()</h3>\n<p>数组实例的<code>find</code>方法，<strong>用于找出第一个符合条件的数组成员</strong>。它的参数是一个回调函数，所有数组成员依次执行该回调函数，<strong>直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code></strong>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码找出数组中第一个小于 0 的成员。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>\n<p><strong>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码中，<code>find</code>函数接收了第二个参数<code>person</code>对象，回调函数中的<code>this</code>对象指向<code>person</code>对象。</p>\n<p><strong>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>indexOf</code>方法的不足。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p>\n<h3> fill()</h3>\n<p><code>fill</code>方法使用给定值，填充一个数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</strong></p>\n<p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，<code>fill</code>方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p>\n<p><strong>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> entries()，keys(), values()</h3>\n<p>ES6 提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象，可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> includes()</h3>\n<p>**<code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。**ES2016 引入了该方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>includes</code>使用的是不一样的判断算法，就没有这个问题。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>\n<ul>\n<li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>\n<li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>\n</ul>\n<h3> flat()，flatMap()</h3>\n<p><strong>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，原数组的成员里面有一个数组，<code>flat()</code>方法将子数组的成员取出来，添加在原来的位置。</p>\n<p><strong><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>flat()</code>的参数为2，表示要“拉平”两层的嵌套数组。</p>\n<p><strong>如果不管有多少层嵌套，都要转成一维数组，可以用<code>Infinity</code>关键字作为参数。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>如果原数组有空位，<code>flat()</code>方法会跳过空位。</strong></p>\n<div class=\"language-text\" data-ext=\"text\"></div><p><strong><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>flatMap()</code>只能展开一层数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此<code>flatMap()</code>返回的还是一个嵌套数组。</strong></p>\n<p><strong><code>flatMap()</code>方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>flatMap()</code>方法还可以有第二个参数，用来绑定遍历函数里面的<code>this</code>。</p>\n<h3> 总结</h3>\n<ol>\n<li>\n<p>会改变原数组的方法：</p>\n<ul>\n<li>push()，pop()</li>\n<li>shift()，unshift()</li>\n<li>reverse()</li>\n<li>splice()</li>\n<li>sort()</li>\n<li>copyWithin()</li>\n<li>fill() (浅拷贝填充)</li>\n</ul>\n</li>\n<li>\n<p>返回新数组，不会改变原数组的方法：</p>\n<ul>\n<li>concat() (浅拷贝)</li>\n<li>slice() (浅拷贝)</li>\n<li>map() (浅拷贝)</li>\n<li>filter() (浅拷贝)</li>\n<li>flat()，flatMap()</li>\n</ul>\n</li>\n</ol>\n<h2> 数组的遍历</h2>\n<h3> for...in 循环</h3>\n<p><strong><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。</strong></p>\n<p><strong>但是注意，<code>for...in</code>循环遍历的是数组的键，而并非值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>但是，<code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码在遍历数组时，也遍历到了非整数键<code>foo</code>。所以，不推荐使用<code>for...in</code>遍历数组。</p>\n<h3> for 循环和 while 循环</h3>\n<p>数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。</p>\n<h3> forEach()</h3>\n<p>数组的<code>forEach</code>方法，也可以用来遍历数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> for...of 循环</h3>\n<p>ES6 提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象，可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性，结果<code>obj</code>的<code>for...of</code>循环，产生了与<code>arr</code>完全一样的结果。</p>\n<p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法（参见《数组的扩展》一章）。</p>\n<p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "6.String",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses6.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses6.html",
      "summary": "字符串的几个关注点 字符串与数组 字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 上面代码表示，字符串内部的单个字符无法改变和增删，...",
      "content_html": "<h1> String</h1>\n<h2> 字符串的几个关注点</h2>\n<h3> 字符串与数组</h3>\n<p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。</p>\n<h3> 转义</h3>\n<p>反斜杠（\\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p>\n<p>需要用反斜杠转义的特殊字符，主要有下面这些。</p>\n<ul>\n<li><code>\\0</code> ：null（<code>\\u0000</code>）</li>\n<li><code>\\b</code> ：后退键（<code>\\u0008</code>）</li>\n<li><code>\\f</code> ：换页符（<code>\\u000C</code>）</li>\n<li><code>\\n</code> ：换行符（<code>\\u000A</code>）</li>\n<li><code>\\r</code> ：回车键（<code>\\u000D</code>）</li>\n<li><code>\\t</code> ：制表符（<code>\\u0009</code>）</li>\n<li><code>\\v</code> ：垂直制表符（<code>\\u000B</code>）</li>\n<li><code>\\'</code> ：单引号（<code>\\u0027</code>）</li>\n<li><code>\\\"</code> ：双引号（<code>\\u0022</code>）</li>\n<li><code>\\\\</code> ：反斜杠（<code>\\u005C</code>）</li>\n</ul>\n<p>上面这些字符前面加上反斜杠，都表示特殊含义。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>\\n</code>表示换行，输出的时候就分成了两行。</p>\n<p>反斜杠还有三种特殊用法。</p>\n<p>（1）<code>\\HHH</code></p>\n<p>反斜杠后面紧跟三个八进制数（<code>000</code>到<code>377</code>），代表一个字符。<code>HHH</code>对应该字符的 Unicode 码点，比如<code>\\251</code>表示版权符号。显然，这种方法只能输出256种字符。</p>\n<p>（2）<code>\\xHH</code></p>\n<p><code>\\x</code>后面紧跟两个十六进制数（<code>00</code>到<code>FF</code>），代表一个字符。<code>HH</code>对应该字符的 Unicode 码点，比如<code>\\xA9</code>表示版权符号。这种方法也只能输出256种字符。</p>\n<p>（3）<code>\\uXXXX</code></p>\n<p><code>\\u</code>后面紧跟四个十六进制数（<code>0000</code>到<code>FFFF</code>），代表一个字符。<code>XXXX</code>对应该字符的 Unicode 码点，比如<code>\\u00A9</code>表示版权符号。</p>\n<p>下面是这三种字符特殊写法的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>a</code>是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。</p>\n<p>如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> ase64 转码</h3>\n<p>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p>\n<p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、<code>+</code>和<code>/</code>这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p>\n<p><strong>JavaScript 原生提供两个 Base64 相关的方法。</strong></p>\n<ul>\n<li><strong><code>btoa()</code>：任意值转为 Base64 编码</strong></li>\n<li><strong><code>atob()</code>：Base64 编码转为原来的值</strong></li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，这两个方法不适合非 ASCII 码的字符，会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 字符的 Unicode 表示法</h3>\n<p>ES6 加强了对 Unicode 的支持，允许采用<code>\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是，这种表示法只限于码点在<code>\\u0000</code>~<code>\\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，如果直接在<code>\\u</code>后面跟上超过<code>0xFFFF</code>的数值（比如<code>\\u20BB7</code>），JavaScript 会理解成<code>\\u20BB+7</code>。由于<code>\\u20BB</code>是一个不可打印字符，所以只会显示一个空格，后面跟着一个<code>7</code>。</p>\n<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p>\n<p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> JSON.stringify() 的改造</h3>\n<p>根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的<code>JSON.stringify()</code>方法有可能返回不符合 UTF-8 标准的字符串。</p>\n<p>具体来说，UTF-8 标准规定，<code>0xD800</code>到<code>0xDFFF</code>之间的码点，不能单独使用，必须配对使用。比如，<code>\\uD834\\uDF06</code>是两个码点，但是必须放在一起配对使用，代表字符<code>𝌆</code>。这是为了表示码点大于<code>0xFFFF</code>的字符的一种变通方法。单独使用<code>\\uD834</code>和<code>\\uDFO6</code>这两个码点是不合法的，或者颠倒顺序也不行，因为<code>\\uDF06\\uD834</code>并没有对应的字符。</p>\n<p><code>JSON.stringify()</code>的问题在于，它可能返回<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>为了确保返回的是合法的 UTF-8 字符，<a href=\"https://github.com/tc39/proposal-well-formed-stringify\" target=\"_blank\" rel=\"noopener noreferrer\">ES2019</a> 改变了<code>JSON.stringify()</code>的行为。如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 模板字符串</h2>\n<h3> 设计目的</h3>\n<p>传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 基本使用</h3>\n<p><strong>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用<code>trim</code>方法消除它。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>模板字符串之中还能调用函数。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</strong></p>\n<p>如果模板字符串中的变量没有声明，将报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>模板字符串甚至还能嵌套。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果需要引用模板字符串本身，在需要时执行，可以写成函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。</p>\n<h3> 标签模板</h3>\n<p><strong>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</strong></p>\n<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，模板字符串前面有一个标识名<code>tag</code>，它是一个函数。整个表达式的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p>\n<p>函数<code>tag</code>依次会接收到多个参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>\n<p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p>\n<p><code>**tag</code>函数所有参数的实际值如下。**</p>\n<ul>\n<li><strong>第一个参数：<code>['Hello ', ' world ', '']</code></strong></li>\n<li><strong>第二个参数: 15</strong></li>\n<li><strong>第三个参数：50</strong></li>\n</ul>\n<p><strong>也就是说，<code>tag</code>函数实际上以下面的形式调用。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面是一个更复杂的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p>\n<p><code>passthru</code>函数采用 rest 参数的写法如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码通过<code>jsx</code>函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到<code>jsx</code>函数的<a href=\"https://gist.github.com/lygaret/a68220defa69174bdec5\" target=\"_blank\" rel=\"noopener noreferrer\">具体实现</a>。</p>\n<p>下面则是一个假想的例子，通过<code>java</code>函数，在 JavaScript 代码之中运行 Java 代码。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>console.log</code>接受的参数，实际上是一个数组。该数组有一个<code>raw</code>属性，保存的是转义后的原字符串。</p>\n<p>请看下面的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>tag</code>函数的第一个参数<code>strings</code>，有一个<code>raw</code>属性，也指向一个数组。该数组的成员与<code>strings</code>数组完全一致。比如，<code>strings</code>数组是<code>[\"First line\\nSecond line\"]</code>，那么<code>strings.raw</code>数组就是<code>[\"First line\\\\nSecond line\"]</code>。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将<code>\\n</code>视为<code>\\\\</code>和<code>n</code>两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p>\n<h3> 模板字符串的限制</h3>\n<p><strong>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</strong></p>\n<p>举例来说，标签模板里面可以嵌入 LaTEX 语言。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，变量<code>document</code>内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。</p>\n<p>模板字符串会将<code>\\u00FF</code>和<code>\\u{42}</code>当作 Unicode 字符进行转义，所以<code>\\unicode</code>解析时报错；而<code>\\x56</code>会被当作十六进制字符串转义，所以<code>\\xerxes</code>会报错。也就是说，<code>\\u</code>和<code>\\x</code>在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。</p>\n<p>为了解决这个问题，ES2018 <a href=\"https://tc39.github.io/proposal-template-literal-revision/\" target=\"_blank\" rel=\"noopener noreferrer\">放松</a>了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回<code>undefined</code>，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为<code>undefined</code>，但是<code>raw</code>属性依然可以得到原始字符串，因此<code>tag</code>函数还是可以对原字符串进行处理。</p>\n<p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 字符串的静态方法</h2>\n<h3> String.fromCharCode()</h3>\n<p><strong><code>String</code>对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是<code>String.fromCharCode()</code>。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>String.fromCharCode</code>方法的参数为空，就返回空字符串；否则，返回参数对应的 Unicode 字符串。</p>\n<p>注意，该方法不支持 Unicode 码点大于<code>0xFFFF</code>的字符，即传入的参数不能大于<code>0xFFFF</code>（即十进制的 65535）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>String.fromCharCode</code>参数<code>0x20BB7</code>大于<code>0xFFFF</code>，导致返回结果出错。<code>0x20BB7</code>对应的字符是汉字<code>𠮷</code>，但是返回结果却是另一个字符（码点<code>0x0BB7</code>）。这是因为<code>String.fromCharCode</code>发现参数值大于<code>0xFFFF</code>，就会忽略多出的位（即忽略<code>0x20BB7</code>里面的<code>2</code>）。</p>\n<p>这种现象的根本原因在于，码点大于<code>0xFFFF</code>的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须把<code>0x20BB7</code>拆成两个字符表示。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>0x20BB7</code>拆成两个字符<code>0xD842</code>和<code>0xDFB7</code>（即两个两字节字符，合成一个四字节字符），就能得到正确的结果。码点大于<code>0xFFFF</code>的字符的四字节表示法，由 UTF-16 编码方法决定。</p>\n<h3> String.raw()</h3>\n<p><strong>ES6 还为原生的 String 对象，提供了一个<code>raw()</code>方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果原字符串的斜杠已经转义，那么<code>String.raw()</code>会进行再次转义。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>String.raw()</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>\n<p><code>String.raw()</code>本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组，对应模板字符串解析后的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>String.raw()</code>方法的第一个参数是一个对象，它的<code>raw</code>属性等同于原始的模板字符串解析后得到的数组。</p>\n<p>作为函数，<code>String.raw()</code>的代码实现基本如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 字符串的实例方法</h2>\n<h3> charAt()</h3>\n<p><strong><code>charAt</code>方法返回指定位置的字符，参数是从<code>0</code>开始编号的位置。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这个方法完全可以用数组下标替代。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果参数为负数，或大于等于字符串的长度，<code>charAt</code>返回空字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> charCodeAt()</h3>\n<p><strong><code>charCodeAt()</code>方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于<code>String.fromCharCode()</code>的逆操作。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>abc</code>的<code>1</code>号位置的字符是<code>b</code>，它的 Unicode 码点是<code>98</code>。</p>\n<p>如果没有任何参数，<code>charCodeAt</code>返回首字符的 Unicode 码点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果参数为负数，或大于等于字符串的长度，<code>charCodeAt</code>返回<code>NaN</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>charCodeAt</code>方法返回的 Unicode 码点不会大于65536（0xFFFF），也就是说，只返回两个字节的字符的码点。如果遇到码点大于 65536 的字符（四个字节的字符），必须连续使用两次<code>charCodeAt</code>，不仅读入<code>charCodeAt(i)</code>，还要读入<code>charCodeAt(i+1)</code>，将两个值放在一起，才能得到准确的字符。</p>\n<h3> codePointAt()</h3>\n<p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode 码点大于<code>0xFFFF</code>的字符），JavaScript 会认为它们是两个字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），需要<code>4</code>个字节储存。对于这种<code>4</code>个字节的字符，JavaScript 不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt()</code>方法无法读取整个字符，<code>charCodeAt()</code>方法只能分别返回前两个字节和后两个字节的值。</p>\n<p>ES6 提供了<code>codePointAt()</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>codePointAt()</code>方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的<code>20BB7</code>）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt()</code>方法的结果与<code>charCodeAt()</code>方法相同。</p>\n<p>总之，<code>codePointAt()</code>方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt()</code>方法相同。</p>\n<p><code>codePointAt()</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString()</code>方法转换一下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>你可能注意到了，<code>codePointAt()</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>的正确位置序号应该是 1，但是必须向<code>codePointAt()</code>方法传入 2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别 32 位的 UTF-16 字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一种方法也可以，使用扩展运算符（<code>...</code>）进行展开运算。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>codePointAt()</code>方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> concat()</h3>\n<p><strong><code>concat</code>方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法可以接受多个参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果参数不是字符串，<code>concat</code>方法会将其先转为字符串，然后再连接。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>concat</code>方法将参数先转成字符串再连接，所以返回的是一个三个字符的字符串。作为对比，加号运算符在两个运算数都是数值时，不会转换类型，所以返回的是一个两个字符的字符串。</p>\n<h3> slice()</h3>\n<p><strong><code>slice()</code>方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>如果省略第二个参数，则表示子字符串一直到原字符串结束。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>如果第一个参数大于第二个参数（正数情况下），<code>slice()</code>方法返回一个空字符串。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> substring()</h3>\n<p><strong><code>substring</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>方法很相像。</strong></p>\n<p><strong>它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果第一个参数大于第二个参数，<code>substring</code>方法会自动更换两个参数的位置。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码中，调换<code>substring</code>方法的两个参数，都得到同样的结果。</strong></p>\n<p><strong>如果参数是负数，<code>substring</code>方法会自动将负数转为0。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，第二个例子的参数<code>-3</code>会自动变成<code>0</code>，等同于<code>'JavaScript'.substring(4, 0)</code>。由于第二个参数小于第一个参数，会自动互换位置，所以返回<code>Java</code>。</p>\n<p><strong>由于这些规则违反直觉，因此不建议使用<code>substring</code>方法，应该优先使用<code>slice</code>。</strong></p>\n<h3> substr()</h3>\n<p><strong><code>substr</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>和<code>substring</code>方法的作用相同。</strong></p>\n<p><strong><code>substr</code>方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</strong></p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，第二个例子的参数<code>-1</code>自动转为<code>0</code>，表示子字符串长度为<code>0</code>，所以返回空字符串。</p>\n<h3> indexOf()，lastIndexOf()</h3>\n<p><strong><code>indexOf</code>方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回<code>-1</code>，就表示不匹配。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>indexOf</code>方法还可以接受第二个参数，表示从该位置开始向后匹配。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>lastIndexOf</code>方法的用法跟<code>indexOf</code>方法一致，主要的区别是<code>lastIndexOf</code>从尾部开始匹配，<code>indexOf</code>则是从头部开始匹配。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另外，<code>lastIndexOf</code>的第二个参数表示从该位置起向前匹配。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> includes(), startsWith(), endsWith()</h3>\n<p><strong>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</strong></p>\n<ul>\n<li><strong>includes()：返回布尔值，表示是否找到了参数字符串。</strong></li>\n<li><strong>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</strong></li>\n<li><strong>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</strong></li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>\n<h3> trim()</h3>\n<p><strong><code>trim</code>方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>该方法去除的不仅是空格，还包括制表符（<code>\\t</code>、<code>\\v</code>）、换行符（<code>\\n</code>）和回车符（<code>\\r</code>）。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> trimStart()，trimEnd()</h3>\n<p><a href=\"https://github.com/tc39/proposal-string-left-right-trim\" target=\"_blank\" rel=\"noopener noreferrer\">ES2019</a> 对字符串实例新增了<code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。<strong>它们返回的都是新字符串，不会修改原始字符串。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>trimStart()</code>只消除头部的空格，保留尾部的空格。<code>trimEnd()</code>也是类似行为。</p>\n<p>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p>\n<p><strong>浏览器还部署了额外的两个方法，<code>trimLeft()</code>是<code>trimStart()</code>的别名，<code>trimRight()</code>是<code>trimEnd()</code>的别名。</strong></p>\n<h3> toLowerCase()，toUpperCase()</h3>\n<p><code>toLowerCase</code>方法用于将一个字符串全部转为小写，<code>toUpperCase</code>则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> split()</h3>\n<p><strong><code>split</code>方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果省略参数，则返回数组的唯一成员就是原字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>split</code>方法还可以接受第二个参数，限定返回数组的最大成员数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>split</code>方法的第二个参数，决定了返回数组的成员数。</p>\n<p><code>split</code>方法还可以使用正则表达式作为参数。</p>\n<h3> repeat()</h3>\n<p><strong><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>参数如果是小数，会被取整。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为 0。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>参数<code>NaN</code>等同于 0。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> padStart()，padEnd()</h3>\n<p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<strong><code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。这两个方法均返回一个新字符串</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</strong></p>\n<p>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果省略第二个参数，默认使用空格补全长度。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>padStart()</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>另一个用途是提示字符串格式。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> localeCompare()</h3>\n<p><strong><code>localeCompare</code>方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，字母<code>B</code>小于字母<code>a</code>。因为 JavaScript 采用的是 Unicode 码点比较，<code>B</code>的码点是66，而<code>a</code>的码点是97。</p>\n<p><strong>但是，<code>localeCompare</code>方法会考虑自然语言的排序情况，将<code>B</code>排在<code>a</code>的前面。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>localeCompare</code>方法返回整数1，表示<code>B</code>较大。</p>\n<p><strong><code>localeCompare</code>还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>de</code>表示德语，<code>sv</code>表示瑞典语。德语中，<code>ä</code>小于<code>z</code>，所以返回<code>-1</code>；瑞典语中，<code>ä</code>大于<code>z</code>，所以返回<code>1</code>。</p>\n<h3> normalize()</h3>\n<p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如<code>Ǒ</code>（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如<code>O</code>（\\u004F）和<code>ˇ</code>（\\u030C）合成<code>Ǒ</code>（\\u004F\\u030C）。</p>\n<p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</p>\n<p>ES6 提供字符串实例的<code>normalize()</code>方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p>\n<ul>\n<li><code>NFC</code>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li>\n<li><code>NFD</code>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li>\n<li><code>NFKC</code>，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，<code>normalize</code>方法不能识别中文。）</li>\n<li><code>NFKD</code>，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数返回字符的分解形式。</p>\n<p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</p>\n<h3> match()</h3>\n<p><strong><code>match</code>方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<code>null</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>返回的数组还有<code>index</code>属性和<code>input</code>属性，分别表示匹配字符串开始的位置和原始字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>match</code>方法还可以使用正则表达式作为参数。</p>\n<h3> search()，replace()</h3>\n<p><strong><code>search</code>方法的用法基本等同于<code>match</code>，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回<code>-1</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>search</code>方法还可以使用正则表达式作为参数。</p>\n<p><code>replace</code>方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有<code>g</code>修饰符的正则表达式）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>replace</code>方法还可以使用正则表达式作为参数。</p>\n<h3> matchAll()</h3>\n<p><code>matchAll()</code>方法返回一个正则表达式在当前字符串的所有匹配。</p>\n<h3> replaceAll()</h3>\n<p>历史上，字符串的实例方法<code>replace()</code>只能替换第一个匹配。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，<code>replace()</code>只将第一个<code>b</code>替换成了下划线。</p>\n<p>如果要替换所有的匹配，不得不使用正则表达式的<code>g</code>修饰符。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>正则表达式毕竟不是那么方便和直观，<a href=\"https://github.com/tc39/proposal-string-replaceall\" target=\"_blank\" rel=\"noopener noreferrer\">ES2021</a> 引入了<code>replaceAll()</code>方法，可以一次性替换所有匹配。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>它的用法与<code>replace()</code>相同，返回一个新字符串，不会改变原字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>searchValue</code>是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有<code>g</code>修饰符）。</p>\n<p>如果<code>searchValue</code>是一个不带有<code>g</code>修饰符的正则表达式，<code>replaceAll()</code>会报错。这一点跟<code>replace()</code>不同。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，<code>/b/</code>不带有<code>g</code>修饰符，会导致<code>replaceAll()</code>报错。</p>\n<p><code>replaceAll()</code>的第二个参数<code>replacement</code>是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。</p>\n<ul>\n<li><code>$&amp;</code>：匹配的子字符串。</li>\n<li>`$``：匹配结果前面的文本。</li>\n<li><code>$'</code>：匹配结果后面的文本。</li>\n<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。</li>\n<li><code>$$</code>：指代美元符号<code>$</code>。</li>\n</ul>\n<p>下面是一些例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>replaceAll()</code>的第二个参数<code>replacement</code>除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数<code>searchValue</code>匹配的文本。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，<code>replaceAll()</code>的第二个参数是一个函数，该函数的返回值会替换掉所有<code>b</code>的匹配。</p>\n<p>这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面例子中，正则表达式有三个组匹配，所以<code>replacer()</code>函数的第一个参数<code>match</code>是捕捉到的匹配内容（即字符串<code>123abc456</code>），后面三个参数<code>p1</code>、<code>p2</code>、<code>p3</code>则依次为三个组匹配。</p>\n<h3> 总结</h3>\n<ol>\n<li>\n<p>会改变原字符串的方法：</p>\n<ul>\n<li>暂无</li>\n</ul>\n</li>\n<li>\n<p>返回新字符串，不会改变原字符串的方法：</p>\n<ul>\n<li>concat()</li>\n<li>slice()</li>\n<li>substring()</li>\n<li>substr()</li>\n<li>trim()</li>\n<li>trimStart()，trimEnd()</li>\n<li>toLowerCase()，toUpperCase()</li>\n<li>repeat()</li>\n<li>padStart()，padEnd()</li>\n</ul>\n</li>\n</ol>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "7.Object",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses7.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses7.html",
      "summary": "几个基础关注点 表达式还是语句？ 对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？ JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。 为了避免这种歧义，J...",
      "content_html": "<h1> Object</h1>\n<h2> 几个基础关注点</h2>\n<h3> 表达式还是语句？</h3>\n<p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含<code>foo</code>属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签<code>foo</code>，指向表达式<code>123</code>。</p>\n<p>为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的语句是一个代码块，而且只有解释为代码块，才能执行。</p>\n<p>如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种差异在<code>eval</code>语句（作用是对字符串求值）中反映得最明显。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果没有圆括号，<code>eval</code>将其理解为一个代码块；加上圆括号以后，就理解成一个对象。</p>\n<h3> delete 命令</h3>\n<p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>delete</code>命令删除对象<code>obj</code>的<code>p</code>属性。删除后，再读取<code>p</code>属性就会返回<code>undefined</code>，而且<code>Object.keys</code>方法的返回值也不再包括该属性。</p>\n<p><strong>注意，删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>obj</code>并没有<code>p</code>属性，但是<code>delete</code>命令照样返回<code>true</code>。因此，不能根据<code>delete</code>命令的结果，认定某个属性是存在的。</p>\n<p><strong>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码之中，对象<code>obj</code>的<code>p</code>属性是不能删除的，所以<code>delete</code>命令返回<code>false</code><strong>（另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性）。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值。</p>\n<h3> in 运算符</h3>\n<p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象<code>obj</code>本身并没有<code>toString</code>属性，但是<code>in</code>运算符会返回<code>true</code>，因为这个属性是继承的。</p>\n<p>这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 属性的简洁表示法</h3>\n<p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，变量<code>foo</code>直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除了属性简写，方法也可以简写。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面是一个实际的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种写法用于函数的返回值，将会非常方便。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>CommonJS 模块输出一组变量，就非常合适使用简洁写法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>简洁写法在打印对象时也很有用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>console.log</code>直接输出<code>user</code>和<code>foo</code>两个对象时，就是两组键值对，可能会混淆。把它们放在大括号里面输出，就变成了对象的简洁表示法，每组键值对前面会打印对象名，这样就比较清晰了。</p>\n<p>注意，简写的对象方法不能用作构造函数，会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>f</code>是一个简写的对象方法，所以<code>obj.f</code>不能当作构造函数使用。</p>\n<h3> 属性名表达式</h3>\n<p>JavaScript 定义对象的属性，有两种方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>\n<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是另一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>表达式还可以用于定义方法名。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p>\n<h3> 方法的 name 属性</h3>\n<p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，方法的<code>name</code>属性返回函数名（即方法名）。</p>\n<p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>key1</code>对应的 Symbol 值有描述，<code>key2</code>没有。</p>\n<h3> with 语句</h3>\n<p><code>with</code>语句的格式如下：</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>obj</code>并没有<code>p1</code>属性，对<code>p1</code>赋值等于创造了一个全局变量<code>p1</code>。正确的写法应该是，先定义对象<code>obj</code>的属性<code>p1</code>，然后在<code>with</code>区块内操作它。</p>\n<p><strong>这是因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>单纯从上面的代码块，根本无法判断<code>x</code>到底是全局变量，还是对象<code>obj</code>的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。</p>\n<p><strong>因此，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> Object 构造函数</h2>\n<p><code>Object</code>不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用<code>new</code>命令。</p>\n<p><strong><code>Object</code>构造函数的首要用途，是直接通过它来生成新对象。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><blockquote>\n<p>注意，通过<code>var obj = new Object()</code>的写法生成新对象，与字面量的写法<code>var obj = {}</code>是等价的。或者说，后者只是前者的一种简便写法。</p>\n</blockquote>\n<p><code>Object</code>构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>虽然用法相似，但是<code>Object(value)</code>与<code>new Object(value)</code>两者的语义是不同的，<code>Object(value)</code>表示将<code>value</code>转成一个对象，<code>new Object(value)</code>则表示新生成一个对象，它的值是<code>value</code>。</strong></p>\n<h2> 元属性</h2>\n<h3> 概述</h3>\n<p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p>\n<p>下面是属性描述对象的一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>属性描述对象提供6个元属性。</p>\n<p>（1）<code>value</code></p>\n<p><code>value</code>是该属性的属性值，默认为<code>undefined</code>。</p>\n<p>（2）<code>writable</code></p>\n<p><code>writable</code>是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为<code>true</code>。</p>\n<p>（3）<code>enumerable</code></p>\n<p><code>enumerable</code>是一个布尔值，表示该属性是否可遍历，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>）跳过该属性。</p>\n<p>（4）<code>configurable</code></p>\n<p><code>configurable</code>是一个布尔值，表示可配置性，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（<code>value</code>属性除外）。也就是说，<code>configurable</code>属性控制了属性描述对象的可写性。</p>\n<p>（5）<code>get</code></p>\n<p><code>get</code>是一个函数，表示该属性的取值函数（getter），默认为<code>undefined</code>。</p>\n<p>（6）<code>set</code></p>\n<p><code>set</code>是一个函数，表示该属性的存值函数（setter），默认为<code>undefined</code>。</p>\n<h4> value</h4>\n<p><code>value</code>属性是目标属性的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码是通过<code>value</code>属性，读取或改写<code>obj.p</code>的例子。</p>\n<h4> writable</h4>\n<p><code>writable</code>属性是一个布尔值，决定了目标属性的值（value）是否可以被改变。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>obj.a</code>的<code>writable</code>属性是<code>false</code>。然后，改变<code>obj.a</code>的值，不会有任何效果。</p>\n<p>注意，正常模式下，对<code>writable</code>为<code>false</code>的属性赋值不会报错，只会默默失败。但是，严格模式下会报错，即使对<code>a</code>属性重新赋予一个同样的值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码是严格模式，对<code>obj.a</code>任何赋值行为都会报错。</p>\n<p>如果原型对象的某个属性的<code>writable</code>为<code>false</code>，那么子对象将无法自定义这个属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>proto</code>是原型对象，它的<code>foo</code>属性不可写。<code>obj</code>对象继承<code>proto</code>，也不可以再自定义这个属性了。如果是严格模式，这样做还会抛出一个错误。</p>\n<p>但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> enumerable</h4>\n<p><code>enumerable</code>（可遍历性）返回一个布尔值，表示目标属性是否可遍历。</p>\n<p>JavaScript 的早期版本，<code>for...in</code>循环是基于<code>in</code>运算符的。我们知道，<code>in</code>运算符不管某个属性是对象自身的还是继承的，都会返回<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>toString</code>不是<code>obj</code>对象自身的属性，但是<code>in</code>运算符也返回<code>true</code>，这导致了<code>toString</code>属性也会被<code>for...in</code>循环遍历。</p>\n<p>这显然不太合理，后来就引入了“可遍历性”这个概念。只有可遍历的属性，才会被<code>for...in</code>循环遍历，同时还规定<code>toString</code>这一类实例对象继承的原生属性，都是不可遍历的，这样就保证了<code>for...in</code>循环的可用性。</p>\n<p>具体来说，如果一个属性的<code>enumerable</code>为<code>false</code>，下面三个操作不会取到该属性。</p>\n<ul>\n<li><code>for..in</code>循环</li>\n<li><code>Object.keys</code>方法</li>\n<li><code>JSON.stringify</code>方法</li>\n</ul>\n<p>因此，<code>enumerable</code>可以用来设置“秘密”属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>obj.x</code>属性的<code>enumerable</code>为<code>false</code>，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但不是真正的私有属性，还是可以直接获取它的值。</p>\n<p>注意，<code>for...in</code>循环包括继承的属性，<code>Object.keys</code>方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用<code>Object.getOwnPropertyNames</code>方法。</p>\n<p>另外，<code>JSON.stringify</code>方法会排除<code>enumerable</code>为<code>false</code>的属性，有时可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的<code>enumerable</code>设为<code>false</code>。</p>\n<h3> configurable</h3>\n<p><code>configurable</code>(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象。也就是说，<code>configurable</code>为<code>false</code>时，<code>value</code>、<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都不能被修改了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>obj.p</code>的<code>configurable</code>为<code>false</code>。然后，改动<code>value</code>、<code>writable</code>、<code>enumerable</code>、<code>configurable</code>，结果都报错。</p>\n<p>注意，<code>writable</code>只有在<code>false</code>改为<code>true</code>会报错，<code>true</code>改为<code>false</code>是允许的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>至于<code>value</code>，只要<code>writable</code>和<code>configurable</code>有一个为<code>true</code>，就允许改动。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，<code>writable</code>为<code>false</code>时，直接目标属性赋值，不报错，但不会成功。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>obj.p</code>的<code>writable</code>为<code>false</code>，对<code>obj.p</code>直接赋值不会生效。如果是严格模式，还会报错。</p>\n<p>可配置性决定了目标属性是否可以被删除（delete）。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>obj.p1</code>的<code>configurable</code>是<code>true</code>，所以可以被删除，<code>obj.p2</code>就无法删除。</p>\n<h2> 存取器</h2>\n<p>除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为<code>setter</code>，使用属性描述对象的<code>set</code>属性；取值函数称为<code>getter</code>，使用属性描述对象的<code>get</code>属性。</p>\n<p>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如定制属性的读取和赋值行为。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>obj.p</code>定义了<code>get</code>和<code>set</code>属性。<code>obj.p</code>取值时，就会调用<code>get</code>；赋值时，就会调用<code>set</code>。</p>\n<p>JavaScript 还提供了存取器的另一种写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面两种写法，虽然属性<code>p</code>的读取和赋值行为是一样的，但是有一些细微的区别。第一种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>false</code>，从而导致属性<code>p</code>是不可遍历的；第二种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>true</code>，因此属性<code>p</code>是可遍历的。实际开发中，写法二更常用。</p>\n<p>注意，取值函数<code>get</code>不能接受参数，存值函数<code>set</code>只能接受一个参数（即属性的值）。</p>\n<p>存取器往往用于，属性的值依赖对象内部数据的场合。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>next</code>属性的存值函数和取值函数，都依赖于内部属性<code>$n</code>。</p>\n<h2> this 关键字</h2>\n<h3> 含义</h3>\n<p><code>this</code>关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。</p>\n<p>前一章已经提到，<code>this</code>可以用在构造函数之中，表示实例对象。除此之外，<code>this</code>还可以用在别的场合。但不管是什么场合，<code>this</code>都有一个共同点：它总是返回一个对象。</p>\n<p>简单说，<code>this</code>就是属性或方法“当前”所在的对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>this</code>就代表<code>property</code>属性当前所在的对象。</p>\n<p>下面是一个实际的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>this.name</code>表示<code>name</code>属性所在的那个对象。由于<code>this.name</code>是在<code>describe</code>方法中调用，而<code>describe</code>方法所在的当前对象是<code>person</code>，因此<code>this</code>指向<code>person</code>，<code>this.name</code>就是<code>person.name</code>。</p>\n<p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即<code>this</code>的指向是可变的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>A.describe</code>属性被赋给<code>B</code>，于是<code>B.describe</code>就表示<code>describe</code>方法所在的当前对象是<code>B</code>，所以<code>this.name</code>就指向<code>B.name</code>。</p>\n<p>稍稍重构这个例子，<code>this</code>的动态指向就能看得更清楚。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，函数<code>f</code>内部使用了<code>this</code>关键字，随着<code>f</code>所在的对象不同，<code>this</code>的指向也不同。</p>\n<p>只要函数被赋给另一个变量，<code>this</code>的指向就会变。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>A.describe</code>被赋值给变量<code>f</code>，内部的<code>this</code>就会指向<code>f</code>运行时所在的对象（本例是顶层对象）。</p>\n<p>总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，<code>this</code>就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，<code>this</code>的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。</p>\n<h3> 实质</h3>\n<p>JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码将一个对象赋值给变量<code>obj</code>。JavaScript 引擎会先在内存里面，生成一个对象<code>{ foo: 5 }</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。也就是说，变量<code>obj</code>是一个地址（reference）。后面如果要读取<code>obj.foo</code>，引擎先从<code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的<code>foo</code>属性。</p>\n<p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的<code>foo</code>属性，实际上是以下面的形式保存的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>foo</code>属性的值保存在属性描述对象的<code>value</code>属性里面。</p>\n<p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给<code>foo</code>属性的<code>value</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供。</p>\n<p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>；在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>。</p>\n<h3> 使用场合</h3>\n<p><code>this</code>主要有以下几个使用场合。</p>\n<h4> 全局环境</h4>\n<p>全局环境使用<code>this</code>，它指的就是顶层对象<code>window</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，<code>this</code>就是指顶层对象<code>window</code>。</p>\n<h4> 构造函数</h4>\n<p>构造函数中的<code>this</code>，指的是实例对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码定义了一个构造函数<code>Obj</code>。由于<code>this</code>指向实例对象，所以在构造函数内部定义<code>this.p</code>，就相当于定义实例对象有一个<code>p</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 对象的方法</h4>\n<p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变<code>this</code>的指向。</p>\n<p>但是，这条规则很不容易把握。请看下面的代码。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>obj.foo</code>方法执行时，它内部的<code>this</code>指向<code>obj</code>。</p>\n<p>但是，下面这几种用法，都会改变<code>this</code>的指向。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>obj.foo</code>就是一个值。这个值真正调用的时候，运行环境已经不是<code>obj</code>了，而是全局环境，所以<code>this</code>不再指向<code>obj</code>。</p>\n<p>可以这样理解，JavaScript 引擎内部，<code>obj</code>和<code>obj.foo</code>储存在两个内存地址，称为地址一和地址二。<code>obj.foo()</code>这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，<code>this</code>指向<code>obj</code>。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此<code>this</code>指向全局环境。上面三种情况等同于下面的代码。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果<code>this</code>所在的方法不在对象的第一层，这时<code>this</code>只是指向当前一层的对象，而不会继承更上面的层。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>a.b.m</code>方法在<code>a</code>对象的第二层，该方法内部的<code>this</code>不是指向<code>a</code>，而是指向<code>a.b</code>，因为实际执行的是下面的代码。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果要达到预期效果，只有写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果这时将嵌套对象内部的方法赋值给一个变量，<code>this</code>依然会指向全局对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>m</code>是多层对象内部的一个方法。为求简便，将其赋值给<code>hello</code>变量，结果调用时，<code>this</code>指向了顶层对象。为了避免这个问题，可以只将<code>m</code>所在的对象赋值给<code>hello</code>，这样调用时，<code>this</code>的指向就不会变。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 使用注意点</h3>\n<h4> 避免多层 this</h4>\n<p>由于<code>this</code>的指向是不确定的，所以切勿在函数中包含多层的<code>this</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码包含两层<code>this</code>，结果运行后，第一层指向对象<code>o</code>，第二层指向全局对象，因为实际执行的是下面的代码。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>一个解决方法是在第二层改用一个指向外层<code>this</code>的变量。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码定义了变量<code>that</code>，固定指向外层的<code>this</code>，然后在内层使用<code>that</code>，就不会发生<code>this</code>指向的改变。</p>\n<p>事实上，使用一个变量固定<code>this</code>的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</p>\n<p>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的<code>this</code>指向顶层对象，就会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>inc</code>方法通过<code>'use strict'</code>声明采用严格模式，这时内部的<code>this</code>一旦指向顶层对象，就会报错。</p>\n<h4> 避免数组处理方法中的 this</h4>\n<p>数组的<code>map</code>和<code>foreach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用<code>this</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>foreach</code>方法的回调函数中的<code>this</code>，其实是指向<code>window</code>对象，因此取不到<code>o.v</code>的值。原因跟上一段的多层<code>this</code>是一样的，就是内层的<code>this</code>不指向外部，而指向顶层对象。</p>\n<p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定<code>this</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另一种方法是将<code>this</code>当作<code>foreach</code>方法的第二个参数，固定它的运行环境。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 避免回调函数中的 this</h4>\n<p>回调函数中的<code>this</code>往往会改变指向，最好避免使用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，点击按钮以后，控制台会显示<code>false</code>。原因是此时<code>this</code>不再指向<code>o</code>对象，而是指向按钮的 DOM 对象，因为<code>f</code>方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p>\n<p>为了解决这个问题，可以采用下面的一些方法对<code>this</code>进行绑定，也就是使得<code>this</code>固定指向某个对象，减少不确定性。</p>\n<h3> 绑定 this 的方法</h3>\n<p><code>this</code>的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把<code>this</code>固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换/固定<code>this</code>的指向。</p>\n<h4> Function.prototype.call()</h4>\n<p>函数实例的<code>call</code>方法，可以指定函数内部<code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，全局环境运行函数<code>f</code>时，<code>this</code>指向全局环境（浏览器为<code>window</code>对象）；<code>call</code>方法可以改变<code>this</code>的指向，指定<code>this</code>指向对象<code>obj</code>，然后在对象<code>obj</code>的作用域中运行函数<code>f</code>。</p>\n<p><code>call</code>方法的参数，应该是一个对象。如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>a</code>函数中的<code>this</code>关键字，如果指向全局对象，返回结果为<code>123</code>。如果使用<code>call</code>方法将<code>this</code>关键字指向<code>obj</code>对象，返回结果为<code>456</code>。可以看到，如果<code>call</code>方法没有参数，或者参数为<code>null</code>或<code>undefined</code>，则等同于指向全局对象。</p>\n<p>如果<code>call</code>方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入<code>call</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>call</code>的参数为<code>5</code>，不是对象，会被自动转成包装对象（<code>Number</code>的实例），绑定<code>f</code>内部的<code>this</code>。</p>\n<p><code>call</code>方法还可以接受多个参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>call</code>的第一个参数就是<code>this</code>所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>call</code>方法指定函数<code>add</code>内部的<code>this</code>绑定当前环境（对象），并且参数为<code>1</code>和<code>2</code>，因此函数<code>add</code>运行后得到<code>3</code>。</p>\n<p><code>call</code>方法的一个应用是调用对象的原生方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>hasOwnProperty</code>是<code>obj</code>对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code>call</code>方法可以解决这个问题，它将<code>hasOwnProperty</code>方法的原始定义放到<code>obj</code>对象上执行，这样无论<code>obj</code>上有没有同名方法，都不会影响结果。</p>\n<h4> Function.prototype.apply()</h4>\n<p><code>apply</code>方法的作用与<code>call</code>方法类似，也是改变<code>this</code>指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>apply</code>方法的第一个参数也是<code>this</code>所要指向的那个对象，如果设为<code>null</code>或<code>undefined</code>，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在<code>call</code>方法中必须一个个添加，但是在<code>apply</code>方法中，必须以数组形式添加。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>f</code>函数本来接受两个参数，使用<code>apply</code>方法以后，就变成可以接受一个数组作为参数。</p>\n<p>利用这一点，可以做一些有趣的应用。</p>\n<p><strong>（1）找出数组最大元素</strong></p>\n<p>JavaScript 不提供找出数组最大元素的函数。结合使用<code>apply</code>方法和<code>Math.max</code>方法，就可以返回数组的最大元素。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）将数组的空元素变为<code>undefined</code></strong></p>\n<p>通过<code>apply</code>方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code>。因此，遍历内部元素的时候，会得到不同的结果。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>（3）转换类似数组的对象</strong></p>\n<p>另外，利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如<code>arguments</code>对象）转为真正的数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>apply</code>方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有<code>length</code>属性，以及相对应的数字键。</p>\n<p><strong>（4）绑定回调函数的对象</strong></p>\n<p>前面的按钮点击事件的例子，可以改写如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，点击按钮以后，控制台将会显示<code>true</code>。由于<code>apply()</code>方法（或者<code>call()</code>方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的<code>bind()</code>方法。</p>\n<h4> Function.prototype.bind()</h4>\n<p><code>bind()</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，我们将<code>d.getTime()</code>方法赋给变量<code>print</code>，然后调用<code>print()</code>就报错了。这是因为<code>getTime()</code>方法内部的<code>this</code>，绑定<code>Date</code>对象的实例，赋给变量<code>print</code>以后，内部的<code>this</code>已经不指向<code>Date</code>对象的实例了。</p>\n<p><code>bind()</code>方法可以解决这个问题。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>bind()</code>方法将<code>getTime()</code>方法内部的<code>this</code>绑定到<code>d</code>对象，这时就可以安全地将这个方法赋值给其他变量了。</p>\n<p><code>bind</code>方法的参数就是所要绑定<code>this</code>的对象，下面是一个更清晰的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>counter.inc()</code>方法被赋值给变量<code>func</code>。这时必须用<code>bind()</code>方法将<code>inc()</code>内部的<code>this</code>，绑定到<code>counter</code>，否则就会出错。</p>\n<p><code>this</code>绑定到其他对象也是可以的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>bind()</code>方法将<code>inc()</code>方法内部的<code>this</code>，绑定到<code>obj</code>对象。结果调用<code>func</code>函数以后，递增的就是<code>obj</code>内部的<code>count</code>属性。</p>\n<p><code>bind()</code>还可以接受更多的参数，将这些参数绑定原函数的参数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>bind()</code>方法除了绑定<code>this</code>对象，还将<code>add()</code>函数的第一个参数<code>x</code>绑定成<code>5</code>，然后返回一个新函数<code>newAdd()</code>，这个函数只要再接受一个参数<code>y</code>就能运行了。</p>\n<p>如果<code>bind()</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（浏览器为<code>window</code>）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>add()</code>内部并没有<code>this</code>，使用<code>bind()</code>方法的主要目的是绑定参数<code>x</code>，以后每次运行新函数<code>plus5()</code>，就只需要提供另一个参数<code>y</code>就够了。而且因为<code>add()</code>内部没有<code>this</code>，所以<code>bind()</code>的第一个参数是<code>null</code>，不过这里如果是其他对象，也没有影响。</p>\n<p><code>bind()</code>方法有一些使用注意点。</p>\n<p><strong>（1）每一次返回一个新函数</strong></p>\n<p><code>bind()</code>方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>click</code>事件绑定<code>bind()</code>方法生成的一个匿名函数。这样会导致无法取消绑定，所以下面的代码是无效的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>正确的方法是写成下面这样：</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（2）结合回调函数使用</strong></p>\n<p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含<code>this</code>的方法直接当作回调函数。解决方法就是使用<code>bind()</code>方法，将<code>counter.inc()</code>绑定<code>counter</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>callIt()</code>方法会调用回调函数。这时如果直接把<code>counter.inc</code>传入，调用时<code>counter.inc()</code>内部的<code>this</code>就会指向全局对象。使用<code>bind()</code>方法将<code>counter.inc</code>绑定<code>counter</code>以后，就不会有这个问题，<code>this</code>总是指向<code>counter</code>。</p>\n<p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的<code>this</code>指向，很可能也会出错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>obj.print</code>内部<code>this.times</code>的<code>this</code>是指向<code>obj</code>的，这个没有问题。但是，<code>forEach()</code>方法的回调函数内部的<code>this.name</code>却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>解决这个问题，也是通过<code>bind()</code>方法绑定<code>this</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>（3）结合<code>call()</code>方法使用</strong></p>\n<p>利用<code>bind()</code>方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的<code>slice()</code>方法为例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码中，数组的<code>slice</code>方法从<code>[1, 2, 3]</code>里面，按照指定的开始位置和结束位置，切分出另一个数组。这样做的本质是在<code>[1, 2, 3]</code>上面调用<code>Array.prototype.slice()</code>方法，因此可以用<code>call</code>方法表达这个过程，得到同样的结果。</p>\n<p><code>call()</code>方法实质上是调用<code>Function.prototype.call()</code>方法，因此上面的表达式可以用<code>bind()</code>方法改写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的含义就是，将<code>Array.prototype.slice</code>变成<code>Function.prototype.call</code>方法所在的对象，调用时就变成了<code>Array.prototype.slice.call</code>。类似的写法还可以用于其他数组方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果再进一步，将<code>Function.prototype.call</code>方法绑定到<code>Function.prototype.bind</code>对象，就意味着<code>bind</code>的调用形式也可以被改写。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的含义就是，将<code>Function.prototype.bind</code>方法绑定在<code>Function.prototype.call</code>上面，所以<code>bind</code>方法就可以直接使用，不需要在函数实例上使用。</p>\n<h2> super 关键字</h2>\n<p>我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，<strong>指向当前对象的原型对象</strong>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，对象<code>obj.find()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p>\n<p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的<code>super</code>都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p>\n<p><strong>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>\n<h2> 对象的继承</h2>\n<h3> 原型对象概述</h3>\n<h4> 构造函数的缺点</h4>\n<p>JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Cat</code>函数是一个构造函数，函数内部定义了<code>name</code>属性和<code>color</code>属性，所有实例对象（上例是<code>cat1</code>）都会生成这两个属性，即这两个属性会定义在实例对象上面。</p>\n<p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>cat1</code>和<code>cat2</code>是同一个构造函数的两个实例，它们都具有<code>meow</code>方法。由于<code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个<code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有<code>meow</code>方法都是同样的行为，完全应该共享。</p>\n<p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p>\n<h4> prototype 属性的作用</h4>\n<p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>\n<p>下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个<code>prototype</code>属性，指向一个对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，函数<code>f</code>默认具有<code>prototype</code>属性，指向一个对象。</p>\n<p>对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加一个<code>color</code>属性，结果，实例对象都共享了该属性。</p>\n<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在<strong>所有</strong>实例对象上。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，原型对象的<code>color</code>属性的值变为<code>yellow</code>，两个实例对象的<code>color</code>属性立刻跟着变了。这是因为实例对象其实没有<code>color</code>属性，都是读取原型对象的<code>color</code>属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。</p>\n<p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，实例对象<code>cat1</code>的<code>color</code>属性改为<code>black</code>，就使得它不再去原型对象读取<code>color</code>属性，后者的值依然为<code>yellow</code>。</p>\n<p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Animal.prototype</code>对象上面定义了一个<code>walk</code>方法，这个方法将可以在所有<code>Animal</code>实例对象上面调用。</p>\n<h4> 原型链</h4>\n<p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p>\n<p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p>\n<p>用一张图表示关系：</p>\n<p></p>\n<p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，<code>Object.prototype</code>对象的原型是<code>null</code>，由于<code>null</code>没有任何属性，所以原型链到此为止。<code>Object.getPrototypeOf</code>方法返回参数对象的原型，具体介绍请看后文。</p>\n<p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p>\n<p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>\n<p>举例来说，如果让构造函数的<code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>mine</code>是构造函数<code>MyArray</code>的实例对象，由于<code>MyArray.prototype</code>指向一个数组实例，使得<code>mine</code>可以调用数组方法（这些方法定义在数组实例的<code>prototype</code>对象上面）。最后那行<code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明<code>mine</code>为<code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文。</p>\n<p>上面代码还出现了原型对象的<code>constructor</code>属性，这个属性的含义下一节就来解释。</p>\n<h4> constructor 属性</h4>\n<p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。</p>\n<p><code>constructor</code>属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>constructor</code>属性确定了实例对象<code>f</code>的构造函数是<code>F</code>，而不是<code>RegExp</code>。</p>\n<p>另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>x</code>是构造函数<code>Constr</code>的实例，可以从<code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例。</p>\n<p><code>constructor</code>属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>。</p>\n<p>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真。</p>\n<p>如果不能确定<code>constructor</code>属性是什么函数，还有一个办法：通过<code>name</code>属性，从实例得到构造函数的名称。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> <code>__proto__</code>属性</h4>\n<p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>\n<p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> instanceof 运算符</h3>\n<p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>v</code>是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>。</p>\n<p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Vehicle</code>是对象<code>v</code>的构造函数，它的原型对象是<code>Vehicle.prototype</code>，<code>isPrototypeOf()</code>方法是 JavaScript 提供的原生方法，用于检查某个对象是否为另一个对象的原型，详细解释见后文。</p>\n<p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>。</p>\n<p>由于任意对象（除了<code>null</code>）都是<code>Object</code>的实例，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，除了<code>null</code>，其他对象的<code>instanceOf Object</code>的运算结果都是<code>true</code>。</p>\n<p><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create()</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。这是唯一的<code>instanceof</code>运算符判断会失真的情况（一个对象的原型是<code>null</code>）。</p>\n<p><code>instanceof</code>运算符的一个用处，是判断值的类型。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象。</p>\n<p>注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>。</p>\n<p>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，忘了加<code>new</code>命令的问题。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p>\n<h3> 构造函数的继承</h3>\n<p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，就会让子类实例具有父类实例的属性。</p>\n<p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p>\n<p>另外一种写法是<code>Sub.prototype</code>等于一个父类实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p>\n<p>举例来说，下面是一个<code>Shape</code>构造函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法。</p>\n<h3> 多重继承</h3>\n<p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p>\n<h2> Object 的静态方法</h2>\n<h3> Object.is()</h3>\n<p><strong>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。</strong></p>\n<p>JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>ES5 可以通过下面的代码，部署<code>Object.is</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.getOwnPropertyDescriptor()</h3>\n<p><code>**Object.getOwnPropertyDescriptor()</code>方法可以获取属性描述对象。**</p>\n<p><strong>它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Object.getOwnPropertyDescriptor()</code>方法获取<code>obj.p</code>的属性描述对象。</p>\n<p><strong>注意，<code>Object.getOwnPropertyDescriptor()</code>方法只能用于对象自身的属性，不能用于继承的属性。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>toString</code>是<code>obj</code>对象继承的属性<code>Object.getOwnPropertyDescriptor()</code>无法获取。</p>\n<h3> Object.getOwnPropertyDescriptors()</h3>\n<p>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。</p>\n<p><strong>ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>上面代码中，<code>Object.getOwnPropertyDescriptors()</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</strong></p>\n<p>该方法的实现非常容易。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>\n<p>这时，<code>Object.getOwnPropertyDescriptors()</code>方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>Object.getOwnPropertyDescriptors()</code>方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码会克隆对象<code>obj</code>。</p>\n<p><strong>另外，<code>Object.getOwnPropertyDescriptors()</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>ES6 规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>有了<code>Object.getOwnPropertyDescriptors()</code>，我们就有了另一种写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>Object.getOwnPropertyDescriptors()</code>也可以用来实现 Mixin（混入）模式。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。</p>\n<p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors()</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors()</code>方法。</p>\n<h3> Object.getOwnPropertyNames()</h3>\n<p><strong><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>obj.p1</code>是可遍历的，<code>obj.p2</code>是不可遍历的。<code>Object.getOwnPropertyNames</code>会将它们都返回。</p>\n<p><strong>这跟<code>Object.keys</code>的行为不同，<code>Object.keys</code>只返回对象自身的可遍历属性的全部属性名。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，数组自身的<code>length</code>属性是不可遍历的，<code>Object.keys</code>不会返回该属性。第二个例子的<code>Object.prototype</code>也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的。</p>\n<h3> Object.getOwnPropertySymbols(obj)</h3>\n<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>\n<p>与<code>Object.getOwnPropertyNames()</code>类似，您可以将给定对象的所有符号属性作为 Symbol 数组获取。 请注意，<code>Object.getOwnPropertyNames()</code>本身不包含对象的 Symbol 属性，只包含字符串属性。</p>\n<p>因为所有的对象在初始化的时候不会包含任何的 Symbol，除非你在对象上赋值了 Symbol 否则<code>Object.getOwnPropertySymbols()</code>只会返回一个空的数组。</p>\n<p><strong>示例</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.keys()</h3>\n<p><strong>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>ES2017 <a href=\"https://github.com/tc39/proposal-object-values-entries\" target=\"_blank\" rel=\"noopener noreferrer\">引入</a>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.values()</h3>\n<p><strong><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p>\n<p><code>Object.values</code>只返回对象自身的可遍历属性。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p>\n<p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Object.entries()</h3>\n<p><strong><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p>\n<p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非 Symbol 值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p>\n<p><code>Object.entries</code>的基本用途是遍历对象的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>自己实现<code>Object.entries</code>方法，非常简单。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.defineProperty()，Object.defineProperties()</h3>\n<p><code>Object.defineProperty()</code>方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Object.defineProperty</code>方法接受三个参数，依次如下。</p>\n<ul>\n<li>object：属性所在的对象</li>\n<li>propertyName：字符串，表示属性名</li>\n<li>attributesObject：属性描述对象</li>\n</ul>\n<p>举例来说，定义<code>obj.p</code>可以写成下面这样。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Object.defineProperty()</code>方法定义了<code>obj.p</code>属性。由于属性描述对象的<code>writable</code>属性为<code>false</code>，所以<code>obj.p</code>属性不可写。注意，这里的<code>Object.defineProperty</code>方法的第一个参数是<code>{}</code>（一个新建的空对象），<code>p</code>属性直接定义在这个空对象上面，然后返回这个对象，这是<code>Object.defineProperty()</code>的常见用法。</p>\n<p>如果属性已经存在，<code>Object.defineProperty()</code>方法相当于更新该属性的属性描述对象。</p>\n<p>如果一次性定义或修改多个属性，可以使用<code>Object.defineProperties()</code>方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Object.defineProperties()</code>同时定义了<code>obj</code>对象的三个属性。其中，<code>p3</code>属性定义了取值函数<code>get</code>，即每次读取该属性，都会调用这个取值函数。</p>\n<p>注意，一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性，否则会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，同时定义了<code>get</code>属性和<code>value</code>属性，以及将<code>writable</code>属性设为<code>true</code>，就会报错。</p>\n<p><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>参数里面的属性描述对象，<code>writable</code>、<code>configurable</code>、<code>enumerable</code>这三个属性的默认值都为<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，定义<code>obj.foo</code>时用了一个空的属性描述对象，就可以看到各个元属性的默认值。</p>\n<h3> Object.setPrototypeOf()</h3>\n<p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>该方法等同于下面的函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p>\n<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Object.getPrototypeOf()</h3>\n<p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果参数不是对象，会被自动转为对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Object.create()</h3>\n<p>生成实例对象的常用方法是，使用<code>new</code>命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？</p>\n<p>JavaScript 提供了<code>Object.create()</code>方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Object.create()</code>方法以<code>A</code>对象为原型，生成了<code>B</code>对象。<code>B</code>继承了<code>A</code>的所有属性和方法。</p>\n<p>实际上，<code>Object.create()</code>方法可以用下面的代码代替。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表明，<code>Object.create()</code>方法的实质是新建一个空的构造函数<code>F</code>，然后让<code>F.prototype</code>属性指向参数对象<code>obj</code>，最后返回一个<code>F</code>的实例，从而实现让该实例继承<code>obj</code>的属性。</p>\n<p>下面三种方式生成的新对象是等价的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果想要生成一个不继承任何属性（比如没有<code>toString()</code>和<code>valueOf()</code>方法）的对象，可以将<code>Object.create()</code>的参数设为<code>null</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>obj</code>的原型是<code>null</code>，它就不具备一些定义在<code>Object.prototype</code>对象上面的属性，比如<code>valueOf()</code>方法。</p>\n<p>使用<code>Object.create()</code>方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Object.create()</code>方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，修改对象原型<code>obj1</code>会影响到实例对象<code>obj2</code>。</p>\n<p>除了对象的原型，<code>Object.create()</code>方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Object.create()</code>方法生成的对象，继承了它的原型对象的构造函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>b</code>对象的原型是<code>a</code>对象，因此继承了<code>a</code>对象的构造函数<code>A</code>。</p>\n<h3> Object.assign()</h3>\n<h4> 基本用法</h4>\n<p><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>\n<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果只有一个参数，<code>Object.assign()</code>会直接返回该参数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果该参数不是对象，则会先转成对象，然后返回。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign()</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>\n<p><code>Object.assign()</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Object.assign()</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p>\n<p>属性名为 Symbol 值的属性，也会被<code>Object.assign()</code>拷贝。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 注意点</h4>\n<p><strong>（1）浅拷贝</strong></p>\n<p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign()</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>\n<p><strong>（2）同名属性的替换</strong></p>\n<p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>{ a: { b: 'hello', d: 'e' } }</code>的结果。这通常不是开发者想要的，需要特别小心。</p>\n<p>一些函数库提供<code>Object.assign()</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep()</code>方法），可以得到深拷贝的合并。</p>\n<p><strong>（3）数组的处理</strong></p>\n<p><code>Object.assign()</code>可以用来处理数组，但是会把数组视为对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Object.assign()</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p>\n<p><strong>（4）取值函数的处理</strong></p>\n<p><code>Object.assign()</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign()</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>\n<h4> 常见用途</h4>\n<p><code>Object.assign()</code>方法有很多用处。</p>\n<p><strong>（1）为对象添加属性</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面方法通过<code>Object.assign()</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p>\n<p><strong>（2）为对象添加方法</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign()</code>方法添加到<code>SomeClass.prototype</code>之中。</p>\n<p><strong>（3）克隆对象</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>\n<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（4）合并多个对象</strong></p>\n<p>将多个对象合并到某个对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>（5）为属性指定默认值</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign()</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>options</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p>\n<p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p>\n<h3> 控制对象状态</h3>\n<p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是<code>Object.preventExtensions</code>，其次是<code>Object.seal</code>，最强的是<code>Object.freeze</code>。</p>\n<h4> Object.preventExtensions()</h4>\n<p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>obj</code>对象经过<code>Object.preventExtensions</code>以后，就无法添加新属性了。</p>\n<h4> Object.isExtensible()</h4>\n<p><code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，检查是否可以为一个对象添加属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对<code>obj</code>对象使用<code>Object.preventExtensions</code>方法以后，再使用<code>Object.isExtensible</code>方法，返回<code>false</code>，表示已经不能添加新属性了。</p>\n<h4> Object.seal()</h4>\n<p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>obj</code>对象执行<code>Object.seal</code>方法以后，就无法添加新属性和删除旧属性了。</p>\n<p><code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，使用<code>Object.seal</code>方法之后，属性描述对象的<code>configurable</code>属性就变成了<code>false</code>，然后改变<code>enumerable</code>属性就会报错。</p>\n<p><code>Object.seal</code>只是禁止新增或删除属性，并不影响修改某个属性的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Object.seal</code>方法对<code>p</code>属性的<code>value</code>无效，是因为此时<code>p</code>属性的可写性由<code>writable</code>决定。</p>\n<h4> Object.isSealed()</h4>\n<p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这时，<code>Object.isExtensible</code>方法也返回<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Object.freeze()</h4>\n<p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，对<code>obj</code>对象进行<code>Object.freeze()</code>以后，修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错。</p>\n<h4> Object.isFrozen()</h4>\n<p><code>Object.isFrozen</code>方法用于检查一个对象是否使用了<code>Object.freeze</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>使用<code>Object.freeze</code>方法以后，<code>Object.isSealed</code>将会返回<code>true</code>，<code>Object.isExtensible</code>返回<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Object.isFrozen</code>的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，确认<code>obj</code>没有被冻结后，再对它的属性赋值，就不会报错了。</p>\n<h4> 局限性</h4>\n<p>上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>obj</code>本身不能新增属性，但是可以在它的原型对象上新增属性，就依然能够在<code>obj</code>上读到。</p>\n<p>一种解决方案是，把<code>obj</code>的原型也冻结住。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>obj.bar</code>属性指向一个数组，<code>obj</code>对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。</p>\n<h2> Object 的实例方法</h2>\n<h3> Object.prototype.valueOf()</h3>\n<p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码比较<code>obj.valueOf()</code>与<code>obj</code>本身，两者是一样的。</p>\n<p><code>valueOf</code>方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码将对象<code>obj</code>与数字<code>1</code>相加，这时 JavaScript 就会默认调用<code>valueOf()</code>方法，求出<code>obj</code>的值再与<code>1</code>相加。所以，如果自定义<code>valueOf</code>方法，就可以得到想要的结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码自定义了<code>obj</code>对象的<code>valueOf</code>方法，于是<code>1 + obj</code>就得到了<code>3</code>。这种方法就相当于用自定义的<code>obj.valueOf</code>，覆盖<code>Object.prototype.valueOf</code>。</p>\n<h3> Object.prototype.toString()</h3>\n<p><code>toString</code>方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，对于一个对象调用<code>toString</code>方法，会返回字符串<code>[object Object]</code>，该字符串说明对象的类型。</p>\n<p>字符串<code>[object Object]</code>本身没有太大的用处，但是通过自定义<code>toString</code>方法，可以让对象在自动类型转换时，得到想要的字符串形式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，当对象用于字符串加法时，会自动调用<code>toString</code>方法。由于自定义了<code>toString</code>方法，所以返回字符串<code>hello world</code>。</p>\n<p>数组、字符串、函数、Date 对象都分别部署了自定义的<code>toString</code>方法，覆盖了<code>Object.prototype.toString</code>方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，数组、字符串、函数、Date 对象调用<code>toString</code>方法，并不会返回<code>[object Object]</code>，因为它们都自定义了<code>toString</code>方法，覆盖原始方法。</p>\n<h3> Object.prototype.toLocaleString()</h3>\n<p><code>Object.prototype.toLocaleString</code>方法与<code>toString</code>的返回结果相同，也是返回一个值的字符串形式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的<code>toLocaleString</code>，用来返回针对某些地域的特定的值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>toString()</code>方法返回对象的一般字符串形式，<code>toLocaleString()</code>方法返回本地的字符串形式。</p>\n<p>目前，主要有三个对象自定义了<code>toLocaleString</code>方法。</p>\n<ul>\n<li>Array.prototype.toLocaleString()</li>\n<li>Number.prototype.toLocaleString()</li>\n<li>Date.prototype.toLocaleString()</li>\n</ul>\n<p>举例来说，日期的实例对象的<code>toString</code>和<code>toLocaleString</code>返回值就不一样，而且<code>toLocaleString</code>的返回值跟用户设定的所在地域相关。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> Object.prototype.hasOwnProperty()</h3>\n<p><code>Object.prototype.hasOwnProperty</code>方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>obj</code>自身具有<code>p</code>属性，所以返回<code>true</code>。<code>toString</code>属性是继承的，所以返回<code>false</code>。</p>\n<h3> Object.prototype.isPrototypeOf()</h3>\n<p><strong>实例对象的<code>isPrototypeOf</code>方法，用来判断该对象是否为参数对象的原型。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>o1</code>和<code>o2</code>都是<code>o3</code>的原型。这表明只要实例对象处在参数对象的原型链上，<code>isPrototypeOf</code>方法都返回<code>true</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，由于<code>Object.prototype</code>处于原型链的最顶端，所以对各种实例都返回<code>true</code>，只有直接继承自<code>null</code>的对象除外。</p>\n<h3> Object.prototype.propertyIsEnumerable()</h3>\n<p>实例对象的<code>propertyIsEnumerable()</code>方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回<code>false</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>obj.p</code>是可遍历的，而<code>obj.toString</code>是继承的属性。</p>\n<h2> 属性的可枚举性和遍历</h2>\n<h3> 可枚举性</h3>\n<p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>\n<p><strong>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</strong></p>\n<ul>\n<li><strong><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</strong></li>\n<li><strong><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</strong></li>\n<li><strong><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</strong></li>\n<li><strong><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</strong></li>\n</ul>\n<p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>\n<p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p>\n<h3> 属性的遍历</h3>\n<p>ES6 一共有 5 种方法可以遍历对象的属性。</p>\n<h4> for...in</h4>\n<p><strong><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</strong></p>\n<p><strong><code>for...in</code>循环用来遍历一个对象的全部属性。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>for...in</code>循环有两个使用注意点。</strong></p>\n<ul>\n<li><strong>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</strong></li>\n<li><strong>它不仅遍历对象自身的属性，还遍历继承的属性。</strong></li>\n</ul>\n<p>举例来说，对象都继承了<code>toString</code>属性，但是<code>for...in</code>循环不会遍历到这个属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，对象<code>obj</code>继承了<code>toString</code>属性，该属性不会被<code>for...in</code>循环遍历到，因为它默认是“不可遍历”的。关于对象属性的可遍历性，参见《标准库》章节中 Object 一章的介绍。</p>\n<p>如果继承的属性是可遍历的，那么就会被<code>for...in</code>循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> Object.keys(obj)</h4>\n<p><strong><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</strong></p>\n<h4> Object.getOwnPropertyNames(obj)</h4>\n<p><strong><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</strong></p>\n<h4> Object.getOwnPropertySymbols(obj)</h4>\n<p><strong><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</strong></p>\n<p>与<code>Object.getOwnPropertyNames()</code>类似，您可以将给定对象的所有符号属性作为 Symbol 数组获取。 请注意，<code>Object.getOwnPropertyNames()</code>本身不包含对象的 Symbol 属性，只包含字符串属性。</p>\n<p>因为所有的对象在初始化的时候不会包含任何的 Symbol，除非你在对象上赋值了 Symbol 否则<code>Object.getOwnPropertySymbols()</code>只会返回一个空的数组。</p>\n<p><strong>示例</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> Reflect.ownKeys(obj)</h4>\n<p><strong><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</strong></p>\n<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>\n<ul>\n<li><strong>首先遍历所有数值键，按照数值升序排列。</strong></li>\n<li><strong>其次遍历所有字符串键，按照加入时间升序排列。</strong></li>\n<li><strong>最后遍历所有 Symbol 键，按照加入时间升序排列。</strong></li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 Symbol 属性。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "8.Class",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses8.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses8.html",
      "summary": "Class 的由来 JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES...",
      "content_html": "<h1> Class</h1>\n<h2> Class 的由来</h2>\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>\n<p><strong>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</strong></p>\n<p><strong>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor()</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。这种新的 Class 写法，本质上与本章开头的 ES5 的构造函数<code>Point</code>是一致的。</p>\n<p><code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。注意，定义<code>toString()</code>方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</p>\n<p>ES6 的类，完全可以看作构造函数的另一种写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>\n<p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> Class 的本质</h2>\n<h3> 与JS类的转化</h3>\n<p>ES6 的类，完全可以看作构造函数的另一种写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>\n<p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>constructor()</code>、<code>toString()</code>、<code>toValue()</code>这三个方法，其实都是定义在<code>Point.prototype</code>上面。</p>\n<p>因此，在类的实例上面调用方法，其实就是调用原型上的方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor()</code>方法就是<code>B</code>类原型的<code>constructor()</code>方法。</p>\n<p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign()</code>方法可以很方便地一次向类添加多个方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>prototype</code>对象的<code>constructor()</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 注意点</h3>\n<p><strong>类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>toString()</code>方法是<code>Point</code>类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码采用 ES5 的写法，<code>toString()</code>方法就是可枚举的。</p>\n<h2> 基本语法</h2>\n<h3> Class 表达式</h3>\n<p>与函数一样，类也可以使用表达式的形式定义。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>Me</code>，但是<code>Me</code>只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用<code>MyClass</code>引用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码表示，<code>Me</code>只在 Class 内部有定义。</p>\n<p>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>采用 Class 表达式，可以写出立即执行的 Class。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>person</code>是一个立即执行的类的实例。</p>\n<h3> constructor 方法</h3>\n<p><code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，定义了一个空的类<code>Point</code>，JavaScript 引擎会自动为它添加一个空的<code>constructor()</code>方法。</p>\n<p><code>constructor()</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>constructor()</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p>\n<p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 取值函数（getter）和存值函数（setter）</h3>\n<p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>\n<p>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，存值函数和取值函数是定义在<code>html</code>属性的描述对象上面，这与 ES5 完全一致。</p>\n<h3> 实例属性的新写法</h3>\n<p><strong>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，实例属性<code>this._count</code>定义在<code>constructor()</code>方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。</p>\n<p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码，一眼就能看出，<code>foo</code>类有两个实例属性，一目了然。另外，写起来也比较简洁。</p>\n<h3> 属性表达式</h3>\n<p><strong>类的属性名，可以采用表达式。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的。</p>\n<h3> 注意点</h3>\n<h4> 严格模式</h4>\n<p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p>\n<h4> 不存在提升</h4>\n<p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>Foo</code>类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的代码不会报错，因为<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>已经有定义了。但是，如果存在<code>class</code>的提升，上面代码就会报错，因为<code>class</code>会被提升到代码头部，而<code>let</code>命令是不提升的，所以导致<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</p>\n<h4> 关于name 属性</h4>\n<p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p>\n<h4> 定义Generator 方法</h4>\n<p>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个 Generator 函数。<code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器。</p>\n<h4> this 的指向</h4>\n<p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</p>\n<p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另一种解决方法是使用箭头函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>箭头函数内部的<code>this</code>总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以<code>this</code>会总是指向实例对象。</p>\n<p>还有一种解决方法是使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 类的实例</h2>\n<p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>对象上），所以<code>hasOwnProperty()</code>方法返回<code>true</code>，而<code>toString()</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty()</code>方法返回<code>false</code>。这些都与 ES5 的行为保持一致。</p>\n<p>与 ES5 一样，类的所有实例共享一个原型对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。</p>\n<p>这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p>\n<blockquote>\n<p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf</code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p>\n</blockquote>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码在<code>p1</code>的原型上添加了一个<code>printName()</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p>\n<h2> 静态方法</h2>\n<h3> 基本使用</h3>\n<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>\n<h3> 注意点</h3>\n<p><strong>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p>\n<h3> 静态方法继承问题</h3>\n<p><strong>父类的静态方法，可以被子类继承。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p>\n<p><strong>静态方法也是可以从<code>super</code>对象上调用的。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 静态属性</h2>\n<p>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</p>\n<p><strong>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a href=\"https://github.com/tc39/proposal-class-fields\" target=\"_blank\" rel=\"noopener noreferrer\">提案</a>提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这个新写法大大方便了静态属性的表达。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>\n<h2> new.target 属性</h2>\n<h3> 基本用法</h3>\n<p><code>new</code>是从构造函数生成实例对象的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码确保构造函数只能通过<code>new</code>命令调用。</p>\n<p>Class 内部调用<code>new.target</code>，返回当前 Class。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>new.target</code>会返回子类。</p>\n<h3> 实现必须继承后使用的类</h3>\n<p><strong>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>Shape</code>类不能被实例化，只能用于继承。</p>\n<p>注意，在函数外部，使用<code>new.target</code>会报错。</p>\n<h2> 私有方法和私有属性</h2>\n<h3> 现有的解决方案</h3>\n<p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p>\n<p>一种做法是在命名上加以区别。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>_bar()</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>\n<p>另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>foo</code>是公开方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar()</code>实际上成为了当前类的私有方法。</p>\n<p>还有一种方法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，Symbol 值的属性名依然可以从类的外部拿到。</p>\n<h3> 私有属性的提案</h3>\n<p>目前，有一个<a href=\"https://github.com/tc39/proposal-private-methods\" target=\"_blank\" rel=\"noopener noreferrer\">提案</a>，为<code>class</code>加了私有属性。方法是在属性名之前，使用<code>#</code>表示。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码在类的外部，读取私有属性，就会报错。</p>\n<p>下面是另一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>#x</code>就是私有属性，在<code>Point</code>类之外是读取不到这个属性的。由于井号<code>#</code>是属性名的一部分，使用时必须带有<code>#</code>一起使用，所以<code>#x</code>和<code>x</code>是两个不同的属性。</p>\n<p>之所以要引入一个新的前缀<code>#</code>表示私有属性，而没有采用<code>private</code>关键字，是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用<code>@</code>表示私有属性，ES6 没有用这个符号而使用<code>#</code>，是因为<code>@</code>已经被留给了 Decorator。</p>\n<p>这种写法不仅可以写私有属性，还可以用来写私有方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>#sum()</code>就是一个私有方法。</p>\n<p>另外，私有属性也可以设置 getter 和 setter 方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>#x</code>是一个私有属性，它的读写都通过<code>get #x()</code>和<code>set #x()</code>来完成。</p>\n<p>私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码允许从实例<code>foo</code>上面引用私有属性。</p>\n<p>私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>#totallyRandomNumber</code>是私有属性，<code>#computeRandomNumber()</code>是私有方法，只能在<code>FakeMath</code>这个类的内部调用，外部调用就会报错。</p>\n<h3> in 运算符</h3>\n<p><code>try...catch</code>结构可以用来判断是否存在某个私有属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面示例中，类<code>A</code>并不存在私有属性<code>#foo</code>，所以<code>try...catch</code>报错了。</p>\n<p>这样的写法很麻烦，可读性很差，V8 引擎改进了<code>in</code>运算符，使它也可以用来判断私有属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面示例中，<code>in</code>运算符判断当前类<code>A</code>的实例，是否有私有属性<code>#foo</code>，如果有返回<code>true</code>，否则返回<code>false</code>。</p>\n<p><code>in</code>也可以跟<code>this</code>一起配合使用。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，判断私有属性时，<code>in</code>只能用在定义该私有属性的类的内部。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面示例中，类<code>A</code>的私有属性<code>#foo</code>，只能在类<code>A</code>内部使用<code>in</code>运算符判断，而且只对<code>A</code>的实例返回<code>true</code>，对于其他对象都返回<code>false</code>。</p>\n<p>子类从父类继承的私有属性，也可以使用<code>in</code>运算符来判断。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面示例中，<code>SubA</code>从父类继承了私有属性<code>#foo</code>，<code>in</code>运算符也有效。</p>\n<p>注意，<code>in</code>运算符对于<code>Object.create()</code>、<code>Object.setPrototypeOf</code>形成的继承，是无效的，因为这种继承不会传递私有属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面示例中，对于修改原型链形成的继承，子类都取不到父类的私有属性，所以<code>in</code>运算符无效。</p>\n<h2> 继承的实现</h2>\n<h3> 基本使用</h3>\n<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p>\n<p><strong>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p>\n<h3> 本质</h3>\n<p><strong>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。</strong></p>\n<p><strong>ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</strong></p>\n<p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>**另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。**这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p>\n<p>下面是生成子类实例的代码。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与 ES5 的行为完全一致。</p>\n<p><strong>最后，父类的静态方法，也会被子类继承。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。</p>\n<h3> 获取父类</h3>\n<p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>\n<h2> super 关键字</h2>\n<p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>\n<h3> 作为函数使用</h3>\n<p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>\n<p>注意，<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p>\n<p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>super()</code>用在<code>B</code>类的<code>m</code>方法之中，就会造成语法错误。</p>\n<h3> 作为对象使用</h3>\n<p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p>\n<p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p>\n<p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p>\n<p><strong>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p>\n<p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p>\n<p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>\n<p><strong>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p>\n<p>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p>\n<p><strong>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> ES6 继承机制</h2>\n<h3> 基本概述</h3>\n<p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>\n<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p>\n<p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p>\n<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Object.setPrototypeOf</code>方法的实现：</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>因此，就得到了上面的结果。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> extends 关键字</h3>\n<p><code>extends</code>关键字后面可以跟多种类型的值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>\n<p>下面，讨论两种情况。第一种，子类继承<code>Object</code>类。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>这种情况下，<code>A</code>其实就是构造函数<code>Object</code>的复制，<code>A</code>的实例就是<code>Object</code>的实例。</strong></p>\n<p>第二种情况，不存在任何继承。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>这种情况下，<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。</strong></p>\n<h3> 实例的 <strong>proto</strong> 属性</h3>\n<p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p>\n<p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码在<code>ColorPoint</code>的实例<code>p2</code>上向<code>Point</code>类添加方法，结果影响到了<code>Point</code>的实例<code>p1</code>。</p>\n<p>下面用一张图进行总结：</p>\n<p></p>\n<h2> 继承原生构造函数</h2>\n<p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p>\n<ul>\n<li>Boolean()</li>\n<li>Number()</li>\n<li>String()</li>\n<li>Array()</li>\n<li>Date()</li>\n<li>Function()</li>\n<li>RegExp()</li>\n<li>Error()</li>\n<li>Object()</li>\n</ul>\n<p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码定义了一个继承 Array 的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p>\n<p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p>\n<p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象<code>e</code>具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p>\n<p><strong>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。</strong></p>\n<p>下面是一个继承<code>Array</code>的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 ES5 无法做到的。</p>\n<p><strong>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。</strong></p>\n<p>下面就是定义了一个带版本功能的数组。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p>\n<p>下面是一个自定义<code>Error</code>子类的例子，可以用来定制报错时的行为。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，继承<code>Object</code>的子类，有一个<a href=\"https://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object\" target=\"_blank\" rel=\"noopener noreferrer\">行为差异</a>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</p>\n<h2> Mixin 模式的实现</h2>\n<p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p>\n<p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "9.Symbol",
      "url": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses9.html",
      "id": "https://harryxiong24.github.io/zh/front-end/advanced-js/jses9.html",
      "summary": "设计原理 ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型...",
      "content_html": "<h1> Symbol</h1>\n<h2> 设计原理</h2>\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\n<p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<strong><code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）</strong>。</p>\n<h2> 使用概述</h2>\n<h3> 基本语法</h3>\n<p><strong>Symbol 值通过<code>Symbol</code>函数生成。</strong></p>\n<p>这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型。</p>\n<p><strong>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</strong></p>\n<h3> 传入 Symbol 描述值</h3>\n<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</strong></p>\n<p><strong>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 唯一性</h3>\n<p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p>\n<h3> 不可运算性</h3>\n<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 数据类型转换</h3>\n<p>Symbol 值可以显式转为字符串。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 读取 Symbol 描述值</h2>\n<p>创建 Symbol 的时候，可以添加一个描述。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>sym</code>的描述就是字符串<code>foo</code>。</p>\n<p>但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面的用法不是很方便。<a href=\"https://github.com/tc39/proposal-Symbol-description\" target=\"_blank\" rel=\"noopener noreferrer\">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> Symbol 作为属性名</h2>\n<h3> 作用</h3>\n<p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p>\n<h3> 注意点</h3>\n<p><strong>注意，Symbol 值作为对象属性名时，不能用点运算符。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p>\n<p><strong>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p>\n<p><strong>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</strong></p>\n<div class=\"language-text\" data-ext=\"text\"></div><h3> 应用</h3>\n<h4> 定义常量</h4>\n<p><strong>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>下面是另外一个例子：</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</strong></p>\n<p><strong>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</strong></p>\n<h4> 消除魔术字符串</h4>\n<p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>\n<p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p>\n<p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个 Symbol，其他地方都不用修改。</p>\n<h2> Symbol 作为属性名遍历</h2>\n<h3> 基本规则</h3>\n<p><strong>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</strong></p>\n<h3> Object.getOwnPropertySymbols()</h3>\n<p>但是，它也不是私有属性，<strong>有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名</strong>。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码是<code>Object.getOwnPropertySymbols()</code>方法的示例，可以获取所有 Symbol 属性名。</p>\n<p>下面是另一个例子，<code>Object.getOwnPropertySymbols()</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，使用<code>for...in</code>循环和<code>Object.getOwnPropertyNames()</code>方法都得不到 Symbol 键名，需要使用<code>Object.getOwnPropertySymbols()</code>方法。</p>\n<h3> Reflect.ownKeys()</h3>\n<p>另一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p>\n<h2> Symbol.for()&amp;Symbol.keyFor()</h2>\n<h3> Symbol.for()</h3>\n<p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</strong></p>\n<p><strong><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</strong></p>\n<p><code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(\"cat\")</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(\"cat\")</code>30 次，会返回 30 个不同的 Symbol 值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p>\n<h3> Symbol.keyFor()</h3>\n<p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p>\n<p><strong>注意，<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</strong></p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>上面代码中，<code>Symbol.for('bar')</code>是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行<code>Symbol.for('bar')</code>可以取到这个 Symbol 值。</p>\n<p><code>Symbol.for()</code>的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p>\n<h2> 内置的 Symbol 值</h2>\n<p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>\n<h3> Symbol.hasInstance</h3>\n<p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p>\n<p>下面是另一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.isConcatSpreadable</h3>\n<p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p>\n<p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p>\n<p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p>\n<h3> Symbol.species</h3>\n<p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p>\n<p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>现在，再来看前面的例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p>\n<p>再看一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p>\n<p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p>\n<h3> Symbol.match</h3>\n<p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.replace</h3>\n<p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是一个例子。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p>\n<h3> Symbol.search</h3>\n<p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.split</h3>\n<p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>下面是一个例子。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p>\n<h3> Symbol.iterator</h3>\n<p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.toPrimitive</h3>\n<p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>\n<p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>\n<ul>\n<li>Number：该场合需要转成数值</li>\n<li>String：该场合需要转成字符串</li>\n<li>Default：该场合可以转成数值，也可以转成字符串</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.toStringTag</h3>\n<p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p>\n<ul>\n<li><code>JSON[Symbol.toStringTag]</code>：'JSON'</li>\n<li><code>Math[Symbol.toStringTag]</code>：'Math'</li>\n<li>Module 对象<code>M[Symbol.toStringTag]</code>：'Module'</li>\n<li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：'ArrayBuffer'</li>\n<li><code>DataView.prototype[Symbol.toStringTag]</code>：'DataView'</li>\n<li><code>Map.prototype[Symbol.toStringTag]</code>：'Map'</li>\n<li><code>Promise.prototype[Symbol.toStringTag]</code>：'Promise'</li>\n<li><code>Set.prototype[Symbol.toStringTag]</code>：'Set'</li>\n<li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：'Uint8Array'等</li>\n<li><code>WeakMap.prototype[Symbol.toStringTag]</code>：'WeakMap'</li>\n<li><code>WeakSet.prototype[Symbol.toStringTag]</code>：'WeakSet'</li>\n<li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：'Map Iterator'</li>\n<li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：'Set Iterator'</li>\n<li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：'String Iterator'</li>\n<li><code>Symbol.prototype[Symbol.toStringTag]</code>：'Symbol'</li>\n<li><code>Generator.prototype[Symbol.toStringTag]</code>：'Generator'</li>\n<li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：'GeneratorFunction'</li>\n</ul>\n<h3> Symbol.unscopables</h3>\n<p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码说明，数组有 7 个属性，会被<code>with</code>命令排除。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p>\n",
      "date_published": "2021-08-01T00:00:00.000Z",
      "date_modified": "2023-06-15T14:05:05.000Z",
      "authors": [],
      "tags": [
        "Web 前端"
      ]
    },
    {
      "title": "Ajax",
      "url": "https://harryxiong24.github.io/zh/front-end/ajax/ajax.html",
      "id": "https://harryxiong24.github.io/zh/front-end/ajax/ajax.html",
      "summary": "Ajax 全称 Asynchronous JavaScript and XML(异步的 JavaScript 和 XML),既是一个对象,也是一种方法模式 AJAX 是一种用于创建快速动态网页的技术,通过在后台与服务器进行少量数据交换,Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新,传统的不使用 Aj...",
      "content_html": "<h1> Ajax</h1>\n<p><strong>Ajax 全称 Asynchronous JavaScript and XML(异步的 JavaScript 和 XML),既是一个对象,也是一种方法模式</strong></p>\n<p>AJAX 是一种用于创建快速动态网页的技术,通过在后台与服务器进行少量数据交换,Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新,传统的不使用 Ajax 的网页如果需要更新内容,必需重载整个网页面。</p>\n\n<h2> 1. 原生 Ajax</h2>\n<h3> 1.1 用法</h3>\n<h4> 1.1.1 创建 Ajax 对象</h4>\n<ul>\n<li><strong>通过 XMLHttpRequest()类创建一个 Ajax 对象(此方法不兼容 IE6 以下浏览器)</strong><br>\nvar Ajax=new XMLHttpRequest();</li>\n<li><strong>在 IE6 以下浏览器通过 ActiveXObject(\"Microsoft.XMLHTTP\")创建一个 Ajax 对象</strong><br>\nvar Ajax=new ActiveXObject(\"Microsoft.XMLHTTP\")</li>\n</ul>\n<h4> 1.1.2 连接服务器</h4>\n<p><strong>通过 open()方法,可以设置跟后台交互的一些行为,该方法有三个参数</strong></p>\n<p>参数</p>\n<p>• 请求方式,一个包含具体请求方式的字符串</p>\n<p><strong>主要请求方式：</strong></p>\n<p>​ <strong>• POST,建议在添加数据时使用</strong></p>\n<p>​ <strong>• GET,建议在查询数据时使用</strong></p>\n<p>​ <strong>• PUT,建议在修改数据时使用</strong></p>\n<p>​ <strong>• DELETE,建议在删除数据时使用</strong></p>\n<p><strong>• url,要请求数据的具体地址</strong></p>\n<p><strong>• bool,进行同步或异步传输,true 为异步,false 为同步</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意:在 IE 浏览器中,如果通过 Ajax 发生 GET 请求,那么 IE 浏览器认为同一个 url 只有一个结果，修改文件内容浏览器中显示的值也不会发生改变</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>设置需求</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>Tip：GET 还是 POST？</strong></p>\n<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>\n<p>然而，在以下情况中，请使用 POST 请求：</p>\n<p>​ • 无法使用缓存文件（更新服务器上的文件或数据库）</p>\n<p>​ • 向服务器发送大量数据（POST 没有数据量限制）</p>\n<p>​ • 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>\n<h4> 1.1.3 发送请求</h4>\n<p><strong>通过 send()方法正式发送请求</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>注:</strong> 如果请求方式是 POST 方式,添加的需求作为参数写入 send()方法中</p>\n<h4> 1.1.4 返回请求结果</h4>\n<ul>\n<li><strong>通过 readyState(Ajax 自身的状态码)属性来返回请求进行到了某一步,该属性存有请求的状态</strong>\n<strong>请求状态</strong></li>\n<li>0: 请求未初始化</li>\n<li>1: 服务器连接已建立</li>\n<li>2: 请求已接收</li>\n<li>3: 请求处理中</li>\n<li>4: 请求已完成，且响应已就绪</li>\n<li><strong>通过 onreadystatechange 事件(在状态码发生改变时就会执行此事件)或 onload 事件来对状态码发生改变时进行操作</strong></li>\n<li><strong>通过 status(http 的状态码)属性的值判断请求后的结果从而得到请求信息,一般该值为 200 到 300 直接和等于 304 时代表请求成功,值为 404 代表请求失败</strong></li>\n<li><strong>response 属性保留着后台返回到前端的数据</strong></li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>解释为什么 Ajax.readyState === 4</strong></p>\n<ol>\n<li>服务器通知客户端当前的通信状态，并不是直接通知的，而是服务器通过修改 readyState 属性值。</li>\n<li>一旦 readyState 属性值发生改变，浏览器里的 Ajax 引擎就会触发 onreadyStatechang 事件，我们就可以通过该事件完成一些动作。</li>\n<li>有的说 onreadyStatechang 事件是由服务器触发的，其实应该是浏览器里的 Ajax 引擎触发的</li>\n</ol>\n<h4> 1.1.5 返回结果演示</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 1.2 超时请求</h3>\n<p>如果请求事件太长就是请求超时,如果事件过长则可能内部出现了错了,可以设置超过一定时间结束请求</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 1.3 跨域请求</h3>\n<p>如果通过 Ajax 跨域传输一个请求,浏览器会自动将该请求阻止并返回报错信息。如果要进行跨域就要进行特殊方法进行实现</p>\n<p><strong>实现跨域</strong></p>\n<ul>\n<li>JOSNP 方式,通过 script 标签中的 src 属性传输请求</li>\n<li>CORS 方式,在后台中设置可以让对应的域进行访问</li>\n<li>通过信任服务器代理请求进入(翻墙)</li>\n</ul>\n<h3> 1.4 XmlHttpRequest 对象的主要方法与属性</h3>\n<p><strong>XmlHttpRequest 对象的主要方法</strong></p>\n<ol>\n<li>void open(String method,String url,Boolen async)\n用于创建请求\n参数：\nmethod： 请求方式（字符串类型），如：POST、GET、DELETE...\nurl： 要请求的地址（字符串类型）\nasync： 是否异步（布尔类型）</li>\n<li>void send(String body)\n用于发送请求\n参数：\nbody： 要发送的数据（字符串类型）</li>\n<li>void setRequestHeader(String header,String value)\n用于设置请求头\n参数：\nheader： 请求头的 key（字符串类型）\nvlaue： 请求头的 value（字符串类型）</li>\n<li>String getAllResponseHeaders()\n获取所有响应头\n返回值：\n响应头数据（字符串类型）</li>\n<li>String getResponseHeader(String header)\n获取响应头中指定 header 的值\n参数：\nheader： 响应头的 key（字符串类型）\n返回值：\n响应头中指定的 header 对应的值</li>\n<li>void abort()\n终止请求</li>\n</ol>\n<p><strong>XmlHttpRequest 对象的主要属性</strong></p>\n<ol>\n<li>Number readyState\n状态值（整数）\n详细：\n0-未初始化，尚未调用 open()方法；\n1-启动，调用了 open()方法，未调用 send()方法；\n2-发送，已经调用了 send()方法，未接收到响应；\n3-接收，已经接收到部分响应数据；\n4-完成，已经接收到全部响应数据；</li>\n<li>Function onreadystatechange\n当 readyState 的值改变时自动触发执行其对应的函数（回调函数）</li>\n<li>String responseText\n服务器返回的数据（字符串类型）</li>\n<li>XmlDocument responseXML\n服务器返回的数据（Xml 对象）</li>\n<li>Number states\n状态码（整数），如：200、404...</li>\n<li>String statesText\n状态文本（字符串），如：OK、NotFound...</li>\n</ol>\n<h3> 1.5 封装 Ajax</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 1.6 总结</h3>\n<p>使用步骤</p>\n<ol>\n<li>创建 XmlHttpRequest 对象</li>\n<li>调用 open 方法设置基本请求信息</li>\n<li>设置发送的数据，发送请求</li>\n<li>注册监听的回调函数</li>\n<li>拿到返回值，对页面进行更新</li>\n</ol>\n<h2> 2. Fetch</h2>\n<p>fetch 是一种 HTTP 数据请求的方式，是 XMLHttpRequest 的一种替代方案。fetch 不是 ajax 的进一步封装，而是原生 js。Fetch 函数就是原生 js，没有使用 XMLHttpRequest 对象。</p>\n<h3> 2.1 用法</h3>\n<h4> 2.1.1 Fetch 的参数</h4>\n<ul>\n<li>\n<p><strong>url,该参数定义要获取的资源,可以是一个 url 字符串,也可以是一个 Request 对象</strong></p>\n</li>\n<li>\n<p><strong>options,该参数可选,为一个对象,内部含有一些对请求的设置属性</strong>\n<strong>内部属性：</strong></p>\n</li>\n<li>\n<ul>\n<li>**method:**请求使用的方法。如:GET、POST 等</li>\n<li>**headers:**请求头信息。形式为 Headers 对象或 ByteString</li>\n<li>**body:**请求的 body 信息,可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息</li>\n<li>**mode:**请求的模式。如 cors、no-cors 或者 same-origin</li>\n<li>**credentiala:**请求的 credentials。如 omit、same-origin 或者 include</li>\n<li>**cache:**请求的 cache 模式:default,no-store,reload,no-cache 或者 only-if-cached</li>\n</ul>\n</li>\n</ul>\n<h4> 2.1.2 response 对象</h4>\n<p><strong>response 为一个 Promise 对象成功时传回的对象,该属性含有对应返回数据的属性和方法</strong></p>\n<ul>\n<li><strong>属性</strong></li>\n<li><strong>status (number),HTTP 请求结果参数,在 100-599 范围</strong></li>\n<li><strong>statusText (string),服务器返回的状态报告</strong></li>\n<li><strong>ok (boolean),如果返回 200 表示请求成功则为 true</strong></li>\n<li><strong>headers (Headers),返回头部信息,该属性后面也有对应的方法</strong></li>\n<li>has(name) (boolean),判断是否存在该信息头</li>\n<li>get(name) (string),获取信息头的数据</li>\n<li>getAll(name) (Array),获取所有头部数据</li>\n<li>set(name,value),设置请求头信息</li>\n<li>append(name,value),添加 header 的内容</li>\n<li>delete(name),删除 header 的信息</li>\n<li>forEach(function(value,name){...},[thisContext]),循环读取 header 的信息</li>\n<li><strong>url (string),详细的地址</strong></li>\n</ul>\n<ul>\n<li><strong>方法</strong></li>\n<li><strong>text(),以 string 的形式生成请求 text</strong></li>\n<li><strong>json(),生成 JSON.parse(responseText)的结果</strong></li>\n<li><strong>blob(),生成一个 Blob</strong></li>\n<li><strong>arrayBuffer(),生成一个 ArrayBuffer</strong></li>\n<li><strong>formData(),生成格式化数据,可用于其它的请求</strong></li>\n<li><strong>其他方法</strong></li>\n<li><strong>clone(),创建一个 Response 对象的克隆</strong></li>\n<li><strong>Response.error(),返回一个绑定了网络错误的新的 Response 对象</strong></li>\n<li><strong>Response.redirect(),用另一个 URL 创建一个新的 Resonse 对象</strong></li>\n</ul>\n<h4> 2.1.3 使用</h4>\n<p><strong>引入 npm install whatwg-fetch --save</strong></p>\n<ul>\n<li><strong>get</strong></li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><ul>\n<li><strong>post</strong></li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.2 与原生 Ajax 的比较</h3>\n<ul>\n<li>原生 Ajax</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>Fetch</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.3 封装 fetch</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 3. Axios</h2>\n<h3> 3.1 安装</h3>\n<p>使用 npm:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>使用 bower:</p>\n<div class=\"language-bash\" data-ext=\"sh\"></div><p>使用 cdn:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>###3.2 用法</p>\n<p>执行 GET 请求</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行 POST 请求</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行多个并发请求</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.3 Axios API</h3>\n<p>可以通过向 axios 传递相关配置来创建请求</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>请求方法的别名</p>\n<p>为方便起见，为所有支持的请求方法提供了别名</p>\n<p>axios.request(config)</p>\n<p>axios.get(url[, config])</p>\n<p>axios.delete(url[, config])</p>\n<p>axios.head(url[, config])</p>\n<p>axios.post(url[, data[, config]])</p>\n<p>axios.put(url[, data[, config]])</p>\n<p>axios.patch(url[, data[, config]])</p>\n<p>在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</p>\n<h4> 处理并发</h4>\n<p>处理并发请求的助手函数</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 创建实例</h4>\n<p>可以使用自定义配置新建一个 axios 实例</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>实例方法</p>\n<p>以下是可用的实例方法。指定的配置将与实例的配置合并</p>\n<p>axios#request(config)</p>\n<p>axios#get(url[, config])</p>\n<p>axios#delete(url[, config])</p>\n<p>axios#head(url[, config])</p>\n<p>axios#post(url[, data[, config]])</p>\n<p>axios#put(url[, data[, config]])</p>\n<p>axios#patch(url[, data[, config]])</p>\n<h4> 请求配置</h4>\n<p>这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.4 响应结果</h3>\n<p>响应结构</p>\n<p>某个请求的响应包含以下信息</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用 then 时，你将接收下面这样的响应：</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用。</p>\n<h3> 3.5 封装 Axios</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 4 原生 Ajax, Axios, Fetch 的区别</h2>\n<h3> 原生 Ajax</h3>\n<p>传统 Ajax 指的是 XMLHttpRequest（XHR）， 最早出现的发送后端请求技术，隶属于原始 js 中，核心使用 XMLHttpRequest 对象，多个请求之间如果有先后关系的话，就会出现<strong>回调地狱</strong>。</p>\n<p>JQuery ajax 是对原生 XHR 的封装，除此以外还增添了对<strong>JSONP</strong>的支持。经过多年的更新维护，真的已经是非常的方便了，优点无需多言；如果是硬要举出几个缺点，那可能只有：</p>\n<ol>\n<li>本身是针对 MVC 的编程,不符合现在前端<strong>MVVM</strong>的浪潮</li>\n<li>基于原生的 XHR 开发，XHR 本身的架构不清晰。</li>\n<li>JQuery 整个项目太大，单纯使用 ajax 却要引入整个 JQuery 非常的不合理（采取个性化打包的方案又不能享受 CDN 服务）</li>\n<li>不符合关注分离（Separation of Concerns）的原则</li>\n<li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li>\n</ol>\n<h3> Axios</h3>\n<p>Axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范，它本身具有以下特征：</p>\n<ol>\n<li>从浏览器中创建 XMLHttpRequest</li>\n<li>支持 Promise API</li>\n<li>.客户端支持防止 CSRF</li>\n<li>提供了一些并发请求的接口（重要，方便了很多的操作）</li>\n<li>从 node.js 创建 http 请求</li>\n<li>拦截请求和响应</li>\n<li>转换请求和响应数据</li>\n<li>取消请求</li>\n<li>自动转换 JSON 数据</li>\n</ol>\n<p><strong>PS:防止 CSRF:就是让你的每个请求都带一个从 cookie 中拿到的 key, 根据浏览器同源策略，假冒的网站是拿不到你 cookie 中得 key 的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。</strong></p>\n<h3> Fetch</h3>\n<p>fetch 号称是 AJAX 的替代品，是在 ES6 出现的，使用了 ES6 中的 promise 对象。</p>\n<p>Fetch 是基于 promise 设计的。Fetch 的代码结构比起 ajax 简单多了，参数有点像 jQuery ajax。</p>\n<p>但是，一定记住<strong>fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象</strong>。</p>\n<p><strong>fetch 的优点：</strong></p>\n<ol>\n<li>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</li>\n<li>更好更方便的写法</li>\n<li>语法简洁，更加语义化</li>\n<li>基于标准 Promise 实现，支持 async/await</li>\n<li>同构方便使用</li>\n<li>加底层，提供的 API 丰富（request, response）</li>\n<li>脱离了 XHR，是 ES 规范里新的实现方式</li>\n</ol>\n<p><strong>使用 fetch 的时候，也遇到了不少的问题：</strong></p>\n<ol>\n<li>fetch 是一个低层次的 API，你可以把它考虑成原生的 XHR，所以使用起来并不是那么舒服，需要进行封装。1）fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。\n2）fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: 'include'})\n3）fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费\n4）fetch 没有办法原生监测请求的进度，而 XHR 可以</li>\n</ol>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "Data Storage",
      "url": "https://harryxiong24.github.io/zh/front-end/data-storage/data-storage.html",
      "id": "https://harryxiong24.github.io/zh/front-end/data-storage/data-storage.html",
      "summary": "[[toc]] 1. Cookie cookie 用于存储数据,当用户访问了某个网站(网页)的时候,可以通过 cookie 来访问客户端上存储的数据 注意: 不同的浏览器存放的 cookie 位置不一样，也是不能通用的; cookie 的存储是以域名形式进行区分的; cookie 的数据可以设置名字的; 一个域名下存放的 cookie 的个数是有限制的...",
      "content_html": "<h1> Data Storage</h1>\n\n<h2> 1. Cookie</h2>\n<p><strong>cookie 用于存储数据,当用户访问了某个网站(网页)的时候,可以通过 cookie 来访问客户端上存储的数据</strong></p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>\n<p>不同的浏览器存放的 cookie 位置不一样，也是不能通用的</p>\n</li>\n<li>\n<p>cookie 的存储是以域名形式进行区分的</p>\n</li>\n<li>\n<p>cookie 的数据可以设置名字的</p>\n</li>\n<li>\n<p>一个域名下存放的 cookie 的个数是有限制的，不同的浏览器存放的个数不一样</p>\n</li>\n<li>\n<p>每个 cookie 存放的内容大小也是有限制的，不同的浏览器存放大小不一样</p>\n</li>\n</ul>\n<h3> 1.1 访问 cookie</h3>\n<p><strong>通过 document.cookie 属性可以获取当前网站下的所有 cookie,得到字符串形式的值,<strong>该返回值会将所有的 cookie 通过</strong>分号+空格</strong>的形式串联起来</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 1.2 存储 cookie</h3>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>注意:</strong></p>\n<ul>\n<li>\n<p>如果设置不同的 cookie 值,则用 document.cookie 再次赋值不会将原来设置的 cookie 覆盖掉,而是再加上一条 cookie</p>\n</li>\n<li>\n<p>如果设置相同的 cookie 值,则再次用 document.coolkie 设置 cookie 值时会将原来的 cookie 值覆盖掉</p>\n</li>\n</ul>\n<h3> 1.3 设置 cookie 过期时间</h3>\n<p>cookie 默认是临时存储的,当浏览器关闭进程的时候自动销毁 ,如果想长时间存放一个 cookie。需要在设置这个 cookie 的时候设置一个过期的时间</p>\n<p>**注意:**过期时间必须是一个日期对象转换成的字符串</p>\n<p><strong>document.cookie = \"数据名=值; expires=过期时间\"</strong>;</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>`</p>\n<h3> 1.4 cookie 封装</h3>\n<ul>\n<li>\n<p>设置 cookie 封装</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>获取 cookie 封装</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>移除 cookie</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n<h2> 2. 本地存储</h2>\n<h3> 2.1 sessionStorage</h3>\n<p><strong>sessionStorage 属性允许用户访问一个 session Storage 对象,存储在 sessionStorage 中的数据在页面会话结束时被清除</strong></p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>\n<p>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</p>\n</li>\n<li>\n<p>在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话,这点和 cookies 的运行方式不同</p>\n</li>\n</ul>\n<p><strong>方法</strong></p>\n<ul>\n<li>\n<p>setItem(\"对象名\",\"对象值\"),增加一个数据项目</p>\n</li>\n<li>\n<p>getItem(\"对象名\"),获取一个数据项目</p>\n</li>\n<li>\n<p>removeItem(\"对象名\"),移除一个数据项目</p>\n</li>\n<li>\n<p>clear(),不传参数,移除所有的数据项目</p>\n</li>\n</ul>\n<h3> 2.2 localStorage</h3>\n<p>localStorage 属性允许用户访问一个了 local Storage 对象,存储在 localStorage 中的数据能在跨浏览器会话保留,也就是说该属性中存入的值会在本地存储中永久保存</p>\n<p>**注意:**localStorage 中的键值对总是以字符串的形式存储,所有如果传入的是非字符串参数会自动转换为字符串,最好手动转化</p>\n<p><strong>方法</strong></p>\n<ul>\n<li>\n<p>setItem(\"对象名\",\"对象值\"),增加一个数据项目</p>\n</li>\n<li>\n<p>getItem(\"对象名\"),获取一个数据项目</p>\n</li>\n<li>\n<p>removeItem(\"对象名\"),移除一个数据项目</p>\n</li>\n<li>\n<p>clear(),不传参数,移除所有的数据项目</p>\n</li>\n</ul>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "1.节点",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db1.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db1.html",
      "summary": "节点 Node(节点)是构成HTML5的基本单元,DOM节点主要分为四类 文档节点:整个HTML文档; 元素节点:HTML文档中的HTML标签; 属性节点:元素的属性; 文本节点:HTML标签中的文本内容; 节点 nodeName(节点名) nodeType(节点类型) nodeValue(节点值) -------- ---------------- ...",
      "content_html": "<h2> 节点</h2>\n<p><strong>Node(节点)是构成HTML5的基本单元</strong>,DOM节点主要分为四类</p>\n<ul>\n<li>\n<p><strong>文档节点</strong>:整个HTML文档</p>\n</li>\n<li>\n<p><strong>元素节点</strong>:HTML文档中的HTML标签</p>\n</li>\n<li>\n<p><strong>属性节点</strong>:元素的属性</p>\n</li>\n<li>\n<p><strong>文本节点</strong>:HTML标签中的文本内容</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>节点</th>\n<th>nodeName(节点名)</th>\n<th>nodeType(节点类型)</th>\n<th>nodeValue(节点值)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>文档节点</td>\n<td>#document</td>\n<td>9</td>\n<td>null</td>\n</tr>\n<tr>\n<td>元素节点</td>\n<td>标签名</td>\n<td>1</td>\n<td>null</td>\n</tr>\n<tr>\n<td>属性节点</td>\n<td>属性名</td>\n<td>2</td>\n<td>属性值</td>\n</tr>\n<tr>\n<td>文本节点</td>\n<td>#text</td>\n<td>3</td>\n<td>文本内容</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注:</strong></p>\n<ul>\n<li>\n<p>浏览器已经为我们提供了文档节点对象window,该对象可以在页面中直接使用,代表的是整个网页</p>\n</li>\n<li>\n<p>通过nodeType===1可以判断某节点是否是元素节点</p>\n</li>\n<li>\n<p>文本节点包含了在写代码时的回车换行符间产生的空白，但是IE8及以下的浏览器中不会将空白节点当作子节点，而其他浏览器会</p>\n</li>\n<li>\n<p>通过nodeName返回的标签名是全大写的</p>\n</li>\n<li>\n<p>元素节点的名字也可以通过专门的TagName属性获得</p>\n</li>\n</ul>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "10.拖拽事件",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db10.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db10.html",
      "summary": "拖拽事件 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，此时会导致拖拽功能的异常，这个是浏览器提供的默认行为,如果不希望发生这个行为，可以通过return false来取消默认行为，但是对IE8及以下浏览器不起作用(并不是说IE8不支持使用return false来取消默认效果，只是不支持在拖拽时取消默认效果) 注意: 使用addEv...",
      "content_html": "<h2> 拖拽事件</h2>\n<p>当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，此时会导致拖拽功能的异常，这个是浏览器提供的默认行为,如果不希望发生这个行为，可以通过return false来取消默认行为，但是对IE8及以下浏览器不起作用(并不是说IE8不支持使用return false来取消默认效果，只是不支持在拖拽时取消默认效果)</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>\n<p><strong>使用addEventListener()方法绑定的响应函数，取消默认行为时不能使用return false,需要使用event事件对象通过event.preventDefault()方法来取消默认行为</strong>,但是IE8及以下浏览器不能支持该方法(包括addEventListener()方法)，使用该方法会报错，所以在调用的时候需要使用：<code>event.preventDefault&amp;&amp;:event.preventDefault();</code></p>\n</li>\n<li>\n<p>**IE8中有setCapture()这一对鼠标按下相关事件进行捕获的方法，**当一个调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自己身上，其他鼠标触发都会由这个元素执行(包含在网页外面点击)，所以可以设置需要进行的行为对象在按下鼠标的时候捕获到所有的事件</p>\n</li>\n</ul>\n<p>当鼠标松开时，取消对事件的捕获，<strong>取消捕获用releaseCapture()方法</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>注:</strong></p>\n<ul>\n<li>\n<p>setCapture()和releaseCapture()必须成对出现</p>\n</li>\n<li>\n<p>其它浏览器一样不支持该方法,所以在调用的时候用\n<code>Odiv.setCapture&amp;&amp;Odiv.setCapture()</code>和<code>Odiv.releaseCapture()&amp;&amp;Odiv.releaseCapture()</code></p>\n</li>\n</ul>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "11.滚轮事件",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db11.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db11.html",
      "summary": "滚轮事件 onscroll事件为元素添加滚动(注意不是滚轮,滚动是滚动条发生变化)事件,该事件是滚动条变化就发生事件,所以一次鼠标滚动可能会发生很多次该事件; onwheel鼠标滚动事件,会在鼠标滚动时触发,推荐使用该事件; onmousewheel鼠标滚轮事件，会在滚轮滚动时触发，但是火狐不支持该属性，在火狐中需要使用DOMMouseScroll来绑...",
      "content_html": "<h2> 滚轮事件</h2>\n<ul>\n<li>\n<p><strong>onscroll事件为元素添加滚动(注意不是滚轮,滚动是滚动条发生变化)事件,该事件是滚动条变化就发生事件,所以一次鼠标滚动可能会发生很多次该事件</strong></p>\n</li>\n<li>\n<p><strong>onwheel鼠标滚动事件,会在鼠标滚动时触发,推荐使用该事件</strong></p>\n</li>\n<li>\n<p>onmousewheel鼠标滚轮事件，会在滚轮滚动时触发，但是火狐不支持该属性，在火狐中需要使用DOMMouseScroll来绑定滚动事件，注意该事件需要通过<strong>addEventListener()方法</strong>来绑定</p>\n</li>\n</ul>\n<p><strong>鼠标滚轮滚动方向</strong></p>\n<ul>\n<li>\n<p>通过事件对象event.wheelDelta可以获取鼠标滚轮滚动的方向，<strong>向上滚为正，向下滚为负,值为数值120的倍数(一般为120,滚动过快会为120的倍数)</strong>\n**注:**只看正负，不看大小</p>\n</li>\n<li>\n<p>在火狐中不支持event.wheelDelta属性,使用事件对象event.detail，<strong>向上滚为负，向下滚为正</strong>，与上方属性相反，<strong>并且每次滚动的数值为3的倍数(一般为3,滚动过快会为3的倍数)</strong></p>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>兼容写法(包括控制滚动的方向)</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "12.键盘事件",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db12.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db12.html",
      "summary": "键盘事件 12.1 事件触发 onkeydown事件触发表明键盘按键被按下,如果一直按着某个按键不松手，则事件会一直触发; 注意:当onkeydown事件连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常快，这种设计是为了防止误操作事故的发生,如果不想要这种效果请使用定时器 onkeyup事件触发表明键盘按键被松开; 注:键盘事件有一般都会绑...",
      "content_html": "<h2> 键盘事件</h2>\n<h3> 12.1 事件触发</h3>\n<ul>\n<li>\n<p><strong>onkeydown事件触发表明键盘按键被按下,如果一直按着某个按键不松手，则事件会一直触发</strong>\n**注意:**当onkeydown事件连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常快，这种设计是为了防止误操作事故的发生,如果不想要这种效果请使用定时器</p>\n</li>\n<li>\n<p><strong>onkeyup事件触发表明键盘按键被松开</strong></p>\n</li>\n</ul>\n<p>**注:**键盘事件有一般都会绑定给一些可以获取到焦点的对象或者是document，有焦点的对象就是可以让光标停留的地方，比如input标签</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 12.2 事件属性</h3>\n<p><strong>通过事件对象event的keyCode和key属性可以获取按键的编码和输入键的字符</strong>，可以判断哪个按键被按下</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>事件对象中还提供了几个辅助属性</strong></p>\n<ul>\n<li>\n<p>altKey属性判断alt键是否被按下，如果按下则返回true，否则返回false</p>\n</li>\n<li>\n<p>ctrlKey属性判断ctrl键是否被按下，如果按下则返回true，否则返回false</p>\n</li>\n<li>\n<p>shiftKey属性判断shift键是否被按下，如果按下则返回true，否则返回false</p>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>注意:在文本框中输入内容，属于onkeydown的默认行为，如果在onkeydown中取消了默认行为return false，则输入的内容不会出现在文本框中</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "13.BOM",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db13.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db13.html",
      "summary": "BOM BOM全称Browser Object Model(浏览器对象模型),是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构，BOM可以使我们通过JS来操作浏览器 BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象 Window-代表...",
      "content_html": "<h2> BOM</h2>\n<p>**BOM全称Browser Object Model(浏览器对象模型),**是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构，BOM可以使我们通过JS来操作浏览器</p>\n<p><strong>BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象</strong></p>\n<ul>\n<li>\n<p>Window-代表的是整个浏览器的窗口，同时window也是网页中的全局对象</p>\n</li>\n<li>\n<p>Navigator-代表当前浏览器的信息，通过该对象可以来识别不同的浏览器</p>\n</li>\n<li>\n<p>Location-代表当前浏览的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面</p>\n</li>\n<li>\n<p>History-代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录，由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前和向翻页，而且该操作只在当次访问时游戏</p>\n</li>\n<li>\n<p>Screen-代表用户的屏幕信息，通过该对象可以获取到用户的显示器的相关信息</p>\n</li>\n</ul>\n<p><strong>Window下方的BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用navigator location history screen</strong></p>\n<h3> 13.1 Navigator</h3>\n<p><strong>Navigator代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器，由于历史原因，Navigator对象中的大部分属性已经不能帮助我们识别浏览器了</strong></p>\n<p>一般我们只会使用userAgent属性来判断浏览器的信息,userAgent是一个字符串，这个字符串包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent，usetAgent里面会有与浏览器相关的标识，但在IE11中已经将微软和IE相关的标识都已经取消了，所以我们基本已经不能通过UserAgent识别一个浏览器是否是IE浏览器</p>\n<div class=\"language-JS\" data-ext=\"JS\"></div><div class=\"language-JS\" data-ext=\"JS\"></div><p>如果通过userAgent属性不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息，比如：通过ActiveXObject属性判断是否为IE浏览器</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 13.2 History</h3>\n<p><strong>History对象可以用来操作浏览器向前或向后翻页</strong></p>\n<ul>\n<li>\n<p>length属性，可以获取到当次访问的链接数量</p>\n</li>\n<li>\n<p>back()方法可以用来退到上一个页面，作用和浏览器的回退按钮一样</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>forward()方法可以跳转下一个页面，作用和浏览器的前进按钮一样</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>go()方法可以用来跳转到指定页面，该方需要一个整数作为参数</p>\n<p>参数用法:</p>\n<p>1表示向前跳转一个页面，2表示向前跳转2个页面，-1表示向后跳转一个页面，-2表示向后跳转2个页面</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n<h3> 13.3 Location</h3>\n<p><strong>Location对象中封装了浏览器的地址栏信息</strong></p>\n<ul>\n<li>\n<p>直接打印location对象可以获取到地址栏的信息(当前页面的完整路径)</p>\n</li>\n<li>\n<p>如果直接将location属性修改为一个完整的路径，或相对路径，则页面会自动跳转到该路径，并且会生成相应的历史记录</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n<p><strong>Location对象的属性</strong></p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hash</td>\n<td>返回一个URL的锚部分</td>\n</tr>\n<tr>\n<td>host</td>\n<td>返回一个URL的主机名和端口</td>\n</tr>\n<tr>\n<td>hostname</td>\n<td>返回URL的主机名</td>\n</tr>\n<tr>\n<td>href</td>\n<td>返回完整的URL</td>\n</tr>\n<tr>\n<td>pathname</td>\n<td>返回的URL路径名。</td>\n</tr>\n<tr>\n<td>port</td>\n<td>返回一个URL服务器使用的端口号</td>\n</tr>\n<tr>\n<td>protocol</td>\n<td>返回一个URL协议</td>\n</tr>\n<tr>\n<td>search</td>\n<td>返回一个URL的查询部分</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Location对象的方法</strong></p>\n<ul>\n<li>\n<p>assign()方法用来跳转到其他页面，作用和直接修改location一样</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>reload()方法会重新加载当前页面，作用和刷新按钮一样，该方法可以接受一个布尔值参数,默认是flase,代表只刷新当前页面,不清除页面的缓存内容(一般的刷新都会有缓存留着input标签里面的文字),如果传入true则会强制清空页面缓存内容</p>\n<p>注意:</p>\n<p>如果要通过刷新按钮清空页面缓存,需要同时按住ctrl和F5</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>replace()方法可以使用一个新的页面替换当前页面，调用完毕也会跳转页面，不会生成历史记录，所以不能使用回退按钮回退</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n<h3> 13.4 Window</h3>\n<ul>\n<li>\n<p>open()方法打开一个新的浏览器窗口或查找一个已命名的窗口,该方法的返回值是新窗口的window对象</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>close()方法关闭浏览器窗口</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p><strong>setInterval()方法按照指定的周期(以毫秒计)来调用函数或计算表达式</strong></p>\n</li>\n<li>\n<p><strong>setTimeout()方法在指定的毫秒数后调用函数偶计算表达式</strong></p>\n</li>\n<li>\n<p><strong>clearInterval()方法取消由setInterval()设置的定时器</strong></p>\n</li>\n<li>\n<p><strong>clearTimeout()方法取消由setTimeout()方法设置的定时器</strong></p>\n</li>\n<li>\n<p>scrollTo()方法把内容滚动到指定坐标</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p><strong>scrollBy()方法按照指定像素来滚动内容,不带px单位</strong>\n<strong>参数</strong></p>\n</li>\n<li>\n<ul>\n<li>xnum,把文档向右滚动的像素数</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>ynum,把文档向下滚动的像素数</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><ul>\n<li>\n<p><strong>alert(\"内容\")警告框</strong></p>\n</li>\n<li>\n<p><strong>confirm(\"文本\")确认框</strong></p>\n</li>\n<li>\n<p><strong>prompt(\"文本\",\"默认值\")提示框</strong></p>\n</li>\n</ul>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "2.DOM事件",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db2.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db2.html",
      "summary": "DOM事件 事件是用户和浏览器之间的交互行为 2.1 鼠标事件 属性 描述 ------------- ------------------------------------------------------------ onclick 当用户点击某个对象时调用的事件句柄。单击鼠标左键或者按下回车键时触发,意味着onclick事件处理程序既可以通过...",
      "content_html": "<h2> DOM事件</h2>\n<p><strong>事件是用户和浏览器之间的交互行为</strong></p>\n<h3> 2.1 鼠标事件</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onclick</td>\n<td>当用户点击某个对象时调用的事件句柄。单击鼠标左键或者按下回车键时触发,意味着onclick事件处理程序既可以通过键盘也可以通过鼠标执行</td>\n</tr>\n<tr>\n<td>oncontextmenu</td>\n<td>在用户点击鼠标右键打开上下文菜单时触发。可以用做自定义菜单</td>\n</tr>\n<tr>\n<td>ondblclick</td>\n<td>当用户双击某个对象时调用的事件句柄。双击鼠标左键时触发</td>\n</tr>\n<tr>\n<td>onmousedown</td>\n<td>鼠标按钮被按下。</td>\n</tr>\n<tr>\n<td>onmouseenter</td>\n<td>当鼠标指针移动到元素上时触发。该事件不冒泡，即鼠标移到其后代元素上时不会触发。</td>\n</tr>\n<tr>\n<td>onmouseleave</td>\n<td>当鼠标指针移出元素时触发。该事件不冒泡，即鼠标移出其后代元素时不会触发。</td>\n</tr>\n<tr>\n<td>onmousemove</td>\n<td>鼠标被移动。</td>\n</tr>\n<tr>\n<td>onmouseover</td>\n<td>鼠标移到某元素之上。鼠标移到其后代元素上时会触发,意味着支持冒泡</td>\n</tr>\n<tr>\n<td>onmouseout</td>\n<td>鼠标从某元素移开。支持冒泡</td>\n</tr>\n<tr>\n<td>onmouseup</td>\n<td>鼠标按键被松开。</td>\n</tr>\n</tbody>\n</table>\n<h3> 2.2 键盘事件</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onkeydown</td>\n<td>某个键盘按键被按下。</td>\n</tr>\n<tr>\n<td>onkeypress</td>\n<td>某个键盘按键被按下并松开。</td>\n</tr>\n<tr>\n<td>onkeyup</td>\n<td>某个键盘按键被松开。</td>\n</tr>\n</tbody>\n</table>\n<h3> 2.3 框架/对象事件</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onabort</td>\n<td>图像的加载被中断。 ( <code>&lt;object&gt;</code>)</td>\n</tr>\n<tr>\n<td>onbeforeunload</td>\n<td>该事件在即将离开页面（刷新或关闭）时触发</td>\n</tr>\n<tr>\n<td>onerror</td>\n<td>在加载文档或图像时发生错误。 ( <code>&lt;object&gt;</code>, <code>&lt;body&gt;</code>和 <code>&lt;frameset&gt;</code>)</td>\n</tr>\n<tr>\n<td>onhashchange</td>\n<td>该事件在当前 URL 的锚部分发生修改时触发。</td>\n</tr>\n<tr>\n<td>onload</td>\n<td>一张页面或一幅图像完成加载。</td>\n</tr>\n<tr>\n<td>onpageshow</td>\n<td>该事件在用户访问页面时触发</td>\n</tr>\n<tr>\n<td>onpagehide</td>\n<td>该事件在用户离开当前网页跳转到另外一个页面时触发</td>\n</tr>\n<tr>\n<td>onresize</td>\n<td>窗口或框架被重新调整大小。由window调用</td>\n</tr>\n<tr>\n<td>onscroll</td>\n<td>当文档被滚动时发生的事件。</td>\n</tr>\n<tr>\n<td>onunload</td>\n<td>用户退出页面。 ( <code>&lt;body&gt;</code> 和 <code>&lt;frameset&gt;</code>)</td>\n</tr>\n</tbody>\n</table>\n<h3> 2.4 表单事件</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onblur</td>\n<td>元素失去焦点时触发</td>\n</tr>\n<tr>\n<td>onchange</td>\n<td>该事件在表单元素的内容改变时触发( <code>&lt;input&gt;</code>, <code>&lt;keygen&gt;</code>, <code>&lt;select&gt;</code>, 和 <code>&lt;textarea&gt;</code>)</td>\n</tr>\n<tr>\n<td>onfocus</td>\n<td>元素获取焦点时触发</td>\n</tr>\n<tr>\n<td>onfocusin</td>\n<td>元素即将获取焦点时触发</td>\n</tr>\n<tr>\n<td>onfocusout</td>\n<td>元素即将失去焦点时触发</td>\n</tr>\n<tr>\n<td>oninput</td>\n<td>元素获取用户输入时触发</td>\n</tr>\n<tr>\n<td>onreset</td>\n<td>表单重置时触发</td>\n</tr>\n<tr>\n<td>onsearch</td>\n<td>用户向搜索域输入文本时触发 ( ·&lt;input=\"search\"&gt;)</td>\n</tr>\n<tr>\n<td>onselect</td>\n<td>用户选取文本时触发 ( <code>&lt;input&gt; </code>和<code> &lt;textarea&gt;</code>)</td>\n</tr>\n<tr>\n<td>onsubmit</td>\n<td>表单提交时触发</td>\n</tr>\n</tbody>\n</table>\n<h3> 2.5 剪贴板事件</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>oncopy</td>\n<td>该事件在用户拷贝元素内容时触发</td>\n</tr>\n<tr>\n<td>oncut</td>\n<td>该事件在用户剪切元素内容时触发</td>\n</tr>\n<tr>\n<td>onpaste</td>\n<td>该事件在用户粘贴元素内容时触发</td>\n</tr>\n</tbody>\n</table>\n<h3> 2.6 打印事件</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onafterprint</td>\n<td>该事件在页面已经开始打印，或者打印窗口已经关闭时触发</td>\n</tr>\n<tr>\n<td>onbeforeprint</td>\n<td>该事件在页面即将开始打印时触发</td>\n</tr>\n</tbody>\n</table>\n<h3> 2.7 拖动事件</h3>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ondrag</td>\n<td>该事件在元素正在拖动时触发</td>\n</tr>\n<tr>\n<td>ondragend</td>\n<td>该事件在用户完成元素的拖动时触发</td>\n</tr>\n<tr>\n<td>ondragenter</td>\n<td>该事件在拖动的元素进入放置目标时触发</td>\n</tr>\n<tr>\n<td>ondragleave</td>\n<td>该事件在拖动元素离开放置目标时触发</td>\n</tr>\n<tr>\n<td>ondragover</td>\n<td>该事件在拖动元素在放置目标上时触发</td>\n</tr>\n<tr>\n<td>ondragstart</td>\n<td>该事件在用户开始拖动元素时触发</td>\n</tr>\n<tr>\n<td>ondrop</td>\n<td>该事件在拖动元素放置在目标区域时触发</td>\n</tr>\n</tbody>\n</table>\n<h3> 2.8 多媒体事件</h3>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onabort</td>\n<td>事件在视频/音频（audio/video）终止加载时触发。</td>\n</tr>\n<tr>\n<td>oncanplay</td>\n<td>事件在用户可以开始播放视频/音频（audio/video）时触发。</td>\n</tr>\n<tr>\n<td>oncanplaythrough</td>\n<td>事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发。</td>\n</tr>\n<tr>\n<td>ondurationchange</td>\n<td>事件在视频/音频（audio/video）的时长发生变化时触发。</td>\n</tr>\n<tr>\n<td>onemptied</td>\n<td>当期播放列表为空时触发</td>\n</tr>\n<tr>\n<td>onended</td>\n<td>事件在视频/音频（audio/video）播放结束时触发。</td>\n</tr>\n<tr>\n<td>onerror</td>\n<td>事件在视频/音频（audio/video）数据加载期间发生错误时触发。</td>\n</tr>\n<tr>\n<td>onloadeddata</td>\n<td>事件在浏览器加载视频/音频（audio/video）当前帧时触发触发。</td>\n</tr>\n<tr>\n<td>onloadedmetadata</td>\n<td>事件在指定视频/音频（audio/video）的元数据加载后触发。</td>\n</tr>\n<tr>\n<td>onloadstart</td>\n<td>事件在浏览器开始寻找指定视频/音频（audio/video）触发。</td>\n</tr>\n<tr>\n<td>onpause</td>\n<td>事件在视频/音频（audio/video）暂停时触发。</td>\n</tr>\n<tr>\n<td>onplay</td>\n<td>事件在视频/音频（audio/video）开始播放时触发。</td>\n</tr>\n<tr>\n<td>onplaying</td>\n<td>事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发。</td>\n</tr>\n<tr>\n<td>onprogress</td>\n<td>事件在浏览器下载指定的视频/音频（audio/video）时触发。</td>\n</tr>\n<tr>\n<td>onratechange</td>\n<td>事件在视频/音频（audio/video）的播放速度发送改变时触发。</td>\n</tr>\n<tr>\n<td>onseeked</td>\n<td>事件在用户重新定位视频/音频（audio/video）的播放位置后触发。</td>\n</tr>\n<tr>\n<td>onseeking</td>\n<td>事件在用户开始重新定位视频/音频（audio/video）时触发。</td>\n</tr>\n<tr>\n<td>onstalled</td>\n<td>事件在浏览器获取媒体数据，但媒体数据不可用时触发。</td>\n</tr>\n<tr>\n<td>onsuspend</td>\n<td>事件在浏览器读取媒体数据中止时触发。</td>\n</tr>\n<tr>\n<td>ontimeupdate</td>\n<td>事件在当前的播放位置发送改变时触发。</td>\n</tr>\n<tr>\n<td>onvolumechange</td>\n<td>事件在音量发生改变时触发。</td>\n</tr>\n<tr>\n<td>onwaiting</td>\n<td>事件在视频由于要播放下一帧而需要缓冲时触发。</td>\n</tr>\n</tbody>\n</table>\n<h3> 2.9 动画事件</h3>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>animationend</td>\n<td>该事件在 CSS 动画结束播放时触发</td>\n</tr>\n<tr>\n<td>animationiteration</td>\n<td>该事件在 CSS 动画重复播放时触发</td>\n</tr>\n<tr>\n<td>animationstart</td>\n<td>该事件在 CSS 动画开始播放时触发</td>\n</tr>\n</tbody>\n</table>\n<h3> 2.10 过渡事件</h3>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>transitionend</td>\n<td>该事件在 CSS 完成过渡后触发。</td>\n</tr>\n</tbody>\n</table>\n<h3> 2.11 其他事件</h3>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onmessage</td>\n<td>该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发</td>\n</tr>\n<tr>\n<td>onmousewheel</td>\n<td>已废弃。 使用 onwheel事件替代</td>\n</tr>\n<tr>\n<td>ononline</td>\n<td>该事件在浏览器开始在线工作时触发。</td>\n</tr>\n<tr>\n<td>onoffline</td>\n<td>该事件在浏览器开始离线工作时触发。</td>\n</tr>\n<tr>\n<td>onpopstate</td>\n<td>该事件在窗口的浏览历史（history 对象）发生改变时触发。</td>\n</tr>\n<tr>\n<td>onshow</td>\n<td>该事件当 <code>&lt;menu&gt;</code> 元素在上下文菜单显示时触发</td>\n</tr>\n<tr>\n<td>onstorage</td>\n<td>该事件在 Web Storage(HTML 5 Web 存储)更新时触发</td>\n</tr>\n<tr>\n<td>ontoggle</td>\n<td>该事件在用户打开或关闭 <code>&lt;details&gt; </code>元素时触发</td>\n</tr>\n<tr>\n<td>onwheel</td>\n<td>该事件在鼠标滚轮在元素上下滚动时触发</td>\n</tr>\n<tr>\n<td>DOMMouseScroll</td>\n<td>火狐(firefox)支持的绑定鼠标滚轮的事件，并且该事件必须要通过addEventListener()函数来绑定事件</td>\n</tr>\n<tr>\n<td>DOMContentLoaded</td>\n<td>监听文档DOM元素的内容是否加载完成，比onload事件要监听的东西更少，DOM元素加载完毕后就会执行该事件,通过addEventListener()函数来绑定事件</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "3.DOM查询",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db3.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db3.html",
      "summary": "DOM查询 3.1 获取DOM节点 3.1.1 获取元素节点 getElementById()通过ID获取元素节点,返回一个普通对象; 注意:ID其实可以不用获取而直接使用,因为ID是具有唯一性的,但是不推荐不获取就直接使用ID，因为以后会很难区分这个变量是哪里来的 getElementsByTagName()方法通过标签名获取元素节点,返回一个类数组...",
      "content_html": "<h2> DOM查询</h2>\n<h3> 3.1 获取DOM节点</h3>\n<h4> 3.1.1 获取元素节点</h4>\n<ul>\n<li>\n<p><strong>getElementById()通过ID获取元素节点</strong>,返回一个普通对象\n**注意:**ID其实可以不用获取而直接使用,因为ID是具有唯一性的,但是不推荐不获取就直接使用ID，因为以后会很难区分这个变量是哪里来的</p>\n</li>\n<li>\n<p><strong>getElementsByTagName()方法通过标签名获取元素节点</strong>,返回一个类数组对象</p>\n</li>\n<li>\n<p><strong>getElementsByClassName()方法通过类名获取元素节点(IE8及以下版本不支持)</strong>,返回一个类数组对象</p>\n</li>\n<li>\n<p>**getElementsByName()方法通过name属性获取元素节点,**这个方法主要是获取表单项,返回一个类数组对象</p>\n</li>\n<li>\n<p>**quertSelector()方法需要一个选择器的字符串作为参数,可以根据一个CSS选择器来查询一个元素节点对象，**语法和CSS语法一样，可以多个选择器一起使用,该方法在IE8也可用\n**注意:**使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，也只会返回第一个找到的</p>\n</li>\n<li>\n<p><strong>quertSelectorAll()方法用法同quertSelector()方法相同</strong>\n**注意:**使用该方法就返回一个类数组对象，类数组对象里包含的所有符号要求的元素对象,即使符合条件的元素只有一个，也会返回类数组</p>\n</li>\n</ul>\n<p><strong>注意:querySelector()和quertSlectorAll()方法尽量少用,这两种对元素节点的查找效率很低</strong></p>\n<p><strong>静态获取与动态获取元素节点</strong></p>\n<ul>\n<li>\n<p>通过ID查找元素节点和以query开头的查找的元素节点是静态获取元素节点,这时无论元素怎么改变已经获取的元素节点所赋值后的变量永远指向该被查找到的元素节点</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>通过集合进行获取元素节点的方式为动态获取,这时每次使用集合都会获取集合的最新状态,此时通过集合赋值的变量的值也会发生相应变化</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意:</p>\n<p>如果选中了集合中的单个元素,这时获取的元素节点是静态获取</p>\n</li>\n</ul>\n<h4> 3.1.2 获取属性节点</h4>\n<ul>\n<li>\n<p>读取元素的属性节点,使用 <strong>元素.属性名</strong> 或 <strong>元素[属性名]</strong></p>\n</li>\n<li>\n<p>修改元素的属性节点,使用 <strong>元素.属性名=新值</strong> 或 <strong>元素[属性名]=新值</strong></p>\n</li>\n</ul>\n<p><strong>注意:读取元素的class属性时必须用className来代替class关键字</strong></p>\n<p><strong>获取、设立、删除标签属性节点</strong></p>\n<p>如果JS中的自定义属性与标签属性重复时,直接获取会得到自定义属性的值,所以需要特定的值获取标签属性的方法</p>\n<ul>\n<li>\n<p>通过getAttribute()方法获取标签属性节点</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>通过setAttribute()方法设立或改变一个标签属性节点</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>通过removeAttribute()方法删除一个标签属性节点</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n<h4> 3.1.3 获取文本节点</h4>\n<ul>\n<li>\n<p><strong>innerHTML属性可以获取双标签元素内部的html代码，包括子标签,这个属性对于单标签元素(如表单标签)没有意义</strong>,返回一个字符串</p>\n</li>\n<li>\n<p><strong>InnerText属性可以获取双标签元素内部的文本内容，它和InnerHTML属性类似，但会自动将HTML标签去除</strong>,返回一个字符串</p>\n</li>\n<li>\n<p>**value属性可以获取单标签元素(如表单标签)内部的内容,**同时要向单标签元素写入内容也必须使用value属性,返回一个字符串</p>\n</li>\n<li>\n<p><strong>nodeValue属性通过获取标签内的文本节点的内容来获取元素内部的文本内容</strong>(因为文本节点实际是一个标签的子节点,所以需要先找到文本节点)</p>\n<p>,返回一个字符串</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<h4> 3.1.4 获取元素子节点</h4>\n<p><strong>元素子节点的有同父节点一样获取子节点的方法或属性</strong></p>\n<ul>\n<li>\n<p><strong>childNodes属性获取元素子节点</strong>，该属性会获取包括文本节点的所有子节点，返回一个类数组对象</p>\n</li>\n<li>\n<p><strong>children属性可以获取当前元素的所有子元素</strong>，推荐用这个属性，返回一个类数组对象,而且是动态获取</p>\n</li>\n<li>\n<p><strong>firstChild属性表示当前节点的第一个子节点</strong>，也包括空白文本，返回一个普通对象</p>\n</li>\n<li>\n<p><strong>firstElementChild属性获取第一个子元素</strong></p>\n<p>返回一个普通对象，但是不兼容IE8，不推荐使用</p>\n<p>兼容代码</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>**lastChild属性表示当前节点的最后一个子节点，**也包括空白文本，返回一个普通对象</p>\n</li>\n<li>\n<p>**lastElementChld属性获取最后一个子元素，**返回一个普通对象，但是不兼容IE8，不推荐使用</p>\n</li>\n<li>\n<p><strong>childElementCount属性元素子节点个数,不兼容IE8</strong></p>\n</li>\n</ul>\n<h4> 3.1.5 获取父和兄弟节点</h4>\n<ul>\n<li>\n<p><strong>parentElement属性获取当前节点的父元素(只在IE中可用)</strong></p>\n</li>\n<li>\n<p>**parentNode属性获取当前节点的父节点,**这是W3C标准的,推荐使用</p>\n</li>\n<li>\n<p><strong>offsetParent属性获取到离当前元素最近的开启了定位(除去默认的static)的祖先元素</strong>，如果所以的祖先元素都没有开启定位，则会返回body</p>\n</li>\n<li>\n<p><strong>previousSibling属性获取当前节点的前一个兄弟节点</strong>\n**注意:**可能获取空白文本，如果两个元素中间有空白就会获取空白</p>\n</li>\n<li>\n<p>**previosElementSibling属性获取前一个元素，**IE8不支持</p>\n</li>\n<li>\n<p><strong>nextSibiling属性表示当前节点的后一个兄弟节点</strong></p>\n</li>\n<li>\n<p>**nextElementSibling获取后一个元素，**IE8不支持</p>\n</li>\n</ul>\n<h4> 3.1.6 获取特殊元素节点</h4>\n<ul>\n<li>\n<p>在document元素中有一个body属性,它保存的是对body元素的引用</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>在document元素中有一个documentElement属性,它保存html标签的引用</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>在document元素中有一个all属性,该属性代表页面中所有元素(不建议使用)</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n<p><strong>表格的简便操作</strong></p>\n<ul>\n<li>\n<p>getElementsByTagName(\"tbody\")[0]与tBodies[0]相同</p>\n</li>\n<li>\n<p>getElementsByTagName(\"thead\")[0]与tHead相同</p>\n</li>\n<li>\n<p>getElementsByTagName(\"tfoot\")[0]与tFoot相同</p>\n</li>\n<li>\n<p>getElementsByTagName(\"tr\")[0]与rows[0]相同</p>\n</li>\n<li>\n<p>getElementsByTagName(\"td\")[0]与cells[0]相同</p>\n</li>\n</ul>\n<h3> 3.2 创建或添加元素节点</h3>\n<ul>\n<li>\n<p>createElement()方法可以创建一个元素节点对象</p>\n<p>它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回</p>\n<p>注意:</p>\n<p>该方法由document使用</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>createTextNote()方法可以创建一个文本节点对象</p>\n<p>需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新节点返回</p>\n<p>注意:</p>\n<p>该方法由document创建</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p><strong>createElementFragment()方法</strong>创建一个文档片段,</p>\n<p>可以向这个文档片段中添加一个个节点,然后直接将该文档片段加到要添加到的父元素中,该方法可以实现同时给页面加多个节点而只用渲染一次页面,所以如果要添加多个同级节点时最好使用这个来添加</p>\n<p>注意:</p>\n<p>放入文档片段的节点一定要是同级的片段</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>cloneNode()方法可以传入一个参数，克隆一个DOM节点，如果传入true则是把元素中的所有内容也一起克隆，如果传入的是false则会只克隆这一个DOM节点，不会将里面的内容也克隆</p>\n<p>(不传入参数默认为flase)</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p><strong>appendChild()向父节点中添加一个新的子节点</strong>，可以逐层添加子节点\n<strong>注意:</strong></p>\n</li>\n<li>\n<ul>\n<li>该方法由父节点调用</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<p>要添加子节点之前必须要先有这个子节点，没有就要先创建，并且新加的子节点会自动添加到所有子节点的最后面</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n</li>\n<li>\n<ul>\n<li>如果子节点不是新创建而是从原有父级节点上调用的,那么在用appenChild()方法时会先将原有父级节点上的该子节点删除</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p><strong>insertBefore()方法在指定的子节点前面插入子节点</strong>\n<strong>注意:</strong></p>\n</li>\n<li>\n<ul>\n<li>该方法由父节点调用,传入两个参数(新节点和旧节点),第一个参数必填,第二个参数可选</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>要添加子节点之前必须要先有这个子节点，没有就要先创建，并且<strong>如果没有传入第二个参数</strong>会自动添加到所有子节点的最后面</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>如果子节点不是新创建而是从原有父级节点上调用的,那么在用insertBefore()方法时会先将原有父级节点上的该子节点删除</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><ul>\n<li>\n<p>使用innerHTML属性也可以完成DOM的增删改等操作</p>\n<p>可以给innerHTML属性赋值带有HTML标签的字符串实现操作,</p>\n<p>一般我们会将DOM查询和innerHTML属性两种方法同时使用</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n<h3> 3.3 替换或删除元素节点</h3>\n<ul>\n<li>\n<p><strong>replaceChild()方法可以使用指定的子节点替换已有的子节点</strong>\n<strong>注意:</strong></p>\n</li>\n<li>\n<ul>\n<li>该方法由父节点调用</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>要替换子节点之前必须要先有这个新的子节点，没有就要先创建</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>如果子节点不是新创建而是从原有父级节点上调用的,那么在用replace()方法时会先将原有父级节点上的该子节点删除</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><ul>\n<li>\n<p><strong>removeChild()方法可以用作删除一个子节点</strong></p>\n<p>注意:</p>\n<p>该方法由父节点调用</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n<p><strong>注:上述的DOM查询方法可以混合搭配使用</strong></p>\n<p>**如:**在不知道一个子节点的父节点的情况下删除该子节点</p>\n<p>通过 <strong>子节点.parentNode.removeChild(子节点)</strong> 的方法就可以删除</p>\n<h3> 3.4 遍历DOM元素</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "4.元素样式",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db4.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db4.html",
      "summary": "元素样式 4.1 修改元素CSS样式 4.1.1 通过style属性修改元素样式 通过 元素.style.样式名=\"样式值\" 的方式设置修改CSS样式 注意: 如果CSS的样式名中含有-(也就是减号)，这种名称在JS中是不合法的，比如background-color,需要将这种样式名修改为驼峰命名法，去掉-，然后将-后的字母大写，如:backgroun...",
      "content_html": "<h2> 元素样式</h2>\n<h3> 4.1 修改元素CSS样式</h3>\n<h4> 4.1.1 通过style属性修改元素样式</h4>\n<p>通过 <strong>元素.style.样式名=\"样式值\"</strong> 的方式设置修改CSS样式</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>\n<p>如果CSS的样式名中含有-(也就是减号)，这种名称在JS中是不合法的，比如background-color,需要将这种样式名修改为<strong>驼峰命名法</strong>，去掉-，然后将-后的字母大写，如:background-color写作backgroumdColor，border-top-width写作borderTopWidth</p>\n</li>\n<li>\n<p>因为float样式是JS中的保留字,所有在修改元素浮动属性的时候不能够直接写作 <strong>元素.style.float=\"样式值\"</strong> 的形式,需要**用styleFloat(兼容IE6~8)或cssFloat(IE9以上使用)**来代替使用</p>\n</li>\n<li>\n<p>通过style属性设置的样式都是内联样式，而内联样式有较高的优先级，所以通过JS修改的样式往往会立即重置，但是如果在样式中用了!important则样式会拥有最高优先级，导致JS修改样式失效，所以尽量不要使用important</p>\n</li>\n<li>\n<p>通过JS的style属性设置和读取的都是内联样式，无法读取CSS样式表中的样式(外部样式和嵌套样式)</p>\n</li>\n</ul>\n<p><strong>简写方式</strong></p>\n<p>通过 <strong>元素.style.cssText=\"样式值\"</strong>  的方式可以将多个CSS属性同时写入,右边的值的写法和内联的CSS样式一样的,并不用遵循驼峰命名法,也不用在意JS的保留字问题</p>\n<h4> 4.1.2 通过类修改元素样式</h4>\n<p>通过**修改类(class)**来修改CSS样式</p>\n<ul>\n<li>\n<p><strong>修改className属性</strong>\n通过修改元素的className属性(在JS中的class是保留字,所以用className来代替)来间接修改样式，这样一来，只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好\n<strong>用className属性添加一个类</strong>\n<strong>元素.className+=\" 类名\"</strong>，记得在类名前面加上空格</p>\n</li>\n<li>\n<p><strong>通过classList属性</strong>\n每个标签元素都有classList属性,这个属性和当中的一些方法可以让我们修改类时更加简便</p>\n</li>\n<li>\n<ul>\n<li><strong>classList属性返回元素的类名,该属性只读</strong>,只能通过该属性的一些方法来修改元素的类</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>classList属性有length属性,该属性返回元素类的属性,并且该属性只读</strong></li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<p>classList属性的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>add(class1, class2, ...)</code></td>\n<td>在元素中添加一个或多个类名。  如果指定的类名已存在，则不会添加</td>\n</tr>\n<tr>\n<td><code>contains(class)</code></td>\n<td>返回布尔值，判断指定的类名是否存在。可能值：true - 元素包已经包含了该类名false - 元素中不存在该类名</td>\n</tr>\n<tr>\n<td><code>item(index)</code></td>\n<td>返回元素中索引值对应的类名。索引值从 0 开始。  如果索引值在区间范围外则返回 <em>null</em></td>\n</tr>\n<tr>\n<td><code>remove(class1, class2, ...)</code></td>\n<td>移除元素中一个或多个类名。<strong>注意:</strong> 移除不存在的类名，不会报错。</td>\n</tr>\n<tr>\n<td><code>toggle(class, true|false)</code></td>\n<td>在元素中切换类名。  第一个参数为要在元素中移除的类名，并返回 false。  如果该类名不存在则会在元素中添加类名，并返回 true。   第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存在。也就是说如果写了第二个参数那么该方法就变成了add()或remover()方法</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ul>\n</li>\n</ul>\n<h3> 4.2 获取元素样式</h3>\n<h4> 4.2.1 通用样式</h4>\n<ul>\n<li>\n<p><strong>在IE了浏览器中通过currentStyle属性来获取当前元素正在显示的样式</strong>,如果获取的是没有设置的样式,就会返回该样式的默认值,并且如果<strong>默认是以px为单位</strong>来返回的\n**如:**没有设置width就会返回默认值auto\n**语法:**元素.currentStyle.样式名</p>\n</li>\n<li>\n<p>在其他浏览器可以使用getComputedStyle()方法来获取元素样式(IE8以下不支持,)这个方法是window的方法，可以直接进行调用</p>\n<p>该方法</p>\n<p>有两个参数，</p>\n<p>第一个参数传入一个元素,第二个参数传入一个伪类,第二个参数可选,当不查询伪类元素的时候可以忽略或者传入null。该方法会</p>\n<p>返回一个对象</p>\n<p>，对象中封装了当前元素对应的样式，可以通过样式名来读取样式，如果获取的样式没有设置，与currentStyle属性不同,会获取真实的值，而不是默认值，同时值也是默认以</p>\n<p>px为单位</p>\n<p>来返回的</p>\n<p>如:</p>\n<p>没有设置width,不会返回auto,而是返回一个长度</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n<p>**注意:**通过currentStyle属性和getComputedStyle()方法读取到的样式都是只读的，不能修改，如果要修改必须通过style属性</p>\n<p><strong>兼容写法</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 4.2.2 获取特殊样式</h4>\n<p><strong>注:以下获取的样式都是只读的,不能够修改</strong></p>\n<p><strong>属性</strong></p>\n<ul>\n<li>\n<p><strong>clientWidth和clientHeight属性获取元素的可见宽度和高度(内容区和内边距)，这些属性都是返回纯数值</strong>，不带单位,可以直接进行计算</p>\n</li>\n<li>\n<p><strong>offsetWidth和offsetHeight属性获取元素的整个宽度和高度(内容区，内边距和边框),返回值也是纯数值</strong></p>\n</li>\n<li>\n<p><strong>offsetLeft和offsetTop属性获取当前元素相对于其定位父元素的水平偏移量和垂直偏移量</strong>\n**注意:**偏移量的原点是父元素的左上角(left top),和背景图片的原点相同</p>\n</li>\n<li>\n<p><strong>window.innerWidth</strong>和<strong>window.innerHeight</strong>属性可以获取window窗口的内部宽高</p>\n<p>注意:</p>\n<p>不包括页面的导航栏以及页面滚动条和控制台</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p>document.documentElement.clientWidth和document.documentElement.clientWidth属性获取文档可视区域</p>\n<p>,该属性的值虽然与window,innerWidth和window.innerHeight的值相同,但是对象的调用者不同,内部的含义也不同</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p><strong>scrollWidth和scrollHeight属性可以获取元素整个滚动区域的宽度和高度,如果没有隐藏的部分则等于clientWidth和clientHeight</strong></p>\n</li>\n<li>\n<p>scrollLeft和scrollTop属性可以获取水平和垂直滚动条滚动的距离</p>\n<p>浏览器滚动条问题</p>\n<p>chrome认为浏览器的滚动条是body元素的，可以通过body.scrollTopl来获取，而火狐和IE浏览器认为浏览器的滚动条是html元素的，所以在用到浏览器滚动条的时候就会出现兼容问题(现在的chrome版本已经和火狐与IE统一都是通过html元素获取了,通过body获取反而值为0)</p>\n<p>兼容代码</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n<p><strong>注:当满足<code>scrollHeight-ScrollTop===clientHeight</code> 这个表示式时说明垂直滚动条到底了，同理水平滚动条也一样</strong></p>\n<p><strong>自制滚动条</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>方法</strong></p>\n<ul>\n<li>\n<p><strong>getBoundingClientRect()方法获取元素节点对象到窗口的左上角(恒定为刚打开页面时的左上角为原点)的距离值以及自身的长宽等属性</strong>,该方法不用传入参数</p>\n</li>\n<li>\n<p><strong>scrollIntoView()方法让滚动条滚动到调用对象的可视区,一旦执行此方法调用此方法的页面就会滚动到该元素节点的位置</strong>,此方法不用传入参数</p>\n</li>\n</ul>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "5.事件对象",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db5.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db5.html",
      "summary": "事件对象 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为默认实参(如果没有传入参数位置为arguments[0])传递进响应函数，在事件对象中封装了当前事件相关的一些信息，比如:鼠标的坐标，键盘哪个按键被按下 ，鼠标滚轮滚动的方向 注: 一般都会把形参写在事件对象的形参里,虽然不写也不会报错,但是获取方式会相对麻烦; 在IE中,event事...",
      "content_html": "<h2> 事件对象</h2>\n<p>当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为默认实参(如果没有传入参数位置为arguments[0])传递进响应函数，在事件对象中封装了当前事件相关的一些信息，比如:鼠标的坐标，键盘哪个按键被按下 ，鼠标滚轮滚动的方向</p>\n<p><strong>注:</strong></p>\n<ul>\n<li>\n<p>一般都会把形参写在事件对象的形参里,虽然不写也不会报错,但是获取方式会相对麻烦</p>\n</li>\n<li>\n<p>在IE中,event事件对象通过window.event来获取，在其他浏览器中是作为参数传入使用</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-javascript\" data-ext=\"js\"></div><h3> 5.1 基本事件对象</h3>\n<ul>\n<li><strong>常量</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>静态变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CAPTURING-PHASE</td>\n<td>当前事件阶段为捕获阶段(1)</td>\n</tr>\n<tr>\n<td>AT-TARGET</td>\n<td>当前事件是目标阶段,在评估目标事件(1)</td>\n</tr>\n<tr>\n<td>BUBBLING-PHASE</td>\n<td>当前的事件为冒泡阶段 (3)</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>属性</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bubbles</td>\n<td>返回布尔值，指示事件是否是起泡事件类型。</td>\n</tr>\n<tr>\n<td>cancelable</td>\n<td>返回布尔值，指示事件是否可拥可取消的默认动作。</td>\n</tr>\n<tr>\n<td>currentTarget</td>\n<td>返回其事件监听器触发该事件的元素。</td>\n</tr>\n<tr>\n<td>eventPhase</td>\n<td>返回事件传播的当前阶段。</td>\n</tr>\n<tr>\n<td>target</td>\n<td>返回触发此事件的元素（事件的目标节点）。不兼容低版本IE,低版本IE用srcElement</td>\n</tr>\n<tr>\n<td>timeStamp</td>\n<td>返回事件生成的日期和时间。</td>\n</tr>\n<tr>\n<td>type</td>\n<td>返回当前 Event 对象表示的事件的名称。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>initEvent()</td>\n<td>初始化新创建的 Event 对象的属性。</td>\n</tr>\n<tr>\n<td>preventDefault()</td>\n<td>通知浏览器不要执行与事件关联的默认动作。</td>\n</tr>\n<tr>\n<td>stopPropagation()</td>\n<td>不再派发事件。</td>\n</tr>\n</tbody>\n</table>\n<h3> 5.2 目标事件对象</h3>\n<p><strong>方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>addEventListener()</td>\n<td>允许在目标事件中注册监听事件(IE8 = attachEvent())</td>\n</tr>\n<tr>\n<td>dispatchEvent()</td>\n<td>允许发送事件到监听器上 (IE8 = fireEvent())</td>\n</tr>\n<tr>\n<td>removeEventListener()</td>\n<td>运行一次注册在事件目标上的监听事件(IE8 = detachEvent())</td>\n</tr>\n</tbody>\n</table>\n<h3> 5.3 事件监听对象</h3>\n<p><strong>方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>handleEvent()</td>\n<td>把任意对象注册为事件处理程序</td>\n</tr>\n</tbody>\n</table>\n<h3> 5.4 文档事件对象</h3>\n<p><strong>方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>createEvent()</td>\n<td>返回新创建的event对象</td>\n</tr>\n</tbody>\n</table>\n<h3> 5.4 鼠标/键盘事件对象</h3>\n<ul>\n<li><strong>属性</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>altKey</td>\n<td>返回当事件被触发时，\"ALT\" 是否被按下。</td>\n</tr>\n<tr>\n<td>button</td>\n<td>返回当事件被触发时，哪个鼠标按钮被点击。</td>\n</tr>\n<tr>\n<td>clientX</td>\n<td>返回当事件被触发时，鼠标指针的水平坐标。</td>\n</tr>\n<tr>\n<td>clientY</td>\n<td>返回当事件被触发时，鼠标指针的垂直坐标。</td>\n</tr>\n<tr>\n<td>ctrlKey</td>\n<td>返回当事件被触发时，\"CTRL\" 键是否被按下。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>返回按键在设备上的位置</td>\n</tr>\n<tr>\n<td>charCode</td>\n<td>返回onkeypress事件触发键值的字母代码。</td>\n</tr>\n<tr>\n<td>key</td>\n<td>在按下按键时返回按键的标识符。</td>\n</tr>\n<tr>\n<td>keyCode</td>\n<td>返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。</td>\n</tr>\n<tr>\n<td>which</td>\n<td>返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。</td>\n</tr>\n<tr>\n<td>metaKey</td>\n<td>返回当事件被触发时，\"meta\" 键是否被按下。</td>\n</tr>\n<tr>\n<td>relatedTarget</td>\n<td>返回与事件的目标节点相关的节点。</td>\n</tr>\n<tr>\n<td>screenX</td>\n<td>返回当某个事件被触发时，鼠标指针的水平坐标。</td>\n</tr>\n<tr>\n<td>screenY</td>\n<td>返回当某个事件被触发时，鼠标指针的垂直坐标。</td>\n</tr>\n<tr>\n<td>shiftKey</td>\n<td>返回当事件被触发时，\"SHIFT\" 键是否被按下。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>方法</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>initMouseEvent()</td>\n<td>初始化鼠标事件对象的值</td>\n</tr>\n<tr>\n<td>initKeyboardEvent()</td>\n<td>初始化键盘事件对象的值</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "6.事件的冒泡(Bubble)",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db6.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db6.html",
      "summary": "事件的冒泡(Bubble) 所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发，在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡，可以通过事件对象来取消冒泡，可以通过设置event.cancelBubble=true来取消冒泡，这个需要设置在子元素的事件中，并且大多数都是设置的可以冒泡，除了某些函数默认...",
      "content_html": "<h2> 事件的冒泡(Bubble)</h2>\n<p>所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发，在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡，可以通过事件对象来取消冒泡，可以通过设置<code>event.cancelBubble=true</code>来取消冒泡，这个需要<strong>设置在子元素的事件中</strong>，并且大多数都是设置的可以冒泡，除了某些函数默认不冒泡</p>\n<p><strong>如果在父元素里面设置了一个事件,而在子元素中也有相同的事件,不想要父元素的事件在子元素的范围内出现时，可以通过多种方式设置取消冒泡</strong></p>\n<p><strong>1.event.cancelBubble=true(低版本IE都通过该方法)</strong></p>\n<p><strong>2.因为这是默认行为，所以也可以直接在事件函数返回flase即可(return flase)</strong></p>\n<p>**注意:**这种方法阻止默认行为只能够阻止通过onclick等绑定的事件,不能阻止通过addEventListener()等绑定的事件</p>\n<p><strong>3.通过event.stopPropagation()来阻止事件冒泡，但是不会阻止默认行为(低版本IE不兼容),低版本IE用event.returnValue=false</strong></p>\n<p><strong>4.通过event.preventDefault()阻止默认行为来阻止冒泡</strong></p>\n<p><strong>兼容写法</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "7.事件的委派",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db7.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db7.html",
      "summary": "事件的委派 事件的委派指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件,事件委派是利用了冒泡，通过委派可以事件绑定的次数，提高程序的性能 例子: 为每一个超链接都绑定一个单击响应函数，这里我们为每一个超链接都绑定了一个单击响应函数，这种中操作比较麻烦，而且这些操作只能为已有...",
      "content_html": "<h2> 事件的委派</h2>\n<p>事件的委派指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件,事件委派是利用了冒泡，通过委派可以事件绑定的次数，提高程序的性能</p>\n<p><strong>例子:</strong></p>\n<p>为每一个超链接都绑定一个单击响应函数，这里我们为每一个超链接都绑定了一个单击响应函数，这种中操作比较麻烦，而且这些操作只能为已有的超链接设置事件，而新添加超链接必须重新绑定</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>我们希望，只绑定一次事件，即可应用到多个元素上，即使元素是后添加的，我们可以尝试将其绑定给元素的共同的祖先元素</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>但是这个例子需要判断如果触发的对象是我们期望的元素,就执行该代码,否则不执行,因为如果点击的是a元素之外的其它地方就不触发弹窗效果,这个时候需要使用target 事件对象中的event中的target表示的触发事件的对象</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "8.事件的绑定",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db8.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db8.html",
      "summary": "事件的绑定 8.1 绑定事件 通过 对象.事件=函数 的形式绑定的响应函数，只能同时为一个元素的一个事件绑定一个响应函数，不能够绑定多个，如果绑定了多个，则后边绑定的响应函数会覆盖掉前边的 通过addEventListener()方法(不支持IE8及以下浏览器)可以为元素绑定多个响应函数,该方法有三个参数; 参数 - 代表事件的字符串,不要加on; -...",
      "content_html": "<h2> 事件的绑定</h2>\n<h3> 8.1 绑定事件</h3>\n<p>通过 <strong>对象.事件=函数</strong> 的形式绑定的响应函数，只能同时为一个元素的一个事件绑定一个响应函数，不能够绑定多个，如果绑定了多个，则后边绑定的响应函数会覆盖掉前边的</p>\n<ul>\n<li>\n<p><strong>通过addEventListener()方法(不支持IE8及以下浏览器)可以为元素绑定多个响应函数</strong>,该方法有三个参数\n<strong>参数</strong></p>\n</li>\n<li>\n<ul>\n<li>代表事件的字符串,不要加on</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>回调函数，当事件触发时该函数会被调用</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>是否在捕获或冒泡阶段触发事件，需要一个布尔值，true表示事件在捕获阶段执行,flase表示在冒泡阶段执行,默认值为false(可选),如果想要这两个事件都可以在同一个对象上发生必须添加两次事件</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>addEventListene0r()方法可以同时为一个元素的相同事件绑定响应函数，这样当事件被触发时，响应函数将<strong>会按照函数的绑定顺序执行</strong></p>\n<ul>\n<li>\n<p><strong>在IE8及以下浏览器中可以通过attachEvent()方法为元素绑定多个响应函数</strong>,该方法有两个参数\n<strong>参数</strong></p>\n</li>\n<li>\n<ul>\n<li>事件的字符串，要加on</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>回调函数</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>​\tattachEvent()方法也可以同时为一个元素的相同事件绑定响应函数，不同的是该方法是<strong>后绑定的响应函数先执行</strong></p>\n<p><strong>注:</strong></p>\n<ul>\n<li>\n<p><strong>大部分时候响应函数的执行顺序都不重要，如果需要对顺序要求就写成一个响应函数，要用这种方法添加的响应函数都是顺序不重要的函数</strong></p>\n</li>\n<li>\n<p><strong>事件的绑定和委派等最好都是通过addEventListener()方法等来绑定,以免和别人的发生冲突</strong></p>\n</li>\n</ul>\n<p>**注意:**addEventListener()方法中的this是绑定事件的对象，attachEvent()方法中的this是window对象</p>\n<p><strong>兼容写法</strong></p>\n<p>注意:addEventListener()中的this是绑定事件的对象，attachEvent()中的this是window，需要统一两个方法的this</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 8.2 移除绑定</h3>\n<ul>\n<li>\n<p><strong>通过removeEventListener()方法(不支持IE8及以下浏览器)可以为元素移除响应函数</strong>,该方法有三个参数\n<strong>参数</strong></p>\n</li>\n<li>\n<ul>\n<li>代表事件的字符串,不要加on</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>需要被移除的事件函数</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>是否在捕获或冒泡阶段取消绑定事件，需要一个布尔值，true表示事件在捕获阶段执行,flase表示在冒泡阶段执行,默认值为false(可选)</li>\n</ul>\n</li>\n<li>\n<p><strong>在IE8及以下浏览器中可以通过detachEvent()方法为元素移除响应函数</strong>,该方法有两个参数\n<strong>参数</strong></p>\n</li>\n<li>\n<ul>\n<li>事件的字符串，要加on</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>回调函数</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意:</strong></p>\n<ul>\n<li>\n<p>如果要使用移除绑定,那么绑定时需要必须通过函数赋值的方式来绑定,因为如果是匿名函数移除的函数并不是同一个对象</p>\n</li>\n<li>\n<p>如果不为removeEventListener()方法传入第三个参数会默认是移除冒泡状态的事件函数,不会移除捕获阶段的,因为这其实是两个不同的事件</p>\n</li>\n<li>\n<p>移除绑定只能对用上述方法绑定的函数器作用,不会对用onclick属性等绑定的函数起作用</p>\n</li>\n</ul>\n<p><strong>兼容写法</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "9.事件的传播",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/db9.html",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/db9.html",
      "summary": "事件的传播 关于事件的传播网景公司和微软公司有不同的看法 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就是说事件应该在冒泡阶段执行; 网景公司认为事件应该是由外向内传播，也就是当前事件被触发时，应该先触发当前元素的最外层的祖先元素的事件，然后再向内传播给后代元素，这个阶段叫做捕...",
      "content_html": "<h2> 事件的传播</h2>\n<p><strong>关于事件的传播网景公司和微软公司有不同的看法</strong></p>\n<ul>\n<li>\n<p>微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就是说事件应该在冒泡阶段执行</p>\n</li>\n<li>\n<p>网景公司认为事件应该是由外向内传播，也就是当前事件被触发时，应该先触发当前元素的最外层的祖先元素的事件，然后再向内传播给后代元素，这个阶段叫做捕获阶段</p>\n</li>\n</ul>\n<p><strong>最后，W3C综合了两个公司的方案，将事件传播分成了三个阶段</strong></p>\n<p><strong>1.捕获阶段</strong></p>\n<p>在捕获阶段时从最外层的祖先元素，向目标元素进行进行事件的捕获，但是默认此时不会触发事件</p>\n<p><strong>2.目标阶段</strong></p>\n<p>事件捕获到目标元素，捕获结束开始在目标元素上触发事件</p>\n<p><strong>3.冒泡阶段</strong></p>\n<p>事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>\n<p>如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true,一般情况下我们不会希望在捕获阶段触发事件，所以这个事件一般都是false</p>\n</li>\n<li>\n<p>IE8及以下没有捕获阶段</p>\n</li>\n</ul>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "DOM&BOM",
      "url": "https://harryxiong24.github.io/zh/front-end/dom-bom/",
      "id": "https://harryxiong24.github.io/zh/front-end/dom-bom/",
      "summary": "DOM全称Document Object Model(文档对象模型) 文档:整个HTML网页文档对象; 对象:网页中的每一个部分都被转换为了一个对象; 模型:使用模型表示对象之间的关系，方便我们获取对象;",
      "content_html": "<h1> DOM&amp;BOM</h1>\n<p><strong>DOM全称Document Object Model(文档对象模型)</strong></p>\n<ul>\n<li>\n<p><strong>文档</strong>:整个HTML网页文档对象</p>\n</li>\n<li>\n<p><strong>对象</strong>:网页中的每一个部分都被转换为了一个对象</p>\n</li>\n<li>\n<p><strong>模型</strong>:使用模型表示对象之间的关系，方便我们获取对象</p>\n</li>\n</ul>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "HTML进阶",
      "url": "https://harryxiong24.github.io/zh/front-end/html-css/advanced-html.html",
      "id": "https://harryxiong24.github.io/zh/front-end/html-css/advanced-html.html",
      "summary": "[[toc]] 1.拖拽 拖拽事件需要在需要拖拽的元素上设置draggable=true来让该元素可以被拖拽 1.1 主要事件 dragstart:当用户开始拖动元素或者拖动选中文本时触发，应用在被拖拽元素上; drag:当元素或者选中的文本被拖动时触发（每几百毫秒触发一次），应用在被拖拽元素上; dragend:当拖动操作结束时触发（通过释放鼠标按钮...",
      "content_html": "<h1> HTML进阶</h1>\n\n<h2> 1.拖拽</h2>\n<p><strong>拖拽事件需要在需要拖拽的元素上设置<code>draggable=true</code>来让该元素可以被拖拽</strong></p>\n<h3> 1.1 主要事件</h3>\n<ul>\n<li>\n<p><strong>dragstart</strong>:当用户开始拖动元素或者拖动选中文本时触发，应用在被拖拽元素上</p>\n</li>\n<li>\n<p><strong>drag</strong>:当元素或者选中的文本被拖动时触发（每几百毫秒触发一次），应用在被拖拽元素上</p>\n</li>\n<li>\n<p><strong>dragend</strong>:当拖动操作结束时触发（通过释放鼠标按钮或者点击转义键），应用在被拖拽元素上</p>\n</li>\n<li>\n<p><strong>dragenter</strong>:当一个被拖动的元素或者选中的文本进入一个有效的放置目标时触发，应用在目标元素上</p>\n</li>\n<li>\n<p><strong>dragover</strong>:当元素或者选中的文本被拖动到有效放置区域上方时触发（每几百毫秒触发一次），应用在目标元素上</p>\n</li>\n<li>\n<p><strong>dragleave</strong>：当拖动元素或者选中的文本离开有效的放置区域时触发，应用在目标元素上</p>\n</li>\n<li>\n<p><strong>drop</strong>:当元素或选中的文本在有效区域放置时触发，应用在目标元素上</p>\n</li>\n<li>\n<p><strong>dragexit</strong>:当元素不再是拖动操作的直接选择元素时触发(很少使用)</p>\n</li>\n</ul>\n<h3> 1.2 注意事项及兼容问题</h3>\n<ul>\n<li>\n<p><strong>ondrop</strong>事件不能调用,因为HTML元素默认是阻止放的操作的,想让这个事件被调用,必须要在正在拖拽的时候<strong>ondragover</strong>时阻止默认事件</p>\n</li>\n<li>\n<p>注意火狐浏览器在拖拽时需要要携带数据,在其它浏览器你只需要在HTML元素上加上</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>即可 ,但因为火狐要求被拖动元素必须包含数据</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<h3> 1.3 案例-将外部文件拖入盒子中</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>MIME类型文件</strong>\nMIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME消息能包含文本、图像、音频、视频以及其他应用程序专用的数据,类型大约有191种类型,不同的应用程序支持不同的 MIME 类型</p>\n<p><strong>base64类型文件</strong></p>\n<p>base64是网络上最常见的用于传输8Bit字节码的编码方式之一,base64就是一种基于64个可打印字符来表示二进制数据的方法,base64编码是从二进制到字符的过程中,可用于在HTTP环境下传递较长的标识信息</p>\n<p><strong>FileReader文件对象</strong></p>\n<p>FileReader API 用于读取文件，即把文件内容读入内存，是一种异步文件读取机制，它的参数是 File 对象或 Blob 对象。对于不同类型的文件，FileReader 提供不同的方法读取文件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 1.4 dataTransfer</h3>\n<ul>\n<li>\n<p>**setData(format,data)😗*设置拖拽元素的信息</p>\n</li>\n<li>\n<ul>\n<li>\n<p>format:系统默认格式为</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>(也可以直接写text)、</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>、</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>、</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>(也可以自定义format，把format-data当key-value键值对使用)</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n</ul>\n</li>\n<li>\n<ul>\n<li>data:保存在拖拽元素中的数据</li>\n</ul>\n</li>\n<li>\n<p><strong>getData(format)</strong>:获取拖拽元素的信息,可以通过该方式获取选中拖入的文字,然后将文字拖到投放区</p>\n</li>\n<li>\n<ul>\n<li>format:和setData里的format遥相呼应，才能取到相应的值</li>\n</ul>\n</li>\n<li>\n<p>**clearData()😗*清除拖拽信息</p>\n</li>\n</ul>\n<p><strong>dataTransfer的常用属性</strong></p>\n<ul>\n<li>\n<p>**effectAllowed:**设置拖拽时应带有的样式类型\n**注:**应该在dragstart事件中设置此属性，以便为拖动源设置所需的拖动效果,在dragenter 和dragover 事件处理程序中,该属性将设置为在dragstart 事件期间分配的任何值,因此,可以使用effectAllowed来确定允许哪个效果\n<strong>值:</strong></p>\n</li>\n<li>\n<ul>\n<li><strong>none</strong>,此项表示不允许放下</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>copy</strong>,源项目的复制项可能会出现在新位置。</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>copyLink</strong>,允许 <em>copy</em> 或者 <em>link</em> 操作</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>copyMove</strong>,允许 <em>copy</em> 或者 <em>move</em> 操作</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>link</strong>,可以在新地方建立与源的链接</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>linkMove</strong>,允许 <em>link</em> 或者 <em>move</em> 操作</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>move</strong>,一个项目可能被移动到新位置</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>all</strong>,允许所有的操作</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>uninitialized</strong>,效果没有设置时的默认值，则等同于<em>all</em></li>\n</ul>\n</li>\n<li>\n<p>**dropEffect:**设置拖拽元素被放下时的样式</p>\n</li>\n<li>\n<p><strong>files</strong>:内含一系列文件信息，常用于将文件从桌面拖向浏览器</p>\n</li>\n</ul>\n<h2> 2.Blob</h2>\n<p><strong>file对象的父类型是Blob对象,Blob对象代表了一段二进制数据,提供了一系列操作接口</strong></p>\n<p><strong>生成 Blob 对象有两种方法</strong></p>\n<ul>\n<li>\n<p>使用 Blob 构造函数</p>\n</li>\n<li>\n<p>另一种是对现有的 Blob 对象使用 slice 方法切出一部分</p>\n</li>\n</ul>\n<p><strong>Blob对象有两个只读属性</strong></p>\n<ul>\n<li>\n<p>**size:**二进制数据的大小,单位为字节(文件上传时,可以在前端判断文件大小是否合适)</p>\n</li>\n<li>\n<p>**type:**二进制数据的 MIME 类型,全部为小写,如果类型未知,则该值为空字符串(文件上传时可以在前端判断文件类型是否合适)</p>\n</li>\n<li>\n<ul>\n<li>**gbk编码:**数字字母 一字节 1KB= 1024字节 一个中文汉字是2字节</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**UTF-8编码:**数字字母 一字节 1KB= 1024字节 一个中文汉字是3字节</li>\n</ul>\n</li>\n</ul>\n<h3> 2.1 Bolb构造函数</h3>\n<p><strong>Blob 构造函数接受两个参数,但是这两个参数都不是必需的</strong></p>\n<ul>\n<li>\n<p>一个包含实际数据的数组</p>\n</li>\n<li>\n<p>数据的类型</p>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 2.2 Bolb对象的slice方法</h3>\n<p><strong>Blob对象的slice方法,将二进制数据按照字节分块,并且返回一个新的Blob对象,只读取文件的一部分可以节省时间,非常适合只关注数据中某个特定部分(如文件文件)的情况</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.3 对象URL</h3>\n<p><strong>对象URL也被称为blob URL,指的是引用保存在File或Blob中数据的URL,使用对象URL的好处是没必要把内容读取到JS中,而直接使用文件内容,能生成一个链接,例如<code>img.src = URL</code></strong></p>\n<p><strong>创建对象URL</strong></p>\n<p>用<code>window.URL.createObjectURL( blob )</code>方法,并传入flle或Blob对象,对二进制数据生成一个 临时的URL,这个URL 可以放置于任何通常可以放置 URL 的地方,<strong>比如img标签的src属性</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>删除对象URL</strong></p>\n<p>出于一些特殊的需要,也可以使URL失效,调用<code>window.URL.revokeObjectURL(url)</code> 方法,使 URL失效</p>\n<h3> 2.4 案例-使用Bolb和对象URL下载文件</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.5 加密</h3>\n<h4> 2.5.1 encodeURI和decodeURI</h4>\n<ul>\n<li>\n<p>encodeURI()用做将字符串转变为URL格式的编码</p>\n</li>\n<li>\n<p>decodeURI()用做将URL格式变化转变为普通的字符串</p>\n</li>\n</ul>\n<h4> 2.5.2 btoa和atob</h4>\n<ul>\n<li>\n<p>btoa()用做将传入的字符串进行加密\n**注意:**被转化为base64位的编码格式,不能对普通的中文编码进行加密,最好先转换为encodeURI编码</p>\n</li>\n<li>\n<p>atob()用做将btoa()加密的字符串解密</p>\n</li>\n</ul>\n<h2> 3.attribute和property</h2>\n<ul>\n<li>\n<p><strong>HTML标签的预定义和自定义属性统称为attribute</strong></p>\n</li>\n<li>\n<p><strong>JS原生对象的直接属性统称property</strong></p>\n</li>\n</ul>\n<h3> 3.1 布尔值属性与非布尔值属性</h3>\n<p><strong>property的属性值为布尔类型的统称为布尔值属性,属性值为非布尔值类型的统称为非布尔值属性</strong></p>\n<p><strong>attribute与property的同步关系</strong></p>\n<ul>\n<li>\n<p>**非布尔值属性:**实时同步</p>\n</li>\n<li>\n<p><strong>布尔值属性:</strong></p>\n</li>\n<li>\n<ul>\n<li>property永远不会同步attribute</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>在没有动过property的情况下,attribute会同步property,在动过property的情况下,attribute不会同步property</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意:</strong></p>\n<ul>\n<li>\n<p>用户操作的是property</p>\n</li>\n<li>\n<p>浏览器认的是property</p>\n</li>\n</ul>\n<h2> 4.Canvas</h2>\n<h3> 4.1 什么是Canvas?</h3>\n<p><strong><code>canvas</code>是HTML5新增元素,可用于通过使用JS绘制图形,可以使用<code>canvas</code>标签定义一个<code>canvas</code>元素</strong></p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>\n<p>使用<code>canvas</code>标签时建议成对出现,不要使用闭合形式</p>\n</li>\n<li>\n<p><code>canvas</code>元素具有默认宽高,<code>width:300px;height:150px</code></p>\n</li>\n</ul>\n<p><strong>替换内容</strong></p>\n<p>有些浏览器不支持使用<code>canvas</code>,可以在<code>canvas</code>标签中提供需要替换的内容,支持<code>canvas</code>的浏览器会正常显示<code>canvas</code>,不会显示其中的内容,而不支持<code>canvas</code>的浏览器会显示替代内容</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 4.2 画布API</h3>\n<ul>\n<li>\n<p><code>canvas</code>标签只有width和height两个属性,并且这两个属性都是可选的,如果没有设置height和width,<code>canvas</code>会初始化宽度为300px和高度150px</p>\n</li>\n<li>\n<p><code>canvas</code>标签有一个方法**getContext()**用于获取上下文</p>\n</li>\n</ul>\n<p><strong>画布中的width与height</strong></p>\n<ul>\n<li>\n<p>HTML属性中设置的高宽只会影响画布本身的宽高而不会影响其中内容的宽高</p>\n</li>\n<li>\n<p>CSS属性中设置的高宽不但会影响画布本身的高宽,还会使得画布中的内容等比例缩放(缩放参照于画布默认的尺寸)</p>\n</li>\n</ul>\n<h3> 4.3 绘制矩形</h3>\n<p><strong><code>canvas</code>提供了三种方法绘制矩形</strong></p>\n<ul>\n<li>\n<p><strong>fillRect(x,y,width,height)</strong>,绘制一个填充的矩形(填充色默认为黑色)</p>\n</li>\n<li>\n<p><strong>strokeRect(x,y,width,height)</strong>,绘制一个矩形的边框(默认的边框颜色为1px实心黑色)</p>\n</li>\n<li>\n<p><strong>clearRect(x,y,width,height)</strong>,清除指定的矩形区域,让清除部分完全透明</p>\n</li>\n</ul>\n<p><strong>注:</strong></p>\n<ul>\n<li>\n<p>x与y指定了在<code>canvas</code>画布上所绘制的矩形的左上角(相对于原点)的坐标,width与height设置矩形的尺寸,如果存在边框,边框会在width与height上占据一个边框的宽度</p>\n</li>\n<li>\n<p>里面所有的参数都不带任何单位</p>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>使用strokeRect时边框出现的像素渲染问题</strong></p>\n<p><strong>按理说如果是使用的默认的边框边框的宽度应该是1px,但是<code>canvas</code>在渲染边框时,边框的宽度是平均在偏移位置的两侧进行渲染的</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 4.3.1 添加样式颜色</h4>\n<ul>\n<li>\n<p><strong>fillStyle</strong>,设置矩形的填充颜色</p>\n</li>\n<li>\n<p><strong>strokeStyle</strong>,设置图形轮廓的颜色,默认情况下填充的颜色都是黑色</p>\n</li>\n<li>\n<p><strong>lineWidth</strong>,设置当前绘制线条的颜色,值必须为正数,默认是1,如果值是0,负数,infinity和NaN时会被忽略</p>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>注意:</strong></p>\n<ul>\n<li>\n<p><code>canvas</code>内部的样式是同步布置的,所以绘制的调用先后会对最后的结果产生很大的影响,如果想最开始就有样式的话就需要先在前面定义了样式后再进行绘制,同时后面绘制的图形的层级比前面的高,所以会覆盖住前面的图形</p>\n</li>\n<li>\n<p>填充图形的样式不会作用给线条图形,线条图形也不会影响到填充图形,并且l<strong>ineWidth</strong>属性也只会作用给线条图形</p>\n</li>\n</ul>\n<h4> 4.3.2 设置线条接合样式</h4>\n<p><strong>lineJoin能设置线条与线条之间接合处的样式</strong>,默认是<code>miter</code>直角</p>\n<p><strong>值:</strong></p>\n<ul>\n<li>\n<p>round:圆角</p>\n</li>\n<li>\n<p>bevel:斜角</p>\n</li>\n<li>\n<p>miter:直角</p>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 4.4 绘制路径</h3>\n<p>图形的基本元素是路径,路径是通过不同颜色和宽度的线段或曲线相连而成的不同形状的集合</p>\n<p><strong>绘制路径的步骤</strong></p>\n<ul>\n<li>\n<p>先创建路径起始点</p>\n</li>\n<li>\n<p>再使用画图命令绘画路径</p>\n</li>\n<li>\n<p>把路径封闭</p>\n</li>\n<li>\n<p>一旦路径生成,就能通过描边或填充路径区域来渲染图形</p>\n</li>\n</ul>\n<h4> 4.4.1 路径方法</h4>\n<ul>\n<li>\n<p><strong>beginPath()</strong>,新建一条路径,生成之后图形绘制命令被指向到路径上准备生成路径,生成路径的第一步就是先使用<strong>beginPath()</strong>。本质上,路径是由很多子路径构成,这些子路径都是在一个列表里,所有的子路径(线、弧形等)构成图形。而每次调用该方法后列表都会被清空重置,我们就可以重新绘制新的图形</p>\n</li>\n<li>\n<p><strong>moveTo(x,y)</strong>,将触笔移动到指定的坐标x以及y上,当<code>canvas</code>初始化或者**beginPath()<strong>调用后,通常会使用</strong>moveTo()**设置起点</p>\n</li>\n<li>\n<p><strong>lineTo(x,y)</strong>,绘制一条从当前位置到指定x以及y位置的直线</p>\n</li>\n<li>\n<p><strong>closePath()</strong>,闭合路径之后图形绘制命令又重新指向到上下文,该方法并不是必须要调用,该方法会通过绘制一条从当前点到开始点的直线来闭合图形,如果图形已经闭合了,该方法不会有任何作用\n**注:<strong>当调用</strong>fill()<strong>函数后所有没有闭合的形状都会自动闭合,不需要该函数,而如果调用</strong>stroke()**函数就不会自动闭合路径</p>\n</li>\n<li>\n<p><strong>stroke()</strong>,通过线条来绘制图形轮廓,该函数不会自动调用<strong>closePath()</strong></p>\n</li>\n<li>\n<p><strong>fill()</strong>,通过填充路径的内容区域生成实心的图形,该函数会自动调用<strong>closePath()</strong></p>\n</li>\n<li>\n<p><strong>rect(x,y,width,height)</strong>,绘制一个左上角(x,y),宽高为width和height的矩形,当该方法执行的时候,**moveTo()**会自动设置坐标参数为(0,0),也就是说当前笔触会自动充值坐标</p>\n</li>\n<li>\n<p><strong>lineCap</strong>,lineCap是<strong>Canvas 2D API</strong>指定如何绘制每一条线代末端的属性,该属性默认值是butt,线段末端以方形结束\n<strong>值:</strong></p>\n</li>\n<li>\n<ul>\n<li>butt:线段末端以方形结束</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>round:线段末端以圆形结束</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>square:线段末端以方形结束,但是增加了一个宽度和线段相同,高度是线段厚度一半的矩形区域</li>\n</ul>\n</li>\n<li>\n<p><strong>save()</strong>,save()是<strong>Canvas 2D API</strong>通过将当前样式状态放入样式栈中,保存<code>canvas</code>全部状态的方法\n保存到样式栈中额绘制状态由下面几个部分组成:</p>\n</li>\n<li>\n<ul>\n<li>当前的变换矩阵</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>当前的剪切区域</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>当前的虚线列表</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>strokeStyle,fillStyle,lineWidth,lineCap,lineJoin等当前的值</li>\n</ul>\n</li>\n<li>\n<p><strong>restore()</strong>,restore()是<strong>Canvas 2D API</strong>通过在绘图状态栈中弹出顶端的状态,可以将<code>canvas</code>恢复到最近的保存状态的中,如果没有保存该方法不做任何改变</p>\n</li>\n</ul>\n<p><strong>注意:</strong></p>\n<ul>\n<li>\n<p><strong>save()和restore()方法需要成对出现使用</strong></p>\n</li>\n<li>\n<p><strong>save()和restore()是控制样式的设置,而beiginPath()是关于路径的设置</strong></p>\n</li>\n</ul>\n<h4> 4.4.2 路径容器与样式容器</h4>\n<ul>\n<li>\n<p>**路径容器:**每次调用关于路径的API时,都会往路径容器中添加路径做登记,调用beginPath()时,情况整个路径容器</p>\n</li>\n<li>\n<p>**样式容器:**每次调用样式API时,都会往样式容器里做登记,调用save()的时候,将样式容器里的状态记入样式栈,调用restore()的时候,将样式栈的栈顶状态弹出到样式容器里进行覆盖</p>\n</li>\n<li>\n<p>**样式栈:**调用save()的时候,将样式容器里的状态记入样式栈,调用restore()的时候,将样式栈的栈顶状态弹出到样式容器里进行覆盖</p>\n</li>\n</ul>\n<h4> 4.4.3 绘制圆形</h4>\n<p><strong>角度与弧度的转化表达式:<code>radians=(Math.PI/180)\\*degrees</code></strong></p>\n<ul>\n<li>\n<p><strong>arc(x,y,radius,startAngle,endAngle,anticlokwise)</strong>,该方法用于画一个以(x,y)为圆心的以radius为半径的圆弧(圆),从startAngle开始到endAngle结束,按照anticlockwise给定的方向(该值为一个布尔值,默认为false顺时针方向)来生成</p>\n</li>\n<li>\n<ul>\n<li>x,y为绘制圆弧所在圆上的圆心坐标,相对于原点</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>radius为半径</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>startAngle和endAngle参数用<strong>弧度</strong>定义了开始以及结束位置的弧度,都是以x轴为基准参数</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>anticlockwise为一个布尔值,当值为true时代表逆时针方向,为false时代表顺时针方向</li>\n</ul>\n</li>\n<li>\n<p><strong>arcTo(x1,y1,x2,y2,radius)</strong>,根据给定的控制点和半径画一段圆弧\n<strong>注意:<strong>使用该方法其实需要三个控制点,<strong>第一个控制点是第一次使用moveTo()时给定的地方,<strong>从哪个地方其向(x1,y1)方向进行画圆弧,也就是说</strong>该圆弧必定经过moveTo()设定的第一个点和(x2,y2),但不一定经过(x1,y1),这个坐标只是为了控制圆弧的方向</strong>,而</strong>圆弧的半径设置就是用一个半径为radius的圆往两个控制点夹角进行移动,直到刚好能够卡住两条夹线</strong></p>\n</li>\n<li>\n<p><strong>quadraticCurveTo(cp1x,cp1y,x,y)</strong>,该方法用于绘制二次贝塞尔曲线,<strong>(cp1x,cp1y)为一个控制点,(x,y)为结束点,起始点为moveTo()刚抬起指定的点</strong></p>\n</li>\n<li>\n<p><strong>bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)</strong>,该方法用于绘制三次贝塞尔曲线,<strong>(cp1x,cp1y)为一个控制点,(cp2x,cp2y)为第二个控制点,(x,y)为结束点,起始点为moveTo()刚抬起指定的点</strong></p>\n</li>\n</ul>\n<h3> 4.5 变换</h3>\n<ul>\n<li>\n<p><strong>translate(x,y)</strong>,该方法用于移动<code>canvas</code>的坐标原点(默认是左上角),该方法接收两个参数,<strong>x为水平偏移量,y为垂直偏移量</strong>\n**注意:**在<code>canvas</code>中translate()方法造成的结果是累加的</p>\n</li>\n<li>\n<p><strong>rotate(angle)</strong>,该方法只接收一个参数旋转的角度(angle),<strong>该旋转方向为顺时针方向</strong>,以<strong>弧度</strong>为单位的值,用于旋转整个<code>canvas</code>画布\n**注意:**旋转的中心点始终为<code>canvas</code>的原点,也就是说内部的所有图形都是围绕原点转圈,如果要改变它需要使用translate()方法,并且在<code>canvas</code>中translate()方法也是累加的</p>\n</li>\n<li>\n<p><strong>scale(x,y)</strong>,该方法接收两个参数,x和y分别代表横轴和纵轴的缩放因子,这两个值都必须为正值,当值小于1.0代表缩小,大于1.0代表放大\n**注意:**scale()方法中的缩小和放大是相对于整个<code>canvas</code>画布的像素数目,放大总个数会减少,单个像素的实际物理尺寸变大,而缩小总个数会增多,单个像素的实际物理尺寸减小,对图像、位图进行缩小或放大,并且在<code>canvas</code>中scale()方法是累乘的</p>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 4.6 图片操作</h3>\n<h4> 4.6.1 插入图片</h4>\n<p>**drawImage(image,x,y,width,height)**方法用于在<code>canvas</code>中插入图片</p>\n<p><strong>参数:</strong></p>\n<ul>\n<li>\n<p>image为<code>image</code>对象或者<code>canvas</code>对象</p>\n</li>\n<li>\n<p>x,y是插入的图片在目标<code>canvas</code>里的起始坐标</p>\n</li>\n<li>\n<p>width和height是用来控制插入的图片在<code>canvas</code>中应该显示的大小</p>\n</li>\n</ul>\n<p><strong>注意:<strong>在<code>canvas</code>中插入图片需要使用</strong>image对象</strong>,并且必须要等图片加载完成后才能进行操作,所以需要在<strong>image对象</strong>执行onload事件后再执行<code>canvas</code>插入图片的函数</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 4.6.2 设置背景</h4>\n<p>**createPattern(image,repetition)**方法用于在<code>canvas</code>中设置背景</p>\n<p><strong>参数:</strong></p>\n<ul>\n<li>\n<p>image为<code>image</code>对象等图像源</p>\n</li>\n<li>\n<p>repetition为背景在<code>canvas</code>中平铺方式,值为\"repeat\",\"repeat-x\",\"repeat-y\"和\"no-repeat\"</p>\n</li>\n</ul>\n<p>**注意:**该方法会返回一个对象,一般情况下我们都会将该方法返回的对象作为fillStyle的值进行填充</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 4.7 设置渐变</h3>\n<ul>\n<li>\n<p><strong>线性渐变</strong></p>\n</li>\n<li>\n<ul>\n<li>**createLinearGradient(x1,y1,x2,y2)**方法设置线性渐变的终点与起点,(x1,y1)表示起点,(x2,y2)表示终点\n**注意:**该方法会返回一个对象gradient,通过该对象能对线性渐变的颜色等进行具体的设置,同时该对象一般赋值给fillStyle属性</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>gradient.addColorStop(position,color)</strong>\n<strong>参数:</strong></li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**positon,**该参数的值为一个0.0到1.0之间的数值,表示渐变中颜色所在的相对位置,表示从哪个比例开始进行颜色的渐变</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li><strong>color</strong>,该参数必须是一个有效的CSS颜色值,如十六进制数或rgb等</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>**注意:**该方法该可以调用多次,加入的颜色会存入栈中,根据所在位置的不同在调用时会显示不用的渐变颜色</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><ul>\n<li>\n<p><strong>径向渐变</strong></p>\n</li>\n<li>\n<ul>\n<li>**createRadialGradient(x1,y1,r2,x2,y2,r2)**方式设置径向渐变的终点圆和起点圆,<strong>前三个参数表示以(x1,y1)为圆点,r1为半径的圆。后三个参数表示以(x2,y2)为圆点,r2为半径的圆</strong></li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>gradient.addColorStop(position,color)</strong>\n<strong>参数:</strong></li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**positon,**该参数的值为一个0.0到1.0之间的数值,表示渐变中颜色所在的相对位置,表示从哪个比例开始进行颜色的渐变</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li><strong>color</strong>,该参数必须是一个有效的CSS颜色值,如十六进制数或rgb等</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>**注意:**该方法该可以调用多次,加入的颜色会存入栈中,根据所在位置的不同在调用时会显示不用的渐变颜色</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 4.8 绘制文本</h3>\n<p><strong>在<code>canvas</code>中可以使用两种方法来绘制文本</strong></p>\n<ul>\n<li>\n<p><strong>fillText(text,x,y)</strong>,text为要写入的文本,(x,y)位置表示填充指定的文本</p>\n</li>\n<li>\n<p><strong>strokeText(text,x,y)</strong>,text为要写入的文本,(x,y)位置表示填充指定的文本</p>\n</li>\n</ul>\n<h4> 4.8.1 文本样式</h4>\n<ul>\n<li>\n<p>font = \"font-size font-family\"</p>\n<p>,当前我们用来绘制文本的样式,该属性和CSS中的font属性的语法相同,默认的字体为</p>\n<div class=\"language-css\" data-ext=\"css\"></div><p>注意:</p>\n<p>当要使用font属性时,必须要大小和字体同时存在,缺一不可</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div></li>\n<li>\n<p><strong>textAlign=\"value\"</strong>,文本对齐属性,可选的值为<strong>right,left,center,start,end</strong>,其中<strong>start和end分别对应left和right</strong>,默认值是<strong>left</strong>\n**注意:**这里的文本对齐和CSS中的文本对齐不一样,这里的left和right都是相对于fillText()和strokeText()指定的位置时的偏差,默认是最坐标的文字靠近指定点的x,而center与right这些指定就是将写在一起的文字的中部和最右边靠近指定点</p>\n</li>\n<li>\n<p><strong>textBaseline=\"value\"</strong>,该属性用于描述文本时文本基线的属性\n<strong>值:</strong></p>\n</li>\n<li>\n<ul>\n<li><strong>alphabetic</strong>,默认值,文本基线是普通的字母基线</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>top</strong>文本基线是 em 方框的顶端,em方框是包裹整个默认文字基线的方框</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>hanging</strong>,文本基线是悬挂基线</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>middle</strong>,文本基线是 em 方框的正中</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>ideographic</strong>,文本基线是表意基线</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>bottom</strong>,文本基线是 em 方框的底端</li>\n</ul>\n</li>\n<li>\n<p><strong>measureText(text)</strong>,该方法返回一个TextMetrics对象,包含了关于文本尺寸的信息(例如文本的宽度),参数是需要测试文本信息的字符串</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 4.8.2 文本水平垂直居中</h4>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h4> 4.8.3 文本阴影</h4>\n<ul>\n<li>\n<p><strong>shadowOffsetX=\"value\"</strong>,该属性用来设置阴影在X轴的延伸距离,默认是0</p>\n</li>\n<li>\n<p><strong>shadowOffsetY=\"value\"</strong>,该属性用来设置阴影在Y轴的延伸距离,默认是0</p>\n</li>\n<li>\n<p><strong>shadowBlur=\"value\"</strong>,该属性用于设置阴影的模糊度,其数值并不跟像素挂钩,也不受变换矩阵的影响,默认为0</p>\n</li>\n<li>\n<p><strong>shadowColor=\"color\"</strong>,用于设置阴影颜色,该颜色的值为标准的CSS颜色值\n<strong>默认是全透明的黑色:<code>rgba(0,0,0,0)</code></strong></p>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>**注意:**因为默认的颜色是透明的黑色,所以如果想要有阴影必须要设置阴影的颜色</p>\n<h3> 4.9 像素操作</h3>\n<p><strong>在<code>canvas</code>中,我们可以直接通过ImageData对象操纵像素数据,直接读取或将数据数组写入该对象中</strong></p>\n<ul>\n<li>\n<p><strong>getImageData(sx,sy,sw,sh)</strong>,该方法用做获取一个ImageData对象,代表了画布区域的对象数据\n<strong>参数:</strong></p>\n</li>\n<li>\n<ul>\n<li>**sw:**将要被提取的图像数据矩阵区域的左上角x坐标</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**sy:**将要被提取的图像数据矩阵区域的左上角y坐标</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>sw</strong>:将要被提取的图像数据矩形区域的宽度</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**sh:**将要被提取的图像数据矩形区域的高度</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><ul>\n<li>\n<p><strong>ImageData对象</strong>,该对象中存储着<code>canvas</code>对象真实的像素数据,包含以下几个属性:</p>\n</li>\n<li>\n<ul>\n<li>**width:**图片宽度,单位为px</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**height:**图片高度,单位为px</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**data:**Uint8ClampeArray类型的一维数组,包含着rgba格式的整形数据,范围在0到255之间(包括255)\n**注:**该属性保存了每一个像素所占的rgba值,数组中的每四个数据就是一个像素的完整rgba值,并且值都是0到255,由黑色到白色,<strong>注意这里的a(透明度)的值也是0到255,和CSS中的透明度的算法不同</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>putImageData(ImageData,dx,dy)</strong>,该方法用于对场景进行像素数据的写入\n<strong>参数:</strong></p>\n</li>\n<li>\n<ul>\n<li>**ImageData:**为一个ImageData对象,该对象就是要写入的像素数据</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**dx:**要绘制图形的x坐标</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**dy:**要绘制图形的y坐标</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><ul>\n<li>\n<p><strong>createImageData(width,height)</strong>,该方法用于直接创建一个ImageData对象\n<strong>参数:</strong></p>\n</li>\n<li>\n<ul>\n<li>**width:**新对象的宽度</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**height:**新对象的高度</li>\n</ul>\n</li>\n</ul>\n<p>**注意:**默认情况下创建出来的ImageData对象是完全透明的,<strong>颜色为rgba(0,0,0,0)</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>获取单像素颜色</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-javascript\" data-ext=\"js\"></div><p><strong>设置单像素颜色</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-javascript\" data-ext=\"js\"></div><h3> 4.10 合成</h3>\n<h4> 4.10.1 全局透明度</h4>\n<p><strong>globalAlpha=\"value\"</strong>,该属性设置或返回绘图的当前<code>alpha</code>或透明值,这个属性影响到<code>canvas</code>里所有图形的透明度,<strong>有效的值范围是0.0(完全透明)到1.0(完全不透明)</strong>,默认值为1.0</p>\n<h4> 4.10.2 覆盖合成</h4>\n<p><strong>globalCompositeOperation=\"value\"</strong>,设置或返回新图像如何绘制到已有的图像上</p>\n<p><strong>可用的值:</strong></p>\n<ul>\n<li>\n<p><strong>source-over</strong>,<strong>在目标图像上显示源图像</strong>,新的图像层级比较高,该值为默认值</p>\n</li>\n<li>\n<p><strong>source-atop</strong>,在目标图像顶部显示源图像,源图像位于目标图像之外的部分是不可见的,也就是<strong>砍掉溢出的源图像部分</strong></p>\n</li>\n<li>\n<p><strong>source-in</strong>,在目标图像中显示源图像,只有目标图像内的源图像部分会显示,目标图像是透明的,也就是<strong>只留下源图像与目标图像重复的部分(源图像的那部分)</strong></p>\n</li>\n<li>\n<p><strong>source-out</strong>,在目标图像之外显示源图像。只会显示目标图像之外源图像部分,目标图像是透明的。也就是<strong>只留下源图像超出目标的部分</strong></p>\n</li>\n<li>\n<p><strong>destination-over</strong>,在源图像上方显示目标图像,目标图像的层级较高</p>\n</li>\n<li>\n<p><strong>destination-atop</strong>,在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。也就是<strong>砍掉溢出的目标图像部分</strong></p>\n</li>\n<li>\n<p><strong>destination-in</strong>,在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。也就是<strong>只留下源图像与目标图像重复的部分(目标图像的那部分)</strong></p>\n</li>\n<li>\n<p><strong>destination-out</strong>,在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。也就是<strong>只留下超出源图像的部分</strong></p>\n</li>\n<li>\n<p><strong>lighter</strong>,显示源图像和目标图像</p>\n</li>\n<li>\n<p><strong>copy</strong> ,显示源图像。忽略目标图像</p>\n</li>\n<li>\n<p><strong>xor</strong>,使用异或操作对源图像与目标图像进行组合</p>\n</li>\n</ul>\n<p><strong>注意:</strong></p>\n<ul>\n<li>\n<p>**source:**新的图像(源)</p>\n</li>\n<li>\n<p>**destination:**已经绘制过的图像(目标)</p>\n</li>\n<li>\n<p><strong>globalCompositeOperation属性应该在第一个图像绘制后第二个图像回之前使用</strong></p>\n</li>\n</ul>\n<h3> 4.11 导出与事件操作</h3>\n<ul>\n<li>\n<p><strong>将画布导出为图片</strong>\n火狐、谷歌浏览器右键菜单可直接导出为图片,但是如果为手机端可以使用内置的API方法导出</p>\n</li>\n<li>\n<ul>\n<li><strong>canvas.toBlob()</strong>,把canvas图片数据转换成 blob对象</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**canvas.toDataURL(),**默认导出data:png,为base64编码的二进制URL</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**canvas.toDataURL('image/jpeg'),**导出data:jpg,为base64编码的二进制URL</li>\n</ul>\n</li>\n</ul>\n<p>**注意:**这些API由画布本身调用</p>\n<ul>\n<li>\n<p>事件操作</p>\n<p>ctx.isPointInPath(x,y)</p>\n<p>,判断在当前路径是否包含有检测点,就是通过检测clientX和clientY来进行判断是否触发到了画布上的路径,x代表检测点的x坐标,y代表检测点的y坐标,两者都是相对于画布本身来说的</p>\n<p>注意:</p>\n<p>此方法只作用于最新画出的</p>\n<div class=\"language-text\" data-ext=\"text\"></div><p>路径图像</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<h2> 5.SVG</h2>\n<h3> 5.1 SVG与Canvas的区别</h3>\n<ul>\n<li>\n<p><strong>SVG</strong>\nSVG 是一种使用 XML 描述 2D 图形的语言,基于XML,这意味着SVG内部的DOM中的每个元素都是可用的,可以为某个元素附加 JavaScript 事件处理器,在SVG中,每个被绘制的图形均被视为对象。<strong>如果 SVG 对象的属性发生变化,浏览器能够自动重现该图形</strong>\n<strong>svg的特征</strong></p>\n</li>\n<li>\n<ul>\n<li>不依赖分辨率</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>支持事件处理器</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>最适合带有大型渲染区域的应用程序(比如谷歌地图)</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>复杂度高会减慢渲染速度（任何过度使用DOM的应用都不快）</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>不适合游戏应用</li>\n</ul>\n</li>\n<li>\n<p><strong>Canvas</strong>\nCanvas通过 JavaScript 来绘制 2D 图形,C<strong>anvas是逐像素进行渲染的</strong>,在canvas 中,一旦图形被绘制完成,它就不会继续得到浏览器的关注。<strong>如果其位置发生变化,那么整个场景也需要重新绘制,包括任何或许已被图形覆盖的对象</strong>\n<strong>canvas的特征</strong></p>\n</li>\n<li>\n<ul>\n<li>依赖分辨率</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>不支持事件处理器</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>弱的文本渲染能力</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>能够以 .png 或 .jpg 格式保存结果图像</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>\n</ul>\n</li>\n</ul>\n<h3> 5.2 引入SVG</h3>\n<p><strong>svg是基于xml技术实现的,使用svg可以通过三种方式:</strong></p>\n<p>**其中:**xmlns后面的字符串为命名空间,用来区分不同的代码功能</p>\n<ul>\n<li>\n<p>svg文件</p>\n<div class=\"language-html\" data-ext=\"html\"></div></li>\n<li>\n<p>通过图片、背景、框架进行引入svg文件</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>直接在html页面中引入svg</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<h3> 5.3 基本图形</h3>\n<p><strong>所有的svg标签(图层)会有层级关系,后续的标签如果与前面的标签重合就会覆盖点前面的标签</strong></p>\n<h4> 5.3.1 圆</h4>\n<p><strong>svg中的圆通过circle标签进行绘制</strong></p>\n<ul>\n<li>\n<p>**圆心坐标(cx,cy)😗*写在标签上代表圆心离<code>&lt;svg&gt;&lt;/svg&gt;标签</code>左上角的距离坐标,单位为像素(不必填写)</p>\n</li>\n<li>\n<p>**圆心半径(r)😗*写在标签上代表从(cx,cy)坐标开始向四周扩展的圆的半径</p>\n</li>\n<li>\n<p>**fill:**通过填充方式画圆,填充的样式为圆的颜色,默认的填充颜色为黑色,不论是否填写了fill属性</p>\n</li>\n<li>\n<p>**stroke:**通过画线的方式画圆,画线方式为圆的边框颜色</p>\n</li>\n<li>\n<p>**stroke-width:**设置画线方式的线条宽度,单位为像素(不必填写)</p>\n</li>\n<li>\n<p>stroke-dasharray:</p>\n<p>将实线改为虚线形式绘画,可以提供短划线与缺口之间的长度,通过设置该属性手动设置长度如果提供了奇数个值,则这个值的数列重复一次,从而变成偶数个值</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>**stroke-opacity:**设置线条的透明度</p>\n</li>\n<li>\n<p>**fill-opacity:**设置填充样式的透明度</p>\n</li>\n</ul>\n<p>**注:**如果只想要通过画线的方式画圆,需要将fill设置为transparent(透明)或者是none(没有填充色)</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>通过style属性设置</strong></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.3.2 椭圆</h4>\n<p><strong>svg中椭圆通过ellipse标签进行绘制</strong></p>\n<ul>\n<li>\n<p><strong>椭圆中心坐标(cx,cy)</strong></p>\n</li>\n<li>\n<p>**rx:**定义椭圆的水平半径</p>\n</li>\n<li>\n<p>**ry:**定义椭圆的垂直半径</p>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.3.3 矩形</h4>\n<p><strong>svg中的矩形通过rect标签进行绘制</strong></p>\n<ul>\n<li>\n<p>**width:**矩形的宽</p>\n</li>\n<li>\n<p>**height:**矩形的高</p>\n</li>\n<li>\n<p>**(x,y)😗*矩形相对于<code>&lt;svg&gt;&lt;/svg&gt;标签</code>的坐标</p>\n</li>\n<li>\n<p>**(rx,ry)😗*设置矩形圆角,rx和ry分别为在四个角画离x和y相应距离的圆或椭圆,然后截取矩形超出的角。默认为0,如果只写rx或者只写ry那么另一个也会默认也为那个值,会用一个圆去进行切割矩形</p>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.3.4 线条</h4>\n<p><strong>svg中的线条通过line标签进行绘制</strong></p>\n<ul>\n<li>\n<p>**(x1,y1)😗*设置线条的起点</p>\n</li>\n<li>\n<p>**(x2,y2)😗*设置线条的终点</p>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.3.5 折线</h4>\n<p><strong>svg中的折线用polyline标签进行绘制</strong></p>\n<ul>\n<li>**points:**设置折线个各个点坐标,通过<code>points=\"x1 y1 x2 y2 ...\"</code>或<code>points=\"x1,y1,x2,y2....\"</code>进行设置\n**注:**这两种方式也可以混合使用</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.3.6 多边形</h4>\n<p><strong>svg中的折线用polygon标签进行绘制</strong></p>\n<ul>\n<li>**points:**设置折线个各个点坐标,通过<code>points=\"x1 y1 x2 y2 ...\"</code>或<code>points=\"x1,y1,x2,y2....\"</code>进行设置\n**注:**这两种方式也可以混合使用</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.3.7 路径</h4>\n<p><strong>svg中可以用path标签进行对一整个路径进行绘制</strong></p>\n<ul>\n<li>\n<p>**d:**该属性用与设置路径,需要与路径命令进行配合,命令的语法<code>d=\"M0 0L100 100\"</code>,命令后紧跟着路径坐标,路径坐标的x和y坐标用空格隔开\n<strong>路径命令:</strong></p>\n</li>\n<li>\n<ul>\n<li>**M命令:**设置路径的起始坐标</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**L命令:**设置路径的结束坐标</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**Z命令:**闭合路径,该命令放在前一个坐标的最后,用作闭合前面的路径</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**H命令:**绘制水平线,后面只跟着一个x坐标,对应的点会与上一个点的y坐标相同,该坐标的x也是代表着离<code>&lt;svg&gt;&lt;/svg&gt;标签</code>左上角的距离</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**V命令:**绘制垂直线,后面只跟着一个y坐标,对应的点会与上一个点的x坐标相同,该坐标的y也是代表着离<code>&lt;svg&gt;&lt;/svg&gt;标签</code>左上角的距离</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**C,S,Q,T命令:**绘制贝塞尔曲线</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**C命令:**绘制三次贝塞尔曲线(x1,y1,x2,y2,x,y)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li>控制点一(x1,y)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li>控制点二 (x2,y2)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li>结束点(x,y)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**S命令:**绘制平滑贝塞尔曲线(自动对称一个控制点)(x1,y1,x,y)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li>控制点(x1,,y1)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li>结束点(x,y)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**Q命令:**绘制二次贝塞尔曲线(x1,y1,x,y)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li>控制点(x1,y1)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li>结束点(x,y)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**T命令:**绘制一次贝塞尔曲线(x,y)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li>结束点(x,y)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>注:<strong>这些命令有大小写两种方式.<strong>大写为绝对坐标(具体的坐标位置)</strong>,小</strong>写为相对坐标(相对于上一个坐标点的具体长度)</strong></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<ul>\n<li>**A命令:**通过<code>d=\"Mx1 y1Arx ry x-axis-rotation large-arc-flag sweep-flag x2 y2\"</code>,表示绘制一个椭圆圆弧经过(x1,y1),(x2,y2)点\n**注:**A命令需要与M命名等一起配合使用确定圆弧的起始点\n<strong>A命令标识:</strong></li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**rx:**椭圆横轴半径</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**ry:**椭圆竖轴半径</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**x-axis-rotation:**椭圆横轴相对于CanvasX轴的偏移角度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li><strong>large-arc-flag:<strong>在前面三个参数确定的情况下,满足当前点(x1,y1)到指定点(x2,y2)位置条件的圆弧总是有四条,此值</strong>取0表示绘制小弧度,取值1表示绘制大弧度</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li><strong>sweep-flag:<strong>在前三个参数确定的情况下,满足当前点(x1,y1)到指定点(x2,y2)位置条件的圆弧总是有四条,去掉通过上面</strong>large-arc-flag</strong>标识后还有两个,<strong>sweep-flag取值0表示绘制逆时针方向的圆弧,取值1表示绘制顺时针方向的圆弧</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 5.4 其余标签</h3>\n<h4> 5.4.1 g标签</h4>\n<p><strong>g标签是一个容器(分组)标签,专门用来组合元素的,同时可以用来设置元素公共属性</strong>,注意是公共属性**(换句话说就能能写在style中的属性**),不是只有某种图像自身才有的属性,自身才有的属性需要设置给自身的标签</p>\n<p>**注:**可以使用所有元素的共用属性<code>transform=\"translate(0,0)\"</code>用作移动整个组合元素</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.4.2 text标签</h4>\n<p><strong>text标签时svg中专门用来写入文本的标签</strong></p>\n<ul>\n<li>\n<p>**(x,y)😗*文字标签相对于<code>&lt;svg&gt;&lt;/svg&gt;标签</code>的坐标,移动或文字的最左边靠这(x,y)坐标</p>\n</li>\n<li>\n<p>**font-size:**设置文字大小,单位为像素</p>\n</li>\n<li>\n<p>**text-anchor:**设置文本的对齐方式\n<strong>值:</strong></p>\n</li>\n<li>\n<ul>\n<li>**start:**文字开头对齐(x,y)坐标</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**middle:**文字中部对齐(x,y)坐标</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**end:**文字结尾对齐(x,y)坐标</li>\n</ul>\n</li>\n</ul>\n<p>**注意:**文字的颜色不能通过style中的color来设置,svg中的文字默认是fill属性来绘制的,可以通过改变fill属性的颜色来改变文字颜色,同时如果给文字加上stroke属性,会在文字周围再加上围绕的线条</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.4.3 imgae标签</h4>\n<p><strong>image标签用于在svg中添加图片</strong></p>\n<ul>\n<li>\n<p>**width:**图片的宽</p>\n</li>\n<li>\n<p>**height:**图片的高</p>\n</li>\n<li>\n<p>**(x,y)😗*图片相对于<code>&lt;svg&gt;&lt;/svg&gt;标签</code>的坐标</p>\n</li>\n<li>\n<p>**xlink:href:**该属性写入图片的链接</p>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.4.4 defs与symbol标签</h4>\n<p><strong>这两个标签专门用来装需要引入的元素容器,内部的元素使用ID作为唯一标识的url,通过锚点方式引入内部元素url在<code>&lt;defs&gt;&lt;/defs&gt;或&lt;symbol&gt;&lt;/symbol&gt;</code>标签外部显示,通常与use标签等搭配使用</strong></p>\n<p><strong>注:</strong></p>\n<ul>\n<li>\n<p><strong>defs和symbol标签内部的原始元素不会在页面上显示出来,只有通过外部引用才能显示</strong></p>\n</li>\n<li>\n<p>引用的元素有内部可以写对应的样式,在引用时如果引用的标签没有做任何的操作,那么就会使用内部的样式**,如果与引用标签内部规定的样式相冲突,原来样式就会无效**</p>\n</li>\n<li>\n<p>在使用通用样式时(如fill),会有层级的限制,如果直接在内部标签上那个设置fill等样式,外部引用时设置fill将不会起作用,如果设置在内部的g标签中,外部的样式就会起作用</p>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.4.5 filter标签</h4>\n<p><strong>svg滤镜只能定义在<code>&lt;defs&gt;</code>元素中,使用<code>&lt;filter&gt;</code>标签用来定义svg滤镜,<code>&lt;filter&gt;</code>标签使用必需的ID属性来定义向图形应用哪个滤镜</strong></p>\n<p>**注:**其余图形需要使用该滤镜可以通过该属性上内置的filter属性进行设置,设置方式<code>filter=\"url(#引用ID名)\"</code></p>\n<h5> 5.4.5.1 模糊效果</h5>\n<p><strong>通过<code>&lt;feGaussianBlur&gt;</code>元素定义模糊效果</strong></p>\n<ul>\n<li>\n<p>**in=\"SourceGraphic\"😗*定义了由整个图像创建效果为SourceGraphic</p>\n</li>\n<li>\n<p>**stdDeviation:**定义模糊量</p>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 5.4.5.2 阴影</h5>\n<p><strong>通过<code>&lt;feOffset&gt;</code>实现滤镜移动,通过<code>&lt;feGaussianBlur&gt;</code>实现阴影模糊,通过<code>&lt;feColorMatrix&gt;</code>为阴影周围上色</strong></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.4.6 use标签</h4>\n<p><strong>该标签可以通过使用url引用一个<code>&lt;g&gt;或&lt;svg&gt;</code>或其他具有一个唯一的ID属性和重复的图形元素,复制的是原始的元素,因此文件中的原始存在只是一个参考,并且原始影响到所有副本的任何改变</strong></p>\n<ul>\n<li>\n<p>**x:**克隆元素的左上角的x轴</p>\n</li>\n<li>\n<p>**y:**克隆元素的左上角的y轴</p>\n</li>\n<li>\n<p>**width:**克隆元素的宽度</p>\n</li>\n<li>\n<p>**height:**克隆元素的高度</p>\n</li>\n<li>\n<p>**xlink:href:**通过url的方式引用克隆元素,引入方式<code>xlink:href=\"#引用ID名\"</code></p>\n</li>\n</ul>\n<h3> 5.5 渐变</h3>\n<p><strong>SVG渐变主要有两种类型</strong></p>\n<ul>\n<li>\n<p>Linear</p>\n</li>\n<li>\n<p>Radial</p>\n</li>\n</ul>\n<h4> 5.5.1 stop标签</h4>\n<p><strong><code>&lt;stop&gt;</code>标签用来设置渐变停止的位置</strong></p>\n<ul>\n<li>\n<p>**offset:**偏移的停止量,参考值为0%到100%或0.0到1.0</p>\n</li>\n<li>\n<p>**stop-color:**这个stop内的颜色</p>\n</li>\n<li>\n<p>**stop-opacity:**这个stop类的不透明度,参考值为0到1</p>\n</li>\n</ul>\n<h4> 5.5.2 线性渐变</h4>\n<p>**<code>&lt;linearGradient&gt;</code>标签用于定义线性渐变,**线性渐变可以定义为水平,垂直或角渐变</p>\n<ul>\n<li>\n<p>当y1和y2相等,而x1和x2不同时,可创建水平渐变</p>\n</li>\n<li>\n<p>当x1和x2相等,而y1和y2不同时,可创建垂直渐变</p>\n</li>\n<li>\n<p>当x1和x2不同,且y1和y2不同时,可创建角形渐变</p>\n</li>\n</ul>\n<p><strong>注意:<code>&lt;linearGradient&gt;</code>标签必须嵌套在<code>&lt;defs&gt;</code>的内部</strong></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.5.3 放射性渐变</h4>\n<p><strong><code>&lt;radialGradient&gt;</code>元素用于定义放射性渐变</strong></p>\n<p><strong>注意:<code>&lt;radialGradient&gt;</code>标签必须嵌套在<code>&lt;defs&gt;</code>的内部</strong></p>\n<ul>\n<li>\n<p>**渐变中心点(cx,cy)😗*参考值为数字或%,默认是50％</p>\n</li>\n<li>\n<p>**r:**渐变的半径,参考值为数字或%,默认50％</p>\n</li>\n<li>\n<p>**fx:**渐变的焦点,参考值为数字或%,默认0％</p>\n</li>\n<li>\n<p>**fy:**渐变的焦点,参考值为数字或%,默认0％</p>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 5.6 使用JS创建SVG</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>功能函数</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 5.7 SVG动画</h3>\n<h4> 5.6.1 旋转</h4>\n<p><strong>通过<code>transform:rotate(angle x y)</code>属性可以实现svg内置的旋转效果(不要写在style里面)</strong></p>\n<ul>\n<li>\n<p>**angle:**旋转角度</p>\n</li>\n<li>\n<p>**(x,y)😗*旋转中心,这个旋转中心可以是任何位置,一般都是图形的自身旋转中心点</p>\n</li>\n</ul>\n<h4> 5.6.2 animate</h4>\n<p><strong><code>&lt;animate&gt;</code>标签可以用来嵌入到其他标签元素中,使得被嵌入的标签有动画效果</strong></p>\n<ul>\n<li>\n<p>**attributeName:**要变化的元素属性名称</p>\n</li>\n<li>\n<ul>\n<li>可以是元素直接暴露的属性,如x和y等svg图像的专有属性</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>可以是CSS属性,如width,height等</li>\n</ul>\n</li>\n<li>\n<p><strong>from,to,by,values</strong></p>\n</li>\n<li>\n<ul>\n<li>**from:**动画的起始值(如果与元素的默认值一样可省略此值)</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**to:**动画的结束值</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**by:**动画结束值(相对变化的值)</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**values:**用分号分隔的一个或多个值,可以看成是动画的多个关键值点</li>\n</ul>\n</li>\n<li>\n<p>**begin:**动画开始时间,可为具体的时间值,也可以是其他条件触发\noﬀset-value | syncbase-value | event-value | repeat-value | accessKey-value | media-markervalue | wallclock-sync-value | \"indeﬁnite\"</p>\n</li>\n<li>\n<p>**dur:**动画过渡的时间 ,参考值为具体时间或indefinite(无限时间即无具体意义)</p>\n</li>\n<li>\n<p><strong>repeatCount, repeatDur</strong></p>\n</li>\n<li>\n<ul>\n<li>**repeatCount:**表示动画执行次数,可以是合法数值或者”indefinite“</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**repeatDur:**定义重复动画的总时间,可以是普通时间值或者indeﬁnite</li>\n</ul>\n</li>\n</ul>\n<p>**注意:**如果想要动画结束后停留在最后的位置,需要加上<code>fill=\"freeze\"</code>属性</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.6.3 animateTransform</h4>\n<p><strong><code>&lt;animateTransform&gt;</code>标签专门用来对transform属性进行设置动画效果</strong>,通过type属性选择需要变换的类型</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>注:</strong></p>\n<ul>\n<li>\n<p>一个元素类可以写多个动画标签,但是如果相互冲突会执行最下面的动画(指的是都是控制相同的属性),如果是不同的属性会同时执行</p>\n</li>\n<li>\n<p>可以在begin属性中设置一些限制条件来控制动画的运行</p>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 6.Audio与Video</h2>\n<h3> 6.1 容器</h3>\n<p>大多数人认为视频文件就是<code>.avi .mp4</code>等,但事实上这些仅仅只是容器的格式,只决定了怎么将视频存储起来,而不关心储存的内容,类似于压缩文件格式<code>.zip .rar</code>等</p>\n<p><strong>视频与音频容器</strong></p>\n<ul>\n<li>\n<p><strong>视频容器包含了音频轨道、视频轨道、和其他的一些元数据,在视频播放的时候,音频轨道和视频滚到是绑定在一起的,元数据包含了视频的封面、标题、子标题、字幕等相关信息</strong></p>\n</li>\n<li>\n<p><strong>音频容器包含了音频轨道</strong></p>\n</li>\n</ul>\n<p><strong>主流的文件格式</strong></p>\n<ul>\n<li>\n<p><strong>视频</strong></p>\n</li>\n<li>\n<ul>\n<li><strong>MPEG-4</strong>:通常以<code>.mp4</code>为扩展名</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>Flash视频</strong>:通常以<code>.fiv</code>为扩展名</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>Ogg</strong>:通常以<code>.Ogv</code>为扩展名</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>WebM</strong>:通常以<code>.webm</code>为扩展名</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>音视频交错</strong>:通常以<code>.avi</code>为扩展名</li>\n</ul>\n</li>\n<li>\n<p><strong>音频</strong></p>\n</li>\n<li>\n<ul>\n<li><strong>MPEG-3</strong>:通常以<code>.mp3</code>为扩展名</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>Acc音频</strong>:通常以<code>.acc</code>为扩展名</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>Ogg音频</strong>:通常以<code>.Ogg</code>为扩展名</li>\n</ul>\n</li>\n</ul>\n<p>**注:**可以使用转码器进行转码改变文件格式</p>\n<h3> 6.2 兼容</h3>\n<p>通过与<code>&lt;source&gt;&lt;/source&gt;</code>相结合可以实现在不同浏览器下的兼容写法</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 6.3 音视频的attribute</h3>\n<ul>\n<li>\n<p><strong>视频</strong></p>\n</li>\n<li>\n<ul>\n<li>**width:**视频显示区域的宽度,单位是CSS像素</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**height:**视频展示区域的高度,单位是CSS像素</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**poster:**一个海报帧的url,用于在用户播放或者跳帧之前展示</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**src:**要嵌到页面的视频url</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**controls:**显示或隐藏用户控制界面</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**autoplay:**媒体是否循环播放</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**muted:**是否静音</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**preload:**该属性旨在告诉浏览器作者认为达到最佳的用户体验的方式是什么\n<strong>值:</strong></li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**none:**提示作者认为用户不需要查看该视频,服务器也想要最小化访问流量,换句话说就是提示浏览器该视频不需要缓存</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**metadata:**提示尽管作者认为用户不需要查看该视频,但是还是需要提取元数据(如长度等)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li><strong>auto</strong>:用户需要这个视频优先加载,换句话说就是提示如果需要的话可以下载整个视频,即使用户不一定会使用它</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>**注意:**如果值为空的字符串也是代指auto</p>\n<ul>\n<li>\n<p><strong>音频</strong></p>\n</li>\n<li>\n<ul>\n<li>**src:**要嵌到页面的视频url</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**controls:**显示或隐藏用户控制界面</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**autoplay:**媒体是否循环播放</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**muted:**是否静音</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**preload:**该属性旨在告诉浏览器作者认为达到最佳的用户体验的方式是什么\n<strong>值:</strong></li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**none:**提示作者认为用户不需要查看该视频,服务器也想要最小化访问流量,换句话说就是提示浏览器该视频不需要缓存</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**metadata:**提示尽管作者认为用户不需要查看该视频,但是还是需要提取元数据(如长度等)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li><strong>auto</strong>:用户需要这个视频优先加载,换句话说就是提示如果需要的话可以下载整个视频,即使用户不一定会使用它</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>**注意:**如果值为空的字符串也是代指auto</p>\n<h3> 6.4 音视频的property</h3>\n<p><strong>音视频相关的JS属性</strong></p>\n<ul>\n<li>\n<p>**duration:**媒体总时间(只读)</p>\n</li>\n<li>\n<p>**currentTime:**开始播放到现在所用的时间(可读写)</p>\n</li>\n<li>\n<p>**muted:**是否静音(可读写,相比于volume优先级更高)</p>\n</li>\n<li>\n<p><strong>volume:</strong><code>0.0到1.0</code>的音量相对值(可读写)\n**注意:**muted与volume不会同步,所以在写muted为true的时候需要把volume也为设置0,做到两者同步</p>\n</li>\n<li>\n<p>**paused:**媒体是否暂停(只读)</p>\n</li>\n<li>\n<p>**ended:**媒体是否播放完毕(只读)</p>\n</li>\n<li>\n<p>**error:**媒体发生错误的时候</p>\n</li>\n<li>\n<p>**currentSrc:**以字符串形式返回媒体地址(只读)</p>\n</li>\n</ul>\n<p><strong>视频多出的JS属性</strong></p>\n<ul>\n<li>\n<p>**poster:**视频播放前的预览图片(可读写)</p>\n</li>\n<li>\n<p>**width:**设置视频标签的宽</p>\n</li>\n<li>\n<p>**height:**设置视频标签的高</p>\n</li>\n<li>\n<p>**videoWidth:**视频的实际宽(就是只有视频图像的那部分)</p>\n</li>\n<li>\n<p>**videoHeight:**视频的实际高</p>\n</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>更多属性</strong></p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>audioTracks</td>\n<td>返回表示可用音频轨道的 AudioTrackList 对象。</td>\n</tr>\n<tr>\n<td>autoplay</td>\n<td>设置或返回是否在加载完成后随即播放音频/视频。</td>\n</tr>\n<tr>\n<td>buffered</td>\n<td>返回表示音频/视频已缓冲部分的 TimeRanges 对象。</td>\n</tr>\n<tr>\n<td>controller</td>\n<td>返回表示音频/视频当前媒体控制器的 MediaController 对象。</td>\n</tr>\n<tr>\n<td>controls</td>\n<td>设置或返回音频/视频是否显示控件（比如播放/暂停等）。</td>\n</tr>\n<tr>\n<td>crossOrigin</td>\n<td>设置或返回音频/视频的 CORS 设置。</td>\n</tr>\n<tr>\n<td>currentSrc</td>\n<td>返回当前音频/视频的 URL。</td>\n</tr>\n<tr>\n<td>currentTime</td>\n<td>设置或返回音频/视频中的当前播放位置（以秒计）。</td>\n</tr>\n<tr>\n<td>defaultMuted</td>\n<td>设置或返回音频/视频默认是否静音。</td>\n</tr>\n<tr>\n<td>defaultPlaybackRate</td>\n<td>设置或返回音频/视频的默认播放速度。</td>\n</tr>\n<tr>\n<td>duration</td>\n<td>返回当前音频/视频的长度（以秒计）。</td>\n</tr>\n<tr>\n<td>ended</td>\n<td>返回音频/视频的播放是否已结束。</td>\n</tr>\n<tr>\n<td>error</td>\n<td>返回表示音频/视频错误状态的 MediaError 对象。</td>\n</tr>\n<tr>\n<td>loop</td>\n<td>设置或返回音频/视频是否应在结束时重新播放。</td>\n</tr>\n<tr>\n<td>mediaGroup</td>\n<td>设置或返回音频/视频所属的组合（用于连接多个音频/视频元素）。</td>\n</tr>\n<tr>\n<td>muted</td>\n<td>设置或返回音频/视频是否静音。</td>\n</tr>\n<tr>\n<td>networkState</td>\n<td>返回音频/视频的当前网络状态。</td>\n</tr>\n<tr>\n<td>paused</td>\n<td>设置或返回音频/视频是否暂停。</td>\n</tr>\n<tr>\n<td>playbackRate</td>\n<td>设置或返回音频/视频播放的速度。</td>\n</tr>\n<tr>\n<td>played</td>\n<td>返回表示音频/视频已播放部分的 TimeRanges 对象。</td>\n</tr>\n<tr>\n<td>preload</td>\n<td>设置或返回音频/视频是否应该在页面加载后进行加载。</td>\n</tr>\n<tr>\n<td>readyState</td>\n<td>返回音频/视频当前的就绪状态。</td>\n</tr>\n<tr>\n<td>seekable</td>\n<td>返回表示音频/视频可寻址部分的 TimeRanges 对象。</td>\n</tr>\n<tr>\n<td>seeking</td>\n<td>返回用户是否正在音频/视频中进行查找。</td>\n</tr>\n<tr>\n<td>src</td>\n<td>设置或返回音频/视频元素的当前来源。</td>\n</tr>\n<tr>\n<td>startDate</td>\n<td>返回表示当前时间偏移的 Date 对象。</td>\n</tr>\n<tr>\n<td>textTracks</td>\n<td>返回表示可用文本轨道的 TextTrackList 对象。</td>\n</tr>\n<tr>\n<td>videoTracks</td>\n<td>返回表示可用视频轨道的 VideoTrackList 对象。</td>\n</tr>\n<tr>\n<td>volume</td>\n<td>设置或返回音频/视频的音量。</td>\n</tr>\n</tbody>\n</table>\n<h3> 6.5 音视频相关事件及函数</h3>\n<ul>\n<li>\n<p>音视频方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>addTextTrack()</td>\n<td>向音频/视频添加新的文本轨道。</td>\n</tr>\n<tr>\n<td>canPlayType()</td>\n<td>检测浏览器是否能播放指定的音频/视频类型。</td>\n</tr>\n<tr>\n<td>load()</td>\n<td>重新加载音频/视频元素。</td>\n</tr>\n<tr>\n<td>play()</td>\n<td>开始播放音频/视频。</td>\n</tr>\n<tr>\n<td>pause()</td>\n<td>暂停当前播放的音频/视频。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>音视频事件</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>abort</td>\n<td>当音频/视频的加载已放弃时触发。</td>\n</tr>\n<tr>\n<td>canplay</td>\n<td>当浏览器可以开始播放音频/视频时触发。</td>\n</tr>\n<tr>\n<td>canplaythrough</td>\n<td>当浏览器可在不因缓冲而停顿的情况下进行播放时触发。</td>\n</tr>\n<tr>\n<td>durationchange</td>\n<td>当音频/视频的时长已更改时触发。</td>\n</tr>\n<tr>\n<td>emptied</td>\n<td>当目前的播放列表为空时触发。</td>\n</tr>\n<tr>\n<td>ended</td>\n<td>当目前的播放列表已结束时触发。</td>\n</tr>\n<tr>\n<td>error</td>\n<td>当在音频/视频加载期间发生错误时触发。</td>\n</tr>\n<tr>\n<td>loadeddata</td>\n<td>当浏览器已加载音频/视频的当前帧时触发。</td>\n</tr>\n<tr>\n<td>loadedmetadata</td>\n<td>当浏览器已加载音频/视频的元数据时触发。</td>\n</tr>\n<tr>\n<td>loadstart</td>\n<td>当浏览器开始查找音频/视频时触发。</td>\n</tr>\n<tr>\n<td>pause</td>\n<td>当音频/视频已暂停时触发。</td>\n</tr>\n<tr>\n<td>play</td>\n<td>当音频/视频已开始或不再暂停时触发。</td>\n</tr>\n<tr>\n<td>playing</td>\n<td>当音频/视频在因缓冲而暂停或停止后已就绪时触发。</td>\n</tr>\n<tr>\n<td>progress</td>\n<td>当浏览器正在下载音频/视频时触发。</td>\n</tr>\n<tr>\n<td>ratechange</td>\n<td>当音频/视频的播放速度已更改时触发。</td>\n</tr>\n<tr>\n<td>seeked</td>\n<td>当用户已移动/跳跃到音频/视频中的新位置时触发。</td>\n</tr>\n<tr>\n<td>seeking</td>\n<td>当用户开始移动/跳跃到音频/视频中的新位置时触发。</td>\n</tr>\n<tr>\n<td>stalled</td>\n<td>当浏览器尝试获取媒体数据，但数据不可用时触发。</td>\n</tr>\n<tr>\n<td>suspend</td>\n<td>当浏览器刻意不获取媒体数据时触发。</td>\n</tr>\n<tr>\n<td>timeupdate</td>\n<td>当目前的播放位置已更改时触发。</td>\n</tr>\n<tr>\n<td>volumechange</td>\n<td>当音量已更改时触发。</td>\n</tr>\n<tr>\n<td>waiting</td>\n<td>当视频由于需要缓冲下一帧而停止时触发。</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ul>\n<h3> 6.6 视频与canvas结合</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 7.表单验证</h2>\n<p>**表单验证时有一个<code>validity</code>对象,通过该对象可以查看验证是否通过,内部拥有八种验证,如果八种验证都通过则返回true(是验证通过,不是每一项代表的布尔值,每一项代表的布尔值不通过会变为true),一旦验证失败返回false,**验证事件通过<code>node.addEventListener(\"invalid\",funciotn(){},false)</code>进行绑定,<strong>其中node为用户写入数据的input标签</strong></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>八种验证</strong></p>\n<ul>\n<li>\n<p>**valueMissing:**输入值为空时返回true</p>\n</li>\n<li>\n<p>**typeMismatch:**控件值与预期类型不匹配返回true</p>\n</li>\n<li>\n<p>**patternMismatch:**输入值不满足pattern正则返回true</p>\n</li>\n<li>\n<p>**tooLong:**超过maxLeng最大值限制返回true</p>\n</li>\n<li>\n<p>**rangeUnderflow:**验证的range最小值返回true</p>\n</li>\n<li>\n<p>**rangeOverflow:**验证的range最大值返回true</p>\n</li>\n<li>\n<p>**stepMismatch:**验证range的当前值是否符合min、max及step的规则返回true</p>\n</li>\n<li>\n<p>**customError:**不符合用户的自定义验证返回true\n**注:**自定义验证可以通过<code>node.setCustonValidity(\"输入格式有误\")</code>传递给用户</p>\n</li>\n</ul>\n<p>**关闭表单验证:**通过formnovalidate属性可以关闭表单的验证</p>\n<h2> 8.地理信息</h2>\n<h3> 8.1 位置信息来源</h3>\n<ul>\n<li>\n<p>IP地址</p>\n</li>\n<li>\n<p>GPS全球定位系统</p>\n</li>\n<li>\n<p>Wi-Fi无线网络</p>\n</li>\n<li>\n<p>基站</p>\n</li>\n</ul>\n<h4> 8.2 navigator.geolocation</h4>\n<p><strong>navigator.geolocation用于获取设备的当前位置</strong></p>\n<p><strong>navigator.geolocation的三个方法：</strong></p>\n<ul>\n<li>\n<p>getCurrentPosition()</p>\n</li>\n<li>\n<p>watchPosition()</p>\n</li>\n<li>\n<p>clearWatch()</p>\n</li>\n</ul>\n<h4> 8.2.1 getCurrentPosition</h4>\n<p><strong>使用方法:<code>navigator.geolocation.getCurrentPosition(successCallback,[errorCallback], [positionOptions])</code>;</strong></p>\n<ul>\n<li>\n<p><strong>successCallback:<strong>successCallback返回一个地理数据对象</strong>position</strong>作为参数,该对象有属性<strong>timestamp</strong>和<strong>coords</strong>。<strong>timestamp表示该地理数据创建时间(时间戳),可以通过<code>new Date(position.timestamp)</code>得到,coords包括另外七个属性：</strong></p>\n</li>\n<li>\n<ul>\n<li>coords.latitude:估计纬度</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>coords.longitude:估计经度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>coords.altitude:估计高度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>coords.accuracy:所提供的以米为单位的经度和纬度估计的精确度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>coords.altitudeAccuracy:所提供的以米为单位的高度估计的精确度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>coords.heading:宿主设备当前移动的角度方向，相对于正北方向顺时针计算</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>coords.speed:以米每秒为单位的设备的当前对地速度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>errorCallback:<strong>errorCallback返回一个错误数据对象</strong>error</strong>作为参数,该对象有属性<strong>code</strong>和<strong>message</strong></p>\n</li>\n<li>\n<ul>\n<li>**code 😗*表示失败原因,会返回失败4种编号.</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**0:**不包括其他错误编号中的错误</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**1:**用户拒绝浏览器获取位置信息</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**2:**尝试获取用户信息,但失败了</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>**3:**设置了timeout值,获取位置超时了</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>message:错误的提示内容</li>\n</ul>\n</li>\n<li>\n<p><strong>positionOptions:</strong> positionOptions用来设置positionOptions来更精细的执行定位,positionOptions拥有三个属性:</p>\n</li>\n<li>\n<ul>\n<li>**enableHighAccuracy:**值为true或者false(默认),是否返回更详细更准确的结构,默认为false不启用,选择true则启用,但是会导致较长的响应时间及增加功耗,这种情况更多的用在移动设备上</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**timeout:**设备位置获取操作的超时时间设定(不包括获取用户权限时间),单位为毫秒,如果在设定的timeout时间内未能获取位置定位,则会执行errorCallback()返回code(3)。如果未设定timeout,那么timeout默认为无穷大,如果timeout为负数,则默认timeout为0</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**maximumAge:**设定位置缓存时间,以毫秒为单位,如果不设置该值,该值默认为0,如果设定负数,则默认为0。该值为0时,位置定位时会重新获取一个新的位置对象。该值大于0时,即从上一次获取位置时开始,缓存位置对象,如果再次获取位置时间不超过maximumAge,则返回缓存中的位置,如果超出maximumAge,则重新获取一个新的位置</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.2.2 watchPosition</h4>\n<p>该方法功能与getCurrentPosition()类似,参数也是相同的三个参数,不过该方法会在检查到位置发生改变后才会触发,所以只对移动设备有用,并且该函数会触发多次</p>\n<p>**使用方法:<code>navigator.geolocation.watchPosition(successCallback, [errorCallback] , [positionOptions])**</code></p>\n<h4> 8.2.3 clearWatch</h4>\n<p><strong>该方法用于配合watchPosition()使用,用于停止watchPosition()轮询</strong></p>\n<p>watchPosition()需要定义一个watchID,如<code>let watchID = watchPosition(...)，</code>,通过clearWatch(watchID)来停止watchPosition()，使用方法类似setInterval</p>\n<h2> 9.Worker与EventSource</h2>\n<h3> 9.1 Worker</h3>\n<p><strong>Woreker是H5中提出的可以让JS实现多线程的对象,通过向其中传入后台处理的JS地址就能让JS通过多线程处理代码,提高效率</strong></p>\n<ul>\n<li>\n<p>**postMessage:**传输数据给后台</p>\n</li>\n<li>\n<p>**onmessage事件:**接收到前台和后台传输数据的事件</p>\n</li>\n<li>\n<p>**importScripts(\"其余JS文件\")😗*该函数能够引入一个JS文件并执行其中代码</p>\n</li>\n</ul>\n<div class=\"language-javascript\" data-ext=\"js\"></div><div class=\"language-javascript\" data-ext=\"js\"></div><div class=\"language-javascript\" data-ext=\"js\"></div><h3> 9.2 EventSource</h3>\n<p><strong>EventSource对象能够获取到sse服务器推送的消息, 同时也是使用其onmessage事件监听接收消息</strong></p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 10.离线存储和跨文档请求</h2>\n<h3> 10.1 离线存储</h3>\n<ul>\n<li>\n<p><strong>服务器设置头信息 :</strong> <code>AddType text/cache-manifest .manifest</code></p>\n</li>\n<li>\n<p><strong>html标签加 :</strong> <code>manifest=“xxxxx.manifest”</code></p>\n</li>\n<li>\n<p><strong>写manifest文件 :  离线的清单列表</strong>\n先写 :  CACHE MANIFEST\nFALLBACK :  第一个网络地址没获取到，就走第二个缓存的\nNETWORK ：无论缓存中存在与否，均从网络获取</p>\n</li>\n</ul>\n<h3> 10.2 跨文档请求</h3>\n<h4> 10.2.1 同域跨文档</h4>\n<ul>\n<li>\n<p><strong>iframe内页：</strong></p>\n</li>\n<li>\n<ul>\n<li><strong>父页面操作子页面</strong>:<code>iframe.contentWindow</code>,iframe为需要操作的iframe标签</li>\n</ul>\n</li>\n<li>\n<ul>\n<li><strong>子页面操作父页面:</strong><code>window.top(找到最顶级的父页面)/parent(第一父页面)</code></li>\n</ul>\n</li>\n<li>\n<p><strong>新窗口页：</strong></p>\n</li>\n<li>\n<ul>\n<li>**父页面操作子页面:**window.open</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**子页面操作父页面:**window.opener</li>\n</ul>\n</li>\n</ul>\n<h4> 10.2.2 不同域跨文档</h4>\n<p><strong>通过postMessage(“发送的数据”,”接收的域”)发送跨域信息,再通过对window绑定message事件进行监听</strong>\n<strong>message事件:</strong></p>\n<ul>\n<li>\n<p>**e.origin:**发送数据来源的域</p>\n</li>\n<li>\n<p>**e.data:**发送的数据,通过判断发送的数据来执行相应的需求</p>\n</li>\n</ul>\n<h2> 11.移动端事件</h2>\n<h3> 11.1 基础事件</h3>\n<ul>\n<li>\n<p><strong>PC端事件</strong></p>\n</li>\n<li>\n<ul>\n<li>**onclick:**鼠标点击触发</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**onmousedown:**鼠标按下触发</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**onmousemove:**鼠标移动触发</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**onmouseup:**鼠标抬起触发</li>\n</ul>\n</li>\n<li>\n<p><strong>移动端触屏事件</strong></p>\n</li>\n<li>\n<ul>\n<li>**ontouchstart:**手指按下触发</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**ontouchmove:**手指移动触发</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>**ontouchend:**手指抬起触发</li>\n</ul>\n</li>\n</ul>\n<h3> 11.2 注意事项</h3>\n<ul>\n<li>\n<p>通过on的方式添加touch事件在谷歌模拟器下无效</p>\n</li>\n<li>\n<p>鼠标事件在移动端可以使用，但有300毫秒的延迟\n**点透问题:**点击了页面之后,浏览器会记录点击下去的坐标300毫秒之后,在该坐标找到现在的元素,执行该事件,所以如果期间进行了移动可能会无效\n<strong>解决办法:</strong></p>\n</li>\n<li>\n<ul>\n<li>阻止默认事件,但在部分安卓机不支持</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>不用a标签做页面跳转,用window.location.href做跳转,比如移动端淘宝</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>在移动端不用鼠标事件</li>\n</ul>\n</li>\n<li>\n<p>**防止误触问题:**用JS做判断,手指移动就不跳转,没有移动,说明是点击,则跳转</p>\n</li>\n</ul>\n<h3> 11.3 获取手指信息</h3>\n<p><strong>所有的手指信息都是在触屏事件的event对象中得到</strong></p>\n<ul>\n<li>\n<p>**e.touches:**当前屏幕上的手指列表</p>\n</li>\n<li>\n<p>**e.targetTouches:**当前元素上的手指列表</p>\n</li>\n<li>\n<p>**e.changedTouches:**触发当前事件的手指列表</p>\n</li>\n<li>\n<p>**e.changedTouches.length:**获取手指的个数</p>\n</li>\n<li>\n<p>**e.changedTouches[0].pageX|pageY:**获取X和Y坐标</p>\n</li>\n</ul>\n<p><strong>注意:<strong>在touchend事件的时候想要获取手指列表,只能用</strong>e.changedTouches</strong>,因为手指抬起也就没有touches和targetTouches了,只能用changedTouches</p>\n<h2> 12.移动端适配</h2>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>适配方案</strong></p>\n<ul>\n<li>\n<p>固定高度，宽度百分比适配-布局非常均匀 适合百分比布局</p>\n</li>\n<li>\n<p>固定宽度，改变缩放比例适配-什么情况都可以</p>\n</li>\n<li>\n<p>rem适配</p>\n</li>\n<li>\n<p>PC端和移动端 分开开发</p>\n</li>\n<li>\n<p>响应式开发(很麻烦)</p>\n</li>\n<li>\n<p>Bootstrap</p>\n</li>\n</ul>\n<p><strong>单位</strong></p>\n<ul>\n<li>\n<p>em:根据元素自身的字体大小计算元素自身</p>\n</li>\n<li>\n<p>rem:根据html的字体大小计算其他元素尺寸</p>\n</li>\n</ul>\n<h3> 12.1 固定高度,宽度百分比</h3>\n<ul>\n<li>\n<p>根据设置的大小去设置高度,单位可以用px、百分比、auto</p>\n</li>\n<li>\n<p>常用Flex布局</p>\n</li>\n<li>\n<p>百分比宽度</p>\n</li>\n</ul>\n<h3> 12.2 固定宽度,改变缩放比例</h3>\n<ul>\n<li>\n<p>设计图的宽度就是网页显示的宽度</p>\n</li>\n<li>\n<p>改变视口的缩放比例</p>\n</li>\n<li>\n<p>页面宽度固定死</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 12.3 rem适配</h3>\n<ul>\n<li>\n<p>根据屏幕的分辨率动态设置html的文字大小,达到等比缩放的功能</p>\n</li>\n<li>\n<p>保证html最终算出来的字体大小,不能小于12px</p>\n</li>\n<li>\n<p>在不同的移动端显示不同的元素比例效果</p>\n</li>\n<li>\n<p>把设计图的宽度分成多少分之一,根据实际情况</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 12.4 像素比适配</h3>\n<ul>\n<li>\n<p>物理像素:手机屏幕分辨率</p>\n</li>\n<li>\n<p>独立像素 指css像素的屏幕宽度</p>\n</li>\n<li>\n<p>像素比 = 物理像素 / css</p>\n</li>\n<li>\n<p>获取设备的像素比:window.devicePixelRatio</p>\n</li>\n</ul>\n<div class=\"language-html\" data-ext=\"html\"></div><div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>**更多优化方案:**http://www.cnblogs.com/wujindong/p/5442275.html</p>\n<h3> 12.5 横竖屏切换</h3>\n<ul>\n<li>\n<p>window.orientation判断选择角度</p>\n</li>\n<li>\n<p>**方向:**竖屏0、横屏90或-90</p>\n</li>\n<li>\n<p>根据横屏幕的切换执行不同的事情</p>\n</li>\n<li>\n<p>**横竖屏切换监听事件:**orientationchange</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "CSS",
      "url": "https://harryxiong24.github.io/zh/front-end/html-css/css.html",
      "id": "https://harryxiong24.github.io/zh/front-end/html-css/css.html",
      "summary": "[[toc]] 1. 外部链接 2. 类和ID及css选择器 2.1 类 2.2 ID id具有唯一性 2.3 css选择器 2.3.1 选择器的权重 选择器的权重大小: ID > 类 > 标签名 > 通配符 在选择器中的属性出现相同的时候,优先考虑ID选择器,然后是类选择器,标签选择器,最后才考虑通配符选择器 在都有这些选择器的时候再看每一个选择器的...",
      "content_html": "<h1> CSS</h1>\n\n<h2> 1. 外部链接</h2>\n<div class=\"language-css\" data-ext=\"css\"></div><div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-css\" data-ext=\"css\"></div><h2> 2. 类和ID及css选择器</h2>\n<h3> 2.1 类</h3>\n<p>&lt;标记名 class=\"\"&gt;</p>\n<h3> 2.2 ID</h3>\n<p>&lt;标记名 id=\"\"&gt;id具有唯一性</p>\n<h3> 2.3 css选择器</h3>\n<h4> 2.3.1 选择器的权重</h4>\n<p><strong>选择器的权重大小: ID &gt; 类 &gt; 标签名 &gt; 通配符</strong></p>\n<p>在选择器中的属性出现相同的时候,<strong>优先考虑ID选择器,然后是类选择器,标签选择器,最后才考虑通配符选择器</strong></p>\n<p>在都有这些选择器的时候再看每一个选择器的数量,从ID到标签选择器,数量多的属性生效,如果数量完全相同,那么写在下方的生效</p>\n<p><strong>注意:</strong></p>\n<ol>\n<li>\n<p>如果css是写在行内的,无视所有选择器直接拿到权重</p>\n</li>\n<li>\n<p>相同选择器数量的情况下内部样式的权重大于外部样式的权重,但是如果外部用的是ID选择器内部是类选择器,那么外部的属性生效</p>\n</li>\n<li>\n<p>可以使用 <strong>!important</strong> 将权重提升到最高,甚至超过行内样式,但是尽量减少important的使用,因为过多的使用容易造成对于样式设置的混乱</p>\n</li>\n</ol>\n<h4> 2.3.2 选择器的种类</h4>\n<ul>\n<li>\n<p>标签选择器</p>\n<p><strong>通过标签直接对所有该标签元素进行样式的修改</strong></p>\n</li>\n<li>\n<p>通配符选择器</p>\n<p><strong>能选择所有的标签元素，权重很低,在开发中不推荐使用</strong>\n用法:*{}</p>\n</li>\n<li>\n<p>后代元素选择器</p>\n<p><strong>选择当前标签下的所有相匹配的后代,不一定是子代,可以是孙子代,中间用空格隔开</strong>\n如: .类 ul li p这样的选择器就是选择当前类下的ul标签中的所有li标签中的所有p标签</p>\n</li>\n<li>\n<p>子元素选择器</p>\n<p><strong>基本与后代元素选择器的用法相同,不过只能够选择子代,不能选择孙子代,中间用&gt;符合隔开</strong>\n如: .类&gt;li&gt;a等就是对必须是li下面的a元素才起作用</p>\n</li>\n<li>\n<p>兄弟选择器</p>\n<p><strong>相邻兄弟选择器,匹配前面一个选择器后紧跟的同级选择器,中间用+符号隔开</strong>\n如:a+p{}表示匹配在前一个a元素的后面紧跟着的一个p元素</p>\n<p><strong>一般兄弟选择器,匹配前一个元素后面的所有同级的某一个元素,中间用~符号隔开</strong>\n如:a~p{}表示匹配在前一个a元素的所有后面p的元素</p>\n</li>\n<li>\n<p>伪元素选择器</p>\n<p><strong>创建伪元素before/after</strong>\n<strong>伪元素必须依赖某一个标签才能产生</strong>\n<strong>如下：</strong></p>\n</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>Hint：</strong></p>\n<ol>\n<li>\n<p>伪元素可以传入图片,一种是通过background-image属性传入,一种是在content处用url()函数来传入图片</p>\n</li>\n<li>\n<p>可以通过在content处写上attr()函数来获取伪元素所在环境的标签上的属性</p>\n</li>\n</ol>\n<div class=\"language-css\" data-ext=\"css\"></div><ol start=\"3\">\n<li>可以通过伪元素来清除浮动</li>\n</ol>\n<div class=\"language-css\" data-ext=\"css\"></div><ul>\n<li><strong>伪类选择器</strong>\n<strong>注:伪类可以对链接在不同状态下定义不同的样式效果，伪类是CSS已经定义了的</strong>\n<strong>如：</strong></li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p>属性选择器</p>\n<p><strong>属性选择器选择时一般都是通过[]将要进行筛选的属性括起来</strong></p>\n</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><strong>前缀和后缀和包含匹配</strong></li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p><strong>交并集选择器</strong></p>\n<p><strong>交集选择器需要两个选择器紧挨着写,并且如果有标签选择器标签需要在最前面写</strong></p>\n<p><strong>并集选择器则是用逗号(,)隔开就可以,这样就会选中所有的被,隔开的选择器</strong></p>\n</li>\n<li>\n<p>序选择器</p>\n<p><strong>:first-child选中同级别第一个</strong>\n如:p:first-child这样用相当于和p做交集选出同级别第一个元素后与p做交集</p>\n<p><strong>:first-of-type选中同级别同类型的第一个元素</strong></p>\n<p><strong>:last-child选中同级别最后一个标签，不区分类型</strong></p>\n<p><strong>:last-of-type选中同级别同类型的最后一个</strong></p>\n<p><strong>:nth-child(n)选中同级别中的第n个标签，不区分类型</strong></p>\n<p><strong>拓展用法:</strong></p>\n<p>odd代表奇数行，even代表偶数行，用xn+y这样的语法进行选择:x和y是用户自定义的,而0是一个计数器，从0开始递增</p>\n<p><strong>:nth-of-type(n)选中同级别中、同类型的第n个标签，用法同上</strong></p>\n<p><strong>:nth-lastchild(n)选中同级别的第倒数第几个标签</strong></p>\n<p><strong>:only-child选中只有一个子元素的父元素带的子元素</strong></p>\n<p><strong>:only-of-type选中父元素中唯一类型的标签</strong></p>\n<p><strong>:not(tagname)选中不是指定标签的所有标签</strong></p>\n</li>\n</ul>\n<p><strong>注意:</strong></p>\n<p><strong>CSS样式的继承性:</strong></p>\n<p>​\t1. 只有以color/font-/text-/line开头的属性才可以继承</p>\n<p>​\t2. <strong>特例</strong>:a标签的下划线和颜色不能继承，h标签的字体大小不能继承</p>\n<p>​\t3. <strong>计算权重时只对被直接选中的元素进行选择</strong></p>\n<h2> 3.文本样式</h2>\n<h3> 3.1 字体样式</h3>\n<p><strong>1.字体类型font-family</strong></p>\n<p><strong>font-family属性表示用哪一个字体</strong>,这个属性后面写需要的字体,字体可以写多个,但总是从第一个开始用,如果用户没有第一个字体样式.那么会依次用后面的字体</p>\n<p><strong>如何用外部引用的字体:</strong></p>\n<div class=\"language-css\" data-ext=\"css\"></div><p><strong>2.字体尺寸font-size</strong></p>\n<p>**font-size属性表示字体大小,**这个属性一般用的单位为px,也可以用一般表示大小的单词来直接表示大小,这个大小是由浏览器加上的,如:xx-small x-small等绝对尺寸,smaller和larger等相对尺寸以及百分比尺寸</p>\n<p><strong>3.字体粗细font-weight</strong></p>\n<p><strong>font-weight属性改变字体粗细</strong>,可以写具体的数字也可以写表示大小的单词由浏览器加上</p>\n<ul>\n<li>100-900表示字体粗细的数字值</li>\n<li>normal表示正常字体粗细，相当于数字值400</li>\n<li>bold表示粗体，相当于数字值700,同时这个值也是最常用的,一般不用数字值,而且这个属性一般也只用作让字\n体加粗</li>\n<li>bolder lighter定义比继承者值更重和更轻的值 ,这是相对值</li>\n</ul>\n<p><strong>4.字体风格font-style</strong></p>\n<p><strong>font-style属性表示字体风格</strong>,一般都用作让字体倾斜</p>\n<ul>\n<li>nomal表示正常字体</li>\n<li>italic和oblique都是表示斜体,但是实质上还是有差别,一般都用italic</li>\n</ul>\n<p><strong>5.字体显示小型大写字符font-variant</strong></p>\n<p><strong>font-variant属性定义小写字母是否显示为小型大写字母</strong>，默认的值为normal</p>\n<p><strong>用法:font-variant:small-caps;</strong></p>\n<p>**字体混合属性用法:**font:font-style font-variant font-weight font-size font-family 中间可以少,但是必须按照这个顺序排列</p>\n<p><strong>6.字体颜色color</strong></p>\n<p>color属性表示字体颜色,支持英文单词,16进制颜色和rgb颜色</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li><strong>rgb()和rgba()后者最后一个是透明度</strong></li>\n<li><strong>color:transparent为颜色透明</strong></li>\n</ul>\n<h3> 3.2 行高line-height</h3>\n<p><strong>line-height属性设置行高</strong>，行高和字体高度不同,但是行高默认会随着字体大小的变化而变化,而撑开盒子高度就是靠的行高</p>\n<p><strong>注意:通过设置行高和内容高度相等可以使得单行文本垂直居中</strong></p>\n<p><strong>多行文本垂直居中方法:</strong></p>\n<p><strong>方法一：使用插入 table  (包括tbody、tr、td)标签，或者父元素使用display:table和子元素使用display:table-cell属性来模拟表格，同时设置子元素vertical-align:middle</strong></p>\n<div class=\"language-html\" data-ext=\"html\"></div><div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>方法二：对子元素设置display:inline-block属性，使其转化成行内块元素，模拟成单行文本。元素设置对应的height和line-height。对子元素设置vertical-align:middle属性，使其基线对齐添加line-height属性，覆盖继承自父元素的行高。缺点：文本的高度不能超过外部盒子的高度</strong></p>\n<div class=\"language-html\" data-ext=\"html\"></div><div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>方法三:脱离文档流的居中方式，把内部div设置宽高之后，再设置top为50%，使用负边距调整，将margin-to设置为负的高度的一半就可以垂直居中了。缺点:需要计算出多行文字固定的高度。高度一旦改变，负边距也要调整。</strong></p>\n<div class=\"language-html\" data-ext=\"html\"></div><div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.3 文字上下对齐vertical-align</h3>\n<p>**vertical-align属性设置内联元素的上下对齐方式,**在父元素设置此样式时,会对inline-block和inline类型的子元素都有用,这个样式一般用做图片和文字的对齐,因为内联元素的独特的对齐方式,所以设置图文对齐的方法一般都是图形和文字都设置vertical-align:middle来使得图文对齐</p>\n<p><strong>verticl-align的值:</strong></p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>baseline</td>\n<td>默认。元素放置在父元素的基线上。</td>\n</tr>\n<tr>\n<td>sub</td>\n<td>垂直对齐文本的下标。</td>\n</tr>\n<tr>\n<td>super</td>\n<td>垂直对齐文本的上标</td>\n</tr>\n<tr>\n<td>top</td>\n<td>把元素的顶端与行中最高元素的顶端对齐</td>\n</tr>\n<tr>\n<td>text-top</td>\n<td>把元素的顶端与父元素字体的顶端对齐</td>\n</tr>\n<tr>\n<td>middle</td>\n<td>把此元素放置在父元素的中部。</td>\n</tr>\n<tr>\n<td>bottom</td>\n<td>把元素的顶端与行中最低的元素的顶端对齐。</td>\n</tr>\n<tr>\n<td>text-bottom</td>\n<td>把元素的底端与父元素字体的底端对齐。</td>\n</tr>\n<tr>\n<td>length</td>\n<td>定义固定的值</td>\n</tr>\n<tr>\n<td>%</td>\n<td>使用 \"line-height\" 属性的百分比值来排列此元素。允许使用负值。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应该从父元素继承 vertical-align 属性的值。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>内联元素的对齐方式:</strong></p>\n<p>所有的内联元素都是通过文字基线对齐方式来实现对齐的,默认情况下是以小写x的两个下角为边界进行图文对齐,</p>\n<p>图片不会超过x的下角所在水平线的位置,vertical-align的默认值是baseline,元素是放在父元素的基线上的</p>\n<p><strong>不知道盒子高度的情况下将文本垂直居中</strong></p>\n<div class=\"language-css\" data-ext=\"css\"></div><h3> 3.4 文本水平对齐text-align</h3>\n<p><strong>text-align属性设置水平对齐方式</strong></p>\n<p>值:left左对齐 right右对齐 center居中对齐 justify两端对齐</p>\n<h3> 3.5 文本换行white-space</h3>\n<p>**white-space属性可以对文本的换行操作进行控制,**默认值是nomal,设置文本到达父元素的边界就自动换行</p>\n<p><strong>white-space:nowrap设置文本不换行</strong>,意思是文本到达边界依然会继续的由左向右平铺,该属性只要都是设置这个值,除此之外还有其他的值,如:white-space:pre不换行又保留多个空格 white-space:pre-wrap保留空白字符但是换行 white-space: pre-line保留换行符 white-space:inherit继承父元素的该属性</p>\n<p><strong>实现文本超出显示省略号:</strong></p>\n<p>需要三个属性的组合</p>\n<ul>\n<li>white-space:nowrap不换行</li>\n<li>text-overflow:ellipsis文本超出显示省略号</li>\n<li>overflow:hidden超出隐藏</li>\n</ul>\n<h3> 3.6 单词换行word-break</h3>\n<p>**word-break属性可以控制单词或字符进行换行,**默认值为normal,使浏览器遵循默认的换行规则</p>\n<p>word-break:break-all强制换行,允许在单词内部换行,如果只写一个因为单词但是太长用了这个属性就会强制把单词断开</p>\n<p>word-break:keep:all,只允许在半角空格或连字符处换行。</p>\n<h3> 3.7 文本缩进text-indent</h3>\n<p><strong>text-indent属性控制文本在一个父元素最前方字符的缩进距离</strong>,该属性可以通过调试来让文本显示在父元素的一</p>\n<p>些特殊位置,可以把它用做于padding-left的作用类似，默认值是not specified,也就是<strong>不首行缩进设置的值一般都是固定的缩放距离</strong>，比如:text-indent:2em 首行缩进2个字符。也可以是百分比，定义基于父元素宽度的百分比的缩进</p>\n<h3> 3.8 控制单词形式text-transform</h3>\n<p><strong>text-transform属性控制英文单词大小写转换</strong></p>\n<p>**值:**none 无转换 capitalize将每个单词的第一个字母大写 uppercase将所有字母大写 lowercase将所有字母小写</p>\n<p>ful-width全角</p>\n<h3> 3.9 字符与单词间距</h3>\n<p><strong>一行文字如果中间没有空格隔开就是组成部分就是一个个字符,这一行文字就是一个单词,而如果有空格隔开,根据</strong>空格的数量来判断单词的数量**</p>\n<p><strong>letter-spacing用来控制字符间的间距</strong>,默认值为normal,具体也是通过写固定的值来实现字符间距</p>\n<p>**注:**汉字也是被认为是一个个的字符,因为中间没有用空格隔开</p>\n<p><strong>word-spacing为单词间距</strong>,该间距是每一个用空格隔开英文单词的间距.只有用空格隔开的词才会认为是一个单词单词内部间距不变</p>\n<h3> 3.10 文本修饰text-decoration</h3>\n<p><strong>text-decoration属性用于修改文本的样式</strong>,是一个复合属性,该属性也是由一些小的属性的组合属性,但是在运用时都是直接用这个属性</p>\n<p><strong>子属性:</strong></p>\n<p><strong>1.text-decoration-line设置文本修饰的样式线条</strong>,一般标签的默认值为none关闭修饰,而a标签的默认值是underline 下划线文本,所以一般a标签都需要通过设置text-decoration:none来修改a标签的样式,其它值还有overline上划线  line-through贯穿线(也叫作删除线)</p>\n<p><strong>2.text-decoration-style设置文本修饰的风格,值:</strong></p>\n<p>solid实线 double双线 dotted点线 dashed虚线 wave波浪线</p>\n<p><strong>3.text-decoration-color设置文本修饰颜色</strong>,用来指定文本装饰线条的颜色,如果不写这个属性这是默认用的字体颜色color</p>\n<h3> 3.11 文本阴影text-shadow</h3>\n<p>**text-shadow属性设置文本周围是否出现阴影,**默认值为none 无阴影</p>\n<p><strong>设置阴影test-shadow:长度1 长度二  长度三  颜色</strong>  (长度三和颜色为可选属性)</p>\n<ul>\n<li>长度1设置水平偏移值，可以为负值，正值表示阴影在右，负值在左</li>\n<li>长度2设置垂直偏移量 正值在下负值在上</li>\n<li>长度三用来设置文本的阴影模糊值，不允许用负值</li>\n<li>颜色用来设置阴影的颜色</li>\n</ul>\n<p><strong>注:可以写多组阴影,每一组阴影中间用逗号隔开</strong></p>\n<h3> 3.12 文本书写模式writing-mode</h3>\n<p><strong>writing-mode 属性定义了文本在水平或垂直方向上如何排布</strong></p>\n<p><strong>语法:</strong></p>\n<div class=\"language-css\" data-ext=\"css\"></div><p><strong>值：</strong></p>\n<ul>\n<li>**horizontal-tb：**水平方向自上而下的书写方式。<strong>即 left-right-top-bottom</strong></li>\n<li>**vertical-rl：**垂直方向自右而左的书写方式。<strong>即 top-bottom-right-left</strong></li>\n<li>**vertical-lr：**垂直方向内内容从上到下，水平方向从左到右</li>\n<li><strong>sideways-rl</strong>：内容垂直方向从上到下排列</li>\n<li>**sideways-lr：**内容垂直方向从下到上排列</li>\n</ul>\n<h3> 3.13 列表属性list-style</h3>\n<p>**list-style是复合的列表属性,**包含list-style-image,list-style-position和list-style-type等</p>\n<ul>\n<li><strong>list-style-image属性用来设置对象的列表项是否图像作为项目符号</strong>\nlist-style-image:url()来指定图片的域名,还有一个none值意为不指定图片符号</li>\n<li><strong>list-style-position属性用来设置对象的列表序号的位置</strong>\nlist-style-positon:outside（inside）ouside为默认值,让列表符号与文字分离开,inside使得列表序号在文本内,\n可以通过控制文本来控制</li>\n<li><strong>list-style-type属性为设置对象的列表项所使用的项目符号</strong>\nlist-style-type:disc实心圆 circle空心圆 square实心方块 decimal阿拉伯数字 lower-alpha小写英文字母\nupper-alpha大写英文字母  none 为不用项目符号\n列表复合属性语法:\nlist-style:list-style-image  list-style-position  list-style-type 按照这个顺序进行书写 如果list-style-image\n这个属性有值并且生效,那么list-style-type属性将不会生效,如果这个属性使none那么list-style-type属性生</li>\n</ul>\n<h3> 3.14 文本溢出text-overflow</h3>\n<p><strong>text-overflow 属性规定当文本溢出包含元素时发生的事情</strong>,默认值是clip,修剪文本,将文本剪裁掉</p>\n<p><strong>值:</strong></p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>clip</td>\n<td>修剪文本</td>\n</tr>\n<tr>\n<td>ellipsis</td>\n<td>显示省略符号来代表被修剪的文本</td>\n</tr>\n<tr>\n<td><em>string</em></td>\n<td>使用给定的字符串来代表被修剪的文本</td>\n</tr>\n</tbody>\n</table>\n<h3> 3.15 内容溢出overflow</h3>\n<p>**overflow属性定义溢出元素内容区的内容会如何处理,**默认值是visible，超出内容不会被修剪，会呈现在元素框之外</p>\n<p><strong>值:</strong></p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hidden</td>\n<td>内容会被修剪，并且其余内容是不可见的。</td>\n</tr>\n<tr>\n<td>scroll</td>\n<td>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</td>\n</tr>\n<tr>\n<td>auto</td>\n<td>如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应该从父元素继承 overflow 属性的值。</td>\n</tr>\n<tr>\n<td>visible</td>\n<td>默认值。内容不会被修剪，会呈现在元素框之外。</td>\n</tr>\n</tbody>\n</table>\n<h2> 4.盒子模型</h2>\n<p><strong>注意:</strong></p>\n<p><strong>因为不同的浏览器会为盒子自动添加不同的内外边距.如果要让网页在每一个浏览器上都显示一样的效果.需要在写代码前把默认的边距全部清空,在平时可以用通配符选择器来清空,但是写正规项目的时候不要这样写,因为通配符选择器的权重太低了</strong></p>\n<p><strong>HTML盒模型由4个元素组成:content padding border margin(按由内到外的顺序)</strong></p>\n<p><strong>盒子大小的计算方法:</strong> content(内容区)+padding(内边距)+border(边框)+margin(外边距)</p>\n<h3> 4.1 margin的注意点</h3>\n<ul>\n<li>\n<p>两个紧挨的兄弟盒子同时设margin,左右两边的margin会叠加,而上下的margin会重叠,margin值更大的盒子的margin会生效</p>\n</li>\n<li>\n<p>当两个盒子是父子关系时,设置子盒子左右的margin值会让子盒子在父盒子里面进行偏移,如果设置上下的\nmargin值则会有margin重合的现象,让父盒子也跟着子盒子一起移动,给父盒子添加border属性可以避免这种\n现象</p>\n</li>\n</ul>\n<h3> 4.2 box-sizing</h3>\n<p><strong>box-sizeing属性能改变盒子大小的计算方法</strong></p>\n<div class=\"language-css\" data-ext=\"css\"></div><p>默认值是content-box,默认情况下width和height只改变内容区</p>\n<p>**border-box能让盒子变为怪异盒模型,**怪异盒模型的计算方式和普通内容盒模型的计算方式不同,怪异盒模型是把padding和border的宽度一起算入width和height中,当宽度和高度固定时,变化padding和border值会自动的将内容区域缩小</p>\n<h3> 4.3 边框border</h3>\n<h4> 4.3.1 一般边框</h4>\n<p><strong>border属性是一个复合属性,可以按照border-width border-style border-color的顺序设置边框</strong></p>\n<p>border:宽度 样式 颜色</p>\n<ul>\n<li><strong>border-width属性,定义边框厚度</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>thin</td>\n<td>定义细的边框。</td>\n</tr>\n<tr>\n<td>medium</td>\n<td>默认。定义中等的边框。</td>\n</tr>\n<tr>\n<td>thick</td>\n<td>定义粗的边框。</td>\n</tr>\n<tr>\n<td><em>length</em></td>\n<td>允许自定义边框的宽度。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应该从父元素继承边框宽度。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>通常情况下边框的宽度都是直接写固定的值</strong></li>\n<li><strong>border-style属性定义边框的样式</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>none</td>\n<td>定义无边框。除非用border-image边框才能使边框生效</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td>与 \"none\" 相同。不过应用于表时除外，对于表，hidden 用于解决边框冲突。</td>\n</tr>\n<tr>\n<td>dotted</td>\n<td>定义点状边框。在大多数浏览器中呈现为实线。</td>\n</tr>\n<tr>\n<td>dashed</td>\n<td>定义虚线。在大多数浏览器中呈现为实线。</td>\n</tr>\n<tr>\n<td>solid</td>\n<td>定义实线。</td>\n</tr>\n<tr>\n<td>double</td>\n<td>定义双线。双线的宽度等于 border-width 的值。</td>\n</tr>\n<tr>\n<td>groove</td>\n<td>定义 3D 凹槽边框。其效果取决于 border-color 的值。</td>\n</tr>\n<tr>\n<td>ridge</td>\n<td>定义 3D 垄状边框。其效果取决于 border-color 的值。</td>\n</tr>\n<tr>\n<td>inset</td>\n<td>定义 3D inset 边框。其效果取决于 border-color 的值。</td>\n</tr>\n<tr>\n<td>outset</td>\n<td>定义 3D outset 边框。其效果取决于 border-color 的值。</td>\n</tr>\n<tr>\n<td>nherit</td>\n<td>规定应该从父元素继承边框样式。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>border-color属性,定义边框线的颜色</strong>\n<strong>注意:</strong>\n以上的三个属性也全部都是复合属性,都是上下左右四个方向的复合属性结构,只写一个值是上下左右四个面全\n部都是那个值,可以通过如:border-top-width这样的写法来单独设置某一个面,也可以写四个值来分别显示四个\n面的结果 ,一样的遵循上右下左的格式</li>\n</ul>\n<h4> 4.3.2 圆角边框</h4>\n<p><strong>border-radius属性决定是否边角出现圆角</strong>,这个属性也是个复合属性,决定左上 右上 右下 左下四个方向的圆角大小,也可以只写一个来代表所有方向,这个属性和border属性无关,即使没有边框也可以作用</p>\n<p><strong>注意:这个属性经常用做显示胶囊状的盒子,同时如果盒子的宽高相等,再将这个属性设置为50%，就会出现圆形的盒子</strong></p>\n<h4> 4.3.3 图像边框</h4>\n<p>**border-image属性设置是否用图像边框.**启用的这个属性border-style设置的边框将会无效,同时这个属性也是个复合属性</p>\n<div class=\"language-css\" data-ext=\"css\"></div><ul>\n<li><strong>border-image-sorce属性用于指定要用于绘制边框的图像的位置</strong>,该属性默认值是none,如果要传入图片和写\n背景图片的用法是一样的用url(\"\")来传入图片的地址</li>\n<li><strong>border-image-slice属性控制边框图像地切片方式</strong>,也是指定四个位置</li>\n</ul>\n<div class=\"language-css\" data-ext=\"css\"></div><ul>\n<li>这个属性的值可以是具体的数值也可以是百分比,如果后面再加fill表示保留着中间部分，相当于盒子作为了背\n景图片\n<strong>注意:</strong> 此属性指定顶部 ，右，底部，左边缘的图像向内偏移，分为九个区域：四个角，四边和中间。图像中间部分将被丢弃（完全透明的处理），除非填写关键字。如果省略第四个数字/百分比，它和第二个相同的。如果也省略了第三个，它和第一个是相同的。如果也省略了第二个，它和第一个是相同的。</li>\n<li><strong>border-image-width属性用于指定使用多厚的边框来承载被裁剪后的图像</strong></li>\n</ul>\n<div class=\"language-css\" data-ext=\"css\"></div><ul>\n<li>该属性的值可以是具体的数值也可以是百分比,默认是1,该属性同样也是包含上右下左的复合属性,该属性有一\n个值是auto,如果指定了，宽度是相应的image-slice的内在宽度或高度</li>\n<li><strong>border-image-outside属性指定边框图像向外扩展所定义的数值</strong>,默认值是0的长度,这个值可以用具体的带单\n位的数值和用纯数字来作为值,纯数字代表border-width的倍数</li>\n<li><strong>border-image-repeat属性用于指定边框图像地填充方式</strong> ,默认值为stretch,拉伸图像来填充区域</li>\n</ul>\n<div class=\"language-css\" data-ext=\"css\"></div><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>stretch</td>\n<td>默认值。拉伸图像来填充区域</td>\n</tr>\n<tr>\n<td>repeat</td>\n<td>平铺（repeated）图像来填充区域。</td>\n</tr>\n<tr>\n<td>round</td>\n<td>类似 repeat 值。如果无法完整平铺所有图像，则对图像进行缩放以适应区域。</td>\n</tr>\n<tr>\n<td>space</td>\n<td>类似 repeat 值。如果无法完整平铺所有图像，扩展空间会分布在图像周围</td>\n</tr>\n<tr>\n<td>initial</td>\n<td>将此属性设置为默认值。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>从父元素中继承该属性。</td>\n</tr>\n</tbody>\n</table>\n<p>**注:**border-collapse属性指定是否用做合成单一的边框,这个属性一般都是给表格使用的,默认值是separate</p>\n<h3> 4.4 盒子阴影</h3>\n<p><strong>box-shadow属性为是否显示盒子阴影</strong>,默认值是none没有阴影,这个属性的用法text-shadow用法基本一致</p>\n<p>有阴影box-shadow:水平偏移量 垂直偏移量 阴影模糊半径 阴影扩展半径 阴影颜色 可以在最后加上inset表示阴影是否是内阴影,默认是外阴影outset,阴影扩展是在原本阴影的上下左右再继续添加阴影,如果没有写阴影颜色,阴影颜</p>\n<p>色由盒子内容的颜色决定<strong>所以简写只用写前面3个</strong></p>\n<h3> 4.5 表现形式</h3>\n<h4> 4.5.1 display</h4>\n<p>**display属性,这个属性能从根本上改变盒子的存在方式,**常用的值有 none inline block inline-block以及flex(弹性盒子)</p>\n<h4> 4.5.2 visiblity</h4>\n<p>**visiblity属性,这个属性指定是否显示一个元素生成的元素框,**但是无论怎么设置原本的盒子都不会脱离文档流,依然会占据其本来的空间,默认值是visible可见的</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>visible</td>\n<td>默认值。元素是可见的。</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td>元素是不可见的。</td>\n</tr>\n<tr>\n<td>collapse</td>\n<td>当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 \"hidden\"。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应该从父元素继承 visibility 属性的值。</td>\n</tr>\n</tbody>\n</table>\n<h4> 4.5.3 opacity</h4>\n<p><strong>opacity属性设置一个元素的透明度</strong>,值为0到1,0为完全透明,1为正常显示,默认值是1</p>\n<p><strong>注意:</strong></p>\n<ol>\n<li>这个属性在ie8以及ie8以下的浏览器不起作用,但是ie浏览器有自己设置透明度的方式</li>\n<li>filter:alpha(opacity=num)这个属性能代替opacity在ie浏览器中生效,但是值是0到100,对应opacity的0到1</li>\n<li>如要要兼容ie8浏览器,可以两个属性都写上,应为其他浏览器不支持下方的属性,该属性相当于没有写</li>\n</ol>\n<p><strong>让盒子在页面中消失:</strong></p>\n<ul>\n<li>display:none能让一个盒子脱离文档流在一个页面中完全消失并且不可被选中</li>\n<li>visiblity:hidden能让一个盒子在页面中隐藏但是还是占据了原本的位置,并没有脱离文档流</li>\n<li>opacity:0能让一个盒子的透明度为0从而达到消失的效果,但是这个消失的效果并不好,因为还能够选中文字,当\n然也并没有脱离文档流</li>\n</ul>\n<h3> 4.6 BFC环境</h3>\n<p><strong>全称叫block formatting context块级格式化上下文,具有流体特性</strong></p>\n<p>**作用:**元素内部的标签无论发生什么情况都不会影响其本身的位置的值的计算</p>\n<p><strong>开启BFC环境的方式:</strong></p>\n<ul>\n<li>overflow值不为visible都能开启</li>\n<li>float的值不为none</li>\n<li>position的值为绝对和固定定位</li>\n<li>display的值为inline-block,flex,inline-flex等</li>\n</ul>\n<p><strong>常见用法:</strong></p>\n<ul>\n<li>阻止兄弟元素上下外边距的合并问题,具体可用一个大盒子包裹下方的盒子,然后让大盒子overflow:hidden开启\nBFC环境</li>\n<li>防止因子元素浮动而导致的父元素高度塌陷问题</li>\n<li>用作双栏式的页面布局,左边是固定宽度,右边是自适应的宽度,这种布局需要给左边的导航栏开启BFC,让左边的\n内容被隔离出来,类似于float,但是又占着原来的位置,左右两个部分相当于是inline-block的表现形式</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 5.背景</h2>\n<p><strong>background设置背景属性,该属性是一个复合属性</strong></p>\n<div class=\"language-css\" data-ext=\"css\"></div><h3> 5.1 background-color</h3>\n<p><strong>background-color属性设置元素的背景颜色</strong>，默认值是transparent透明色</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>color_name</td>\n<td>规定颜色值为颜色名称的背景颜色（比如 red）</td>\n</tr>\n<tr>\n<td>hex_number</td>\n<td>规定颜色值为十六进制值的背景颜色（比如 #ff0000）</td>\n</tr>\n<tr>\n<td>rgb_number</td>\n<td>规定颜色值为 rgb 代码的背景颜色（比如 rgb(255,0,0)。也可以使用rgba,最后一个控制背景颜色的透明度</td>\n</tr>\n<tr>\n<td>transparent</td>\n<td>默认。背景颜色为透明</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应该从父元素继承 background-color 属性的设置</td>\n</tr>\n</tbody>\n</table>\n<p><strong>元素背景的范围</strong></p>\n<p>background-color 属性为元素设置一种纯色。这种颜色会填充元素的内容、内边距和边框区域,扩展到元素边框的外边界(但不包括外边距)。如果边框有透明部分(如虚线边框),会透过这些透明部分显示出背景色。</p>\n<p><strong>渐变色背景(这里是线性渐变,还有一种径向渐变)</strong>(IE基本不支持渐变色,要作渐变色最好还是用图片)</p>\n<p><strong>渐变颜色由颜色渐变函数linear-gradient()设置</strong>,第一个参数是要渐变的方向,如果不写就是默认方向,后面可以跟上任意颜色参数，同时<strong>在两个颜色参数中间</strong>(一定要是中间)还可以跟上一个百分比的参数表示两个颜色间过渡区域的占比</p>\n<p><strong>渐变色有方向性,如果写了两种颜色默认是从上向下平方渐变,渐变的方向只能是左右,上下和对角方向或者指定一个度数</strong></p>\n<p>为了创建一个线性渐变,需要设置一个起始点和一个方向（指定为一个角度）的渐变效果,还需要定义终止色,,所以必须最少指定至少两种，当然也会可以指定更多的颜色去创建更复杂的渐变效果。</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>to top</td>\n<td>从下往上渐变</td>\n</tr>\n<tr>\n<td>to bottom</td>\n<td>从上往下渐变</td>\n</tr>\n<tr>\n<td>to left</td>\n<td>从右往左渐变</td>\n</tr>\n<tr>\n<td>to right</td>\n<td>从左往右渐变</td>\n</tr>\n<tr>\n<td>to top left</td>\n<td>从右下往左上渐变</td>\n</tr>\n<tr>\n<td>to top right</td>\n<td>从左上往右下渐变</td>\n</tr>\n<tr>\n<td>to bottom left</td>\n<td>从右上往左下渐变</td>\n</tr>\n<tr>\n<td>to bottom left</td>\n<td>从左上往右下渐变</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-css\" data-ext=\"css\"></div><p><strong>注意:渐变函数linear-gradient()占用的是background-image属性</strong></p>\n<h3> 5.2 background-image</h3>\n<p>**background-image属性设置背景图像,**默认值是none,如要要设置背景图片和border-image一样用url(\"\")中间写图片的地址来设置</p>\n<h3> 5.3 background-repeat</h3>\n<p>**background-repeat属性设置背景图片是否重复,**默认值为repeat,意为水平和垂直方向都要重复,其它值有</p>\n<p>no-repeat只展示一次背景图片</p>\n<p>repeat-x只在水平方向重复</p>\n<p>repeat-y只在垂直方向重复</p>\n<h3> 5.4 background-attachment</h3>\n<p>**background-attachment属性设置背景图像是否固定或者随着页面的其余部分滚动,**默认值是scroll，背景图片会随着页面其余部分滚动而滚动,如果要让背景图片不移动,设置次属性为fixed</p>\n<h3> 5.5 background-position</h3>\n<p>**background-positon设置背景图像的起始位置,**默认的起始值是0% 0%,也就是在盒子的左上角位置</p>\n<p>这个属性的值可以是具体的像素数值,也可以是百分比,还可以用一些表示方位的关键词来写</p>\n<ul>\n<li>如果是用数值或者百分比来写,有两个值,第一个值是水平位置,第二个值是垂直位置,如果只规定了一个值,那么\n第二个值默认是50%,可以数值和百分号一起使用</li>\n<li>如果用关键词来写,具体的关键词有top left right bottom center,也是第一个值表示水平位置,第二个词表示垂\n直位置，如果只写了一个值,那么第二个值是center</li>\n</ul>\n<h3> 5.6 background-size</h3>\n<p><strong>background-size属性规定背景图像的尺寸</strong>,默认值是auto</p>\n<p><strong>background-size:长度/百分比/auto/cover/contain</strong></p>\n<p>auto真实大小 cover将背景图像等比例缩放到完全覆盖容器,直到将容器填满,不会让图片变形,有可能超出容器 contain将图像等比拉伸，直到高度或者宽度将容器填满且始终包含在容器内</p>\n<p><strong>background-size实际上是控制两个地方,宽和高,如果只写一个就是指控制宽,而高自动为auto</strong></p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>length</td>\n<td>设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 \"auto\"。</td>\n</tr>\n<tr>\n<td>percentage</td>\n<td>以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 \"auto\"。</td>\n</tr>\n<tr>\n<td>cover</td>\n<td>把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。</td>\n</tr>\n<tr>\n<td>contain</td>\n<td>把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。</td>\n</tr>\n</tbody>\n</table>\n<h3> 5.7 background-origin</h3>\n<p>**background-origin 属性规定background-position属性相对于什么位置来定位,**默认值是padding-box,从padding位置开始当做背景参考原点</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>padding-box</td>\n<td>背景图像相对于内边距框来定位。</td>\n</tr>\n<tr>\n<td>border-box</td>\n<td>背景图像相对于边框盒来定位。</td>\n</tr>\n<tr>\n<td>content-box</td>\n<td>背景图像相对于内容框来定位。</td>\n</tr>\n</tbody>\n</table>\n<h3> 5.8 background-clip</h3>\n<p>**background-clips属性背景的绘制区域,**默认值是border-box,在border作为绘制背景图片的区域,其实背景图片的</p>\n<p>border区域一直有背景图,但是如果border的样式是实现的话就看不见图片,如果是点线等中空的线条的话就能看见</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>border-box</td>\n<td>背景被裁剪到边框盒。</td>\n</tr>\n<tr>\n<td>padding-box</td>\n<td>背景被裁剪到内边距框。</td>\n</tr>\n<tr>\n<td>content-box</td>\n<td>背景被裁剪到内容框。</td>\n</tr>\n</tbody>\n</table>\n<h3> 5.9 多背景图片</h3>\n<p>可以多张背景图片一起组合作为背景图,每一个背景图中间用逗号隔开</p>\n<p>语法:</p>\n<div class=\"language-css\" data-ext=\"css\"></div><h3> 5.10 filter</h3>\n<p><strong>filter 属性定义了元素(通常是&lt; img&gt;)的可视效果</strong></p>\n<div class=\"language-css\" data-ext=\"css\"></div><p><strong>注意:</strong></p>\n<ul>\n<li>滤镜通常使用百分比 (如：75%), 也可以使用小数来表示 (如：0.75)</li>\n<li>使用空格可以分隔多个滤镜</li>\n<li>一般可以使用blur()来设置毛玻璃效果</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Filter</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>none</td>\n<td>默认值，没有效果。</td>\n</tr>\n<tr>\n<td>blur(<em>px</em>)</td>\n<td>给图像设置高斯模糊。\"radius\"一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起， 所以值越大越模糊；  如果没有设定值，则默认是0；这个参数可设置css长度值，但不接受百分比值。</td>\n</tr>\n<tr>\n<td>brightness(<em>%</em>)</td>\n<td>给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</td>\n</tr>\n<tr>\n<td>contrast(<em>%</em>)</td>\n<td>调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</td>\n</tr>\n<tr>\n<td>drop-shadow(<em>h-shadow v-shadow blur spread color</em>)</td>\n<td>给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 函数接受(在CSS3背景中定义)类型的值，除了\"inset\"关键字是不允许的</td>\n</tr>\n<tr>\n<td>grayscale(<em>%</em>)</td>\n<td>将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</td>\n</tr>\n<tr>\n<td>hue-rotate(<em>deg</em>)</td>\n<td>给图像应用色相旋转。\"angle\"一值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。</td>\n</tr>\n<tr>\n<td>invert(<em>%</em>)</td>\n<td>反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。</td>\n</tr>\n<tr>\n<td>opacity(<em>%</em>)</td>\n<td>转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。 若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。</td>\n</tr>\n<tr>\n<td>saturate(<em>%</em>)</td>\n<td>转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。 若值未设置，值默认是1。</td>\n</tr>\n<tr>\n<td>sepia(<em>%</em>)</td>\n<td>将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</td>\n</tr>\n<tr>\n<td>url()</td>\n<td>URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。例如：<code>filter: url(svg-url#element-id)</code></td>\n</tr>\n<tr>\n<td>initial</td>\n<td>设置属性为默认值</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>从父元素继承该属性</td>\n</tr>\n</tbody>\n</table>\n<h2> 6.CSS盒子布局和定位</h2>\n<h3> 6.1 position</h3>\n<p><strong>position定位属性指定一个元素的定位方法的类型</strong>,默认值是static静态定位,遵循正常的文档流</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>absolute</td>\n<td>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位，一个绝对定位元素会忽略父元素的padding属性,元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。</td>\n</tr>\n<tr>\n<td>fixed</td>\n<td>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。</td>\n</tr>\n<tr>\n<td>relative</td>\n<td>生成相对定位的元素，相对于其正常位置进行定位,依然会占据原本文档流的位置</td>\n</tr>\n<tr>\n<td>static</td>\n<td>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td>\n</tr>\n<tr>\n<td>sticky</td>\n<td>粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应该从父元素继承 position 属性的值。</td>\n</tr>\n<tr>\n<td>initial</td>\n<td>设置该属性为默认值</td>\n</tr>\n</tbody>\n</table>\n<p><strong>在上述值中:只有absolute,fixed和sticky在超出滚动距离的时候才会脱离文档流,脱离文档流的盒子不会影响到其他盒子的表现形式</strong></p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>在使用top,left,right,bottom这些方位词时,原则上是只写top和bottom，left和right中的一个,另外一个默认是\nauto，如果都写了那么相互的拉伸力就会相互抵消,从而达不到想要的效果</li>\n<li>绝对定位(absolute)默认是相对于body来定位的,如果要让子元素相对于父元素进行定位,必须在父元素上同样\n设置定位属性(静态定位除外),如果父元素没有设置定位,那么就会以最近的定位元素为参考点,以此类推最会会\n以body为参考点，不会因为是 某个元素的子元素就以它为参考点</li>\n<li>绝对定位如果是以body作为参考点,那么是以网页的首屏作为参考点,就是刚刚进来时看见的页面,而不是以整个\n网页的宽度和高度作为参考点</li>\n<li>.默认情况下定位流的元素会盖住标准流的元素</li>\n<li>默认情况下定位流的元素后面编写的会盖住前面编写的</li>\n<li>所有绝对定位的盒子的表现形式都会变为block</li>\n</ul>\n<p><strong>通过绝对定位让子元素在父元素里面水平垂直居中</strong></p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-html\" data-ext=\"html\"></div><h3> 6.2 z-index</h3>\n<p><strong>z-index分层属性设置元素的堆叠顺序</strong>,使得拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面,默认的值为auto,元素在当前层叠上下文中的层叠级别是0.不会创建新的局部上下文</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>auto</td>\n<td>默认。堆叠顺序与父元素相等。</td>\n</tr>\n<tr>\n<td><em>number</em></td>\n<td>设置元素的堆叠顺序。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应该从父元素继承 z-index 属性的值。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意:</strong></p>\n<ul>\n<li>z-index有从父现象，如果父元素没有设置z-index，那么子元素谁的层级大谁就显示，如果父元素设置的z-index，那么子元素的z-index就会失效，而会跟随父元素的z-index</li>\n<li>z-index 仅能在定位元素上生效,在static定位上不生效</li>\n<li>所有元素默认值是auto,也是0层,正常情况下相同层级的元素后面的可以覆盖掉前面的,设置z-index的值为数值,\n数值越大层级越高,可以有负值,负值越大层级越小</li>\n</ul>\n<h3> 6.3 float</h3>\n<p>**float属性定义元素在哪个方向浮动,**默认值是none,元素不浮动</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>left</td>\n<td>元素向左浮动。</td>\n</tr>\n<tr>\n<td>right</td>\n<td>元素向右浮动。</td>\n</tr>\n<tr>\n<td>none</td>\n<td>默认值。元素不浮动，并会显示在其在文本中出现的位置。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应该从父元素继承 float 属性的值。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：</strong></p>\n<ul>\n<li>浮动的元素会脱离正常的文档流,如果是子元素在父元素里面浮动,父元素不设置高可能会造成高度塌陷的问题</li>\n<li>浮动的元素可以与浮动的元素进行操作,支持margin等值</li>\n<li>浮动流和定位流选择其中一个使用,最好不要同时使用</li>\n<li>假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足\n够的空间为止</li>\n</ul>\n<h3> 6.4 clear</h3>\n<p>clear属性定义了元素的哪边上不允许出现浮动元素,这个属性常用做清除浮动,默认值为none，允许出现浮动元素</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>left</td>\n<td>在左侧不允许浮动元素。</td>\n</tr>\n<tr>\n<td>right</td>\n<td>在右侧不允许浮动元素。</td>\n</tr>\n<tr>\n<td>both</td>\n<td>在左右两侧均不允许浮动元素。</td>\n</tr>\n<tr>\n<td>none</td>\n<td>默认值。允许浮动元素出现在两侧。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应该从父元素继承 clear 属性的值。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：</strong></p>\n<ul>\n<li><strong>因为不允许出现浮动元素,但是被设置了浮动的元素已经变成块级元素,所以依然会得到块级元素的换行特性</strong></li>\n<li><strong>如果上一层是float元素，用了clear属性的元素的margin属性将会失效</strong></li>\n</ul>\n<p><strong>清除浮动的六种方法</strong></p>\n<ul>\n<li>给上一个父元素盒子设置高度</li>\n<li>clear清除浮动</li>\n<li>外墙法清除浮动:在两个盒子中间额外添加一个块级元素，并且设置clear:both\n**注意:**只有第二个元素能用margin-top,第一个元素不能用margin-bottom来隔开距离,所以一般隔开距离的方式\n是添加中间的div的高度</li>\n<li>内墙法清除浮动:在第一个盒子最后一个元素后面添加一个块级元素并且设置clear:both\n**注意:**该方法第一第二个盒子都可以使用margin属性</li>\n<li>为第一个盒子添加伪元素(类似内墙法),但不占用内存空间,推荐使用</li>\n</ul>\n<div class=\"language-css\" data-ext=\"css\"></div><ul>\n<li>在前一个盒子里面使用overflow:hidden,给这个盒子添加BFC环境\n**拓展:**也可以利用oveflow:hidden来让外面的盒子不设置边框的情况下里面的盒子使用margin-top的时候不会\n将外面的盒子一起顶下来</li>\n</ul>\n<p><strong>不定宽度的块状元素有三种方法居中</strong></p>\n<ul>\n<li>加入 table 标签</li>\n</ul>\n<div class=\"language-html\" data-ext=\"html\"></div><ul>\n<li>设置 display: inline 方法:与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置</li>\n<li>设置 position:relative 和 left:50%;利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的\n如:给父元素设置float:left;position:relative;left:50%;给子元素设置position:relative;left:-50%</li>\n</ul>\n<h2> 7.过渡模块</h2>\n<p>**transition过渡属性规定某一个要变化的属性从初始值到变化值的延迟效果,**该属性是一个复合属性</p>\n<p><strong>复合属性语法:</strong></p>\n<div class=\"language-css\" data-ext=\"css\"></div><p><strong>过渡效果的要素：</strong></p>\n<ul>\n<li>必须有属性变化</li>\n<li>必须告诉系统哪个属性需要执行过渡效果</li>\n<li>必须告诉系统过渡效效果持续时长</li>\n</ul>\n<p>上面的语法依次为:transition:过渡属性 过渡时长 过渡速度 延迟时间。可以省略后面两个参数，因为前面两个已经有了过渡的三要素</p>\n<p><strong>如果想给多个属性添加过渡效果,需要用逗号隔开</strong></p>\n<p>transition:过渡属性 过渡时长 过渡速度 延迟时间,过渡属性 过渡时长 过渡速度 延迟时间;</p>\n<h3> 7.1 过渡属性</h3>\n<p>**transition-property属性设置要过渡的属性,**默认值是all,也就是所有变化的属性,需要哪些元素的哪些属性发生改变,就在transition里面设置哪个属性,如果所有的属性要变化的时间,速度和延迟时间等都写了并且相同,可以直接写all代替</p>\n<p><strong>如果有多个属性要过渡:transition-property:属性1,属性2;</strong></p>\n<h3> 7.2 过渡时间</h3>\n<p>**transition-duration属性设置要实现过渡效果所用的时间,**单位为s或者ms,如果不设置时间默认是0</p>\n<p><strong>如果有多个属性要过渡:transition-duration:时间1,时间2;</strong></p>\n<h3> 7.3 过渡速度</h3>\n<p>**transition-timing-function属性设置在相同的时间内过渡是通过怎样的方式进行的,**默认的值是ease先慢后快</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>linear</td>\n<td>规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。</td>\n</tr>\n<tr>\n<td>ease</td>\n<td>规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。</td>\n</tr>\n<tr>\n<td>ease-in</td>\n<td>规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。</td>\n</tr>\n<tr>\n<td>ease-out</td>\n<td>规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。</td>\n</tr>\n<tr>\n<td>ease-in-out</td>\n<td>规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。</td>\n</tr>\n<tr>\n<td>cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>\n<td>在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注:过渡速度一般都用的匀速linear,如果想用一些特别的速度模式,用cubil-bezier(贝塞尔曲线)来写出自己想要的运动模式,这个一般可以直接在百度上搜索然后调试出来</strong></p>\n<h3> 7.4 过渡延迟</h3>\n<p><strong>transition-delay属性设置过渡的延迟时间</strong>,告诉系统延迟多少秒之后才开始进行过渡动画，可以通过设置这个来达到多个盒子实现跑火车的效果</p>\n<p><strong>不支持过渡的属性:display:none</strong></p>\n<p>让一个元素消失的过渡一般用透明opacity来做,但是这个属性设置之后可以选中文本.所以一般配合visibility:hidden来使用,至于为什么直接用这个属性来实现消失的过渡效果,因为这个属性的过渡效果很奇怪,元素其他过渡完成后才突然消失,虽然不像display:none一样直接开始就消失,但是也没有过渡效果产生</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>一般过渡效果都是具体的值来变化的,这样才最适合,当一个元素设定absolute时,如果不设置初始位置，那么默\n认的初始位置是上下左右全为auto而不是0,所以如果不设置初始位置,过渡变化absolute时不会支持过渡属性</li>\n<li>要写过渡元素时，先不要管过渡属性，而是先写基本界面，修改我们认为需要修改的属性，最后再反过来修改\n过渡元素</li>\n</ul>\n<h2> 8.动画模块</h2>\n<p>**animation动画属性规定元素呈现自动运行的过渡效果,**该属性是一个复合属性</p>\n<p>**复合属性语法:**animation:动画名称 动画时长 动画运动速度 延迟时间 执行次数 往返动画</p>\n<div class=\"language-css\" data-ext=\"css\"></div><p><strong>动画三要素</strong></p>\n<ul>\n<li>告诉系统执行哪个动画用animation-name:run(名称随便取)确定动画名称</li>\n<li>告诉系统我们需要创建一个名称叫做run的动画</li>\n<li>告诉系统动画持续的时长如:animation-duration:3s;</li>\n</ul>\n<h3> 8.1 动画名称</h3>\n<p><strong>animation-name属性为@keyframes(关键帧)动画规定名称</strong>,只有通过这个名称才能将元素与动画联系起来</p>\n<p><strong>创建一个关键帧:</strong></p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 8.2 动画时长</h3>\n<p>**animation-duration属性定义动画完成一个周期所需要的时间,**单位为s或者ms</p>\n<h3> 8.3 动画运动速度</h3>\n<p>**animation-timing-function属性规定动画的速度曲线,**默认值是ease,先慢后快</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>linear</td>\n<td>规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。</td>\n</tr>\n<tr>\n<td>ease</td>\n<td>规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。</td>\n</tr>\n<tr>\n<td>ease-in</td>\n<td>规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。</td>\n</tr>\n<tr>\n<td>ease-out</td>\n<td>规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。</td>\n</tr>\n<tr>\n<td>ease-in-out</td>\n<td>规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。</td>\n</tr>\n<tr>\n<td>cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>\n<td>在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</td>\n</tr>\n</tbody>\n</table>\n<h3> 8.4 动画延迟</h3>\n<p>**animation-delay 属性定义动画何时开始,**单位为s或者ms,这个动画延迟是触发动画后离正式进行动画的时间差</p>\n<p><strong>注意:这个属性的值允许负值,如:-2s使动画马上开始,但跳过 2 秒进入动画,而过渡不能有负值。</strong></p>\n<h3> 8.5 动画播放次数</h3>\n<p>**animation-iteration-count属性定义动画的播放次数,**默认值是1,代表动画值进行一次</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><em>n</em></td>\n<td>定义动画播放次数的数值。</td>\n</tr>\n<tr>\n<td>infinite</td>\n<td>规定动画应该无限次播放。</td>\n</tr>\n</tbody>\n</table>\n<h3> 8.6 动画进行方向</h3>\n<p><strong>animation-direction属性是否应该轮流反向播放动画</strong>,默认值是normal.动画正常播放</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>normal</td>\n<td>默认值。动画按正常播放</td>\n</tr>\n<tr>\n<td>reverse</td>\n<td>动画反向播放</td>\n</tr>\n<tr>\n<td>alternate</td>\n<td>动画先正向播放再反向播放</td>\n</tr>\n<tr>\n<td>alternate-reverse</td>\n<td>动画先反向播放再正向播放</td>\n</tr>\n</tbody>\n</table>\n<h3> 8.7 动画状态</h3>\n<p>animation-play-state属性告诉系统当前动画的进行状态,默认值为running执行动画</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>paused</td>\n<td>指定暂停动画,通常用做hover效果等悬停暂停效果</td>\n</tr>\n<tr>\n<td>running</td>\n<td>指定正在运行的动画</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注:动画有三个状态:等待状态 执行状态 结束状态</strong></p>\n<h3> 8.8 动画应用样式</h3>\n<p>animation-fill-mode属性规定当动画不播放时(当动画完成时，或当动画有一个延迟未开始播放时),要应用到元素的样式，默认值是none,不应用任何样式</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>none</td>\n<td>默认值。动画在动画执行之前和之后不会应用任何样式到目标元素。</td>\n</tr>\n<tr>\n<td>forwards</td>\n<td>在动画结束后,动画会回到本身属性设置的地方,这个属性让元素保持最后一帧100%是的位置和样式</td>\n</tr>\n<tr>\n<td>backwards</td>\n<td>在动画开始前(在动画延迟时间里或者动画本身的原始状态和第一帧的状态不一样时),应用第一帧0%的样式</td>\n</tr>\n<tr>\n<td>both</td>\n<td>相当于同时应用了forwards和backwards</td>\n</tr>\n</tbody>\n</table>\n<p><strong>过渡动画与动画之间的异同：</strong></p>\n<p><strong>1.不同点</strong></p>\n<p>过渡必须认为的触发才会执行动画  动画不需要人为的就可以执行</p>\n<p><strong>2.相同点</strong></p>\n<p>过渡和动画都是用来给元素添加动画的,过渡和动画都是系统新增的一些属性,过渡和动画都需要满足三要素才会有动画效果</p>\n<h2> 9.2D/3D转换模块</h2>\n<h3> 9.1 transform</h3>\n<p><strong>transform属性意为变化,通过这个属性可以对一个盒子进行2D\\3D形式的变化</strong></p>\n<h4> 9.1.1 rotate</h4>\n<p>rotate旋转,这个值控制盒子是否进行2D旋转,可以接收一个参数里面的值需要带单位,支持负值</p>\n<p><strong>deg度数 turn圈 rad弧度 grad梯度</strong>  比如:rotate(45deg)就是顺时针旋转45度,rotate(45deg)就是逆时针旋转45度</p>\n<p><strong>旋转中心</strong></p>\n<p><strong>默认情况下旋转的中心是元素自身的中心点</strong>,如正方形就是两条对角线的交界处</p>\n<p>如果要改变旋转的中心点,可以通过形变中心点属性transform-origin来修改参考点</p>\n<p><strong>transform-origin:水平 垂直</strong>,里面的坐标是相对于自身元素的</p>\n<p>比如transform-origin:0 0代表元素自身的左上角</p>\n<p><strong>取值的三种形式:</strong></p>\n<ul>\n<li>具体像素,只有3DZ轴旋转的时候才支持,2D旋转不支持具体像素</li>\n<li>百分比,比如默认的是宽度和高度的50%处 写作 50% 50%</li>\n<li>特殊关键字,如left right top bottom center等</li>\n</ul>\n<p><strong>默认情况下所有元素围绕Z轴旋转</strong>，也就是transform:rotateZ(),想围绕那个轴旋转,只用在rotate后添加想要旋转的轴即可,但是如果要向绕X和Y轴旋转，虽然在2D的情况下也能用这个值,但是看出来很怪异,所以在2D情况下一般都是遵循默认情况</p>\n<h4> 9.1.2 skew</h4>\n<p>skew倾斜,让元素产生2D扭曲,这个值可以接收2个参数,第一个是在x轴上的倾斜,第二个参数是y轴,值的单位是deg,控制x轴倾斜视角上呈现的是左右向两边拉动,高度变小,y轴视角上时上下向两边拉动,宽度变小,最终使元素呈现扭曲的样式,最后可能会扭曲消失</p>\n<div class=\"language-css\" data-ext=\"css\"></div><h4> 9.1.3 translate</h4>\n<p>translate位移,这个值可以接受两个参数(x,y),其中x和y分别代表x轴和y轴,意为水平和垂直方向，如果只写一个参数,只会对x轴起作用</p>\n<div class=\"language-css\" data-ext=\"css\"></div><p><strong>也可以单独的只设置x轴或者y轴方向上的位移</strong></p>\n<ul>\n<li>translateX,这个值只接收一个参数,就是水平方向上的位移</li>\n</ul>\n<div class=\"language-css\" data-ext=\"css\"></div><ul>\n<li>translateY,这个值只接收一个参数,就是垂直方向上的位移</li>\n</ul>\n<div class=\"language-css\" data-ext=\"css\"></div><ul>\n<li>translateZ，同上, 定义3D之后才用translateZ,这时translateX等就不是2D面上的偏移了,而是在3D的坐标轴上\n偏移</li>\n</ul>\n<div class=\"language-css\" data-ext=\"css\"></div><p><strong>注意:</strong></p>\n<ul>\n<li>因为可以在transform中写入不同的2D变化,中间只需要用空格隔开,所以如果旋转了再平移,平移的坐标系就会\n发生改变,平移的坐标系应为旋转后会修改坐标系\n<strong>所以如果要多个一起写,translate放在最前面</strong></li>\n<li>位移后实际上还是占据了原来的位置,这一点和相对定位类似,但是比相对定位简单一点</li>\n<li>这个的值可以是具体的值也可以是百分比,这个百分比是相对自身长度或高度的百分比,不是父元素的</li>\n<li>位移的方向计算方式和background-position一样,都是以右和下为正方向,上和左为负方向</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 9.1.4 scale</h4>\n<p>scale缩放,将一个元素缩放为原来的多少倍数,可以接受两个参数,第一个参数是对水平方向进行缩放,第二个参数是对垂直方向进行缩放,默认是scale(1,1),值为0到正无穷大的数字,值为0到1是缩小(值为0是没有缩放),值为1到正无穷是放大,如果水平和垂直的缩放一样,可以只写一个参数</p>\n<div class=\"language-css\" data-ext=\"css\"></div><p>注意:正常情况下scale中传入的参数为负值应该是没有用的,但是在这里传入负值的样子会向电磁感应一样,如果传入的是-1会以上方为中心绕x轴一圈反向展示</p>\n<h3> 9.2 3D转换模块</h3>\n<h4> 9.2.1 perspective</h4>\n<p>**perspective为透视属性,定义 3D 元素距视图的距离,**单位为px,默认值是none,与单位为0相同,该属性允许用户改变3D 元素查看 3D 元素的视图。</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li><strong>当为元素定义 perspective 属性时,其子元素会获得透视效果,而不是元素本身</strong>。在需要呈现效果元素的父元素或祖先元素中加一个perspective属性,就能呈现近大远小效果,给人带来3D的视觉感受\n<strong>像素的数值是元素距离视图的距离</strong>,若为10px则效果特别明显，若为10000px则基本没变化，因为距离太远，具体的值需要自己进行调试\n<strong>注意:这个属性不兼容所有浏览器,如果用chrome需要用-webkit-perspective</strong></li>\n<li>perspective 属性只影响 3D 转换元素</li>\n<li>这个元素最好与perspective-origin 属性一起使用,这样就能改变3D元素的底部位置</li>\n</ul>\n<h4> 9.2.2 perspective-origin</h4>\n<p>**perspective-origin属性定义 3D 元素所基于的x轴和y轴,**该属性允许用户改变3D元素的底部位置,,和</p>\n<p>transform-origin属性一样都是有两个参数x轴和y轴,默认值为50% 50%,也就是x和y轴的中间位置</p>\n<p><strong>取值的三种形式:</strong></p>\n<ul>\n<li>具体像素,因为本来就是3D状态,支持具体的像素值</li>\n<li>百分比,比如默认的是宽度和高度的50%处 写作 50% 50%</li>\n<li>特殊关键字,如left right top bottom center等</li>\n</ul>\n<h4> 9.2.3 transform-style</h4>\n<p>transform-style属性规定如何在 3D 空间中呈现被嵌套的元素,默认值为flat,子元素将不保留其 3D 位置。</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>flat</td>\n<td>子元素将不保留其 3D 位置。</td>\n</tr>\n<tr>\n<td>preserve-3d</td>\n<td>子元素将保留其 3D 位置。</td>\n</tr>\n</tbody>\n</table>\n<p>**注意：**该属性必须与transform属性一起使用</p>\n<h4> 9.2.4 backface-visibility</h4>\n<p>backface-visibility属性定义当元素不面向屏幕时是否可见,默认值是visible,显示背面是可见的,该属性通常用在旋转时不想要看见元素背面</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>visible</td>\n<td>背面是可见的。</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td>背面是不可见的。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>企业开发的正方体竖直轮转</strong>按照上 后 下 前的顺序做每一个边(因为左右两个边其实可以不呈现出来)**,假如父元素的厚度为200px</p>\n<p>transform:rotateX(90deg/180deg/270deg/360deg)(里面的角度分别对应了上后下前的顺序) translateZ(100px)</p>\n<p>(里面的数字是父元素的一半厚度，因为默认这些子元素是在父元素的中间）</p>\n<p>最后只用给这个正方体的父元素设置3D视角就可以了</p>\n<p><strong>扩展:</strong></p>\n<p>要做长方体只用把上 后 下 前四个面用transform:scale扩大(只扩大长宽,不扩大正方体的厚度),左右再多移动100px</p>\n<h2> 10 Flex布局</h2>\n<h3> 10.1 基本用法</h3>\n<p><strong>弹性盒子由display申明,通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器</strong>,弹性容器内包含了</p>\n<p>一个或多个弹性子元素</p>\n<p><strong>设置弹性盒子时需要用到的属性:</strong></p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>display</td>\n<td>指定 HTML  元素盒子类型。</td>\n</tr>\n<tr>\n<td>flex-direction</td>\n<td>指定了弹性容器中子元素的排列方式</td>\n</tr>\n<tr>\n<td>justify-content</td>\n<td>设置弹性盒子元素在主轴（横轴）方向上的对齐方式。</td>\n</tr>\n<tr>\n<td>align-items</td>\n<td>设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。</td>\n</tr>\n<tr>\n<td>flex-wrap</td>\n<td>设置弹性盒子的子元素超出父容器时是否换行。</td>\n</tr>\n<tr>\n<td>align-content</td>\n<td>修改  flex-wrap 属性的行为，类似align-items, 但不是设置子元素对齐，而是设置行对齐</td>\n</tr>\n<tr>\n<td>flex-flow</td>\n<td>flex-direction  和 flex-wrap 的简写</td>\n</tr>\n<tr>\n<td>order</td>\n<td>设置弹性盒子的子元素排列顺序。</td>\n</tr>\n<tr>\n<td>align-self</td>\n<td>在弹性子元素上使用。覆盖容器的  align-items 属性。</td>\n</tr>\n<tr>\n<td>flex</td>\n<td>设置弹性盒子的子元素如何分配空间,下面三个属性的简写。</td>\n</tr>\n<tr>\n<td>flex-grow</td>\n<td>定义项目的放大比例</td>\n</tr>\n<tr>\n<td>flex-shrink</td>\n<td>定义项目的缩小比例</td>\n</tr>\n<tr>\n<td>flex-basis</td>\n<td>定义项目对空间的分配行为</td>\n</tr>\n</tbody>\n</table>\n<h3> 10.2  父元素设置项</h3>\n<h4> 10.2.1 flex-direction</h4>\n<p><strong>flex-direction属性定义弹性盒子中项目的主轴方向</strong>,弹性盒模型将盒子中的内容通过主轴和侧轴进行显示,主轴默</p>\n<p>认是水平从左向右的,侧轴默认垂直从上到下</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>row</td>\n<td>默认值。灵活的项目将水平显示，正如一个行一样。</td>\n</tr>\n<tr>\n<td>row-reverse</td>\n<td>与 row  相同，但是以相反的顺序。</td>\n</tr>\n<tr>\n<td>column</td>\n<td>灵活的项目将垂直显示，正如一个列一样。</td>\n</tr>\n<tr>\n<td>column-reverse</td>\n<td>与 column  相同，但是以相反的顺序。</td>\n</tr>\n<tr>\n<td>initial</td>\n<td>设置该属性为它的默认值。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>从父元素继承该属性。</td>\n</tr>\n</tbody>\n</table>\n<h4> 10.2.2 justify-content</h4>\n<p><strong>justify-content 用于设置或检索弹性盒子元素在主轴方向上的对齐方式</strong>，默认值是flex-start,让项目位于弹性盒子的开头</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>flex-start</td>\n<td>默认值。项目位于容器的开头</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>项目位于容器的结尾。</td>\n</tr>\n<tr>\n<td>center</td>\n<td>项目位于容器的中心。</td>\n</tr>\n<tr>\n<td>space-between</td>\n<td>项目位于各行之间留有空白的容器内。先将盒子的一行的两端占据,再将剩下的空间平分</td>\n</tr>\n<tr>\n<td>space-around</td>\n<td>项目位于各行之前、之间、之后都留有空白的容器内。将盒子的一行完全平分</td>\n</tr>\n<tr>\n<td>initial</td>\n<td>设置该属性为它的默认值</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>从父元素继承该属性</td>\n</tr>\n</tbody>\n</table>\n<h4> 10.2.3 align-items</h4>\n<p>**align-items属性定义了项目在侧轴上的对齐方式(algin-items主要支持单行项目),**默认值是stretch,当子元素没有在侧轴方向定义宽或高的具体长度或者长度为auto时拉伸子元素的宽度或高度到整个侧轴的长度</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>stretch</td>\n<td>默认。  拉伸元件以适应容器。</td>\n</tr>\n<tr>\n<td>center</td>\n<td>中心元素在容器内。</td>\n</tr>\n<tr>\n<td>flex-start</td>\n<td>位置元素在容器的开头。</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>位置元素在容器的末端。</td>\n</tr>\n<tr>\n<td>baseline</td>\n<td>位置元素在容器的文本基线。将子元素类的文字对齐</td>\n</tr>\n<tr>\n<td>initial</td>\n<td>设置为默认值。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>从其父元素继承此属性。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意:如果align-items的值表示默认值stretch而且子元素又没有给具体的宽高,它的大小由里面的内容撑开</strong></p>\n<h4> 10.2.4 flex-wrap</h4>\n<p><strong>flex-wrap属性规定了flex盒子在主轴上单行超出是否换行</strong>,默认值是nowrap不换行</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>nowrap</td>\n<td>默认值。规定灵活的项目不拆行或不拆列。</td>\n</tr>\n<tr>\n<td>wrap</td>\n<td>规定灵活的项目在必要的时候拆行或拆列。</td>\n</tr>\n<tr>\n<td>wrap-reverse</td>\n<td>规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。</td>\n</tr>\n<tr>\n<td>initial</td>\n<td>设置该属性为它的默认值。</td>\n</tr>\n<tr>\n<td>initial</td>\n<td>设置该属性为它的默认值。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意:</strong></p>\n\n<p><strong>注:上面两个属性用flex-flow代替的时候flex-direction写在前面,flex-wrap写在后面</strong></p>\n<h4> 10.2.5 align-content</h4>\n<p>**align-content定义了多行子元素在侧轴上的对齐方式,**默认值是strtch,效果和align-items的相同,只不过是多行子元素进行平分整个侧轴长度</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>stretch</td>\n<td>默认值。项目被拉伸以适应容器。</td>\n</tr>\n<tr>\n<td>center</td>\n<td>项目位于容器的中心。</td>\n</tr>\n<tr>\n<td>flex-start</td>\n<td>项目位于容器的开头。</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>项目位于容器的结尾。</td>\n</tr>\n<tr>\n<td>space-between</td>\n<td>项目位于各行之间留有空白的容器内。</td>\n</tr>\n<tr>\n<td>space-around</td>\n<td>项目位于各行之前、之间、之后都留有空白的容器内。</td>\n</tr>\n<tr>\n<td>initial</td>\n<td>设置该属性为它的默认值</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>从父元素继承该属性。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>align-items和align-content的异同:</strong></p>\n<ul>\n<li>align-items和align-content有相同的功能，不过不同点是align-items是用来让每一个单行的容器居中而不是让整个容器居中</li>\n<li>所以对于只有一行的flex元素，align-content是没有效果的，只有用align-items才能达到预期的效果</li>\n<li>如果是多行flex元素,至于使用align-content才能让所有的flex元素在侧轴方向上面有类似justify-content在主     轴上的居中效果,而使用align-items时两个flex元素间总是有间隙</li>\n</ul>\n<p><strong>上面是针对于整个容器的属性,现在是针对项目上的属性</strong></p>\n<h3> 10.3 子元素设置项</h3>\n<h4> 10.3.1 order</h4>\n<p>**order属性设置项目中的子元素在它那一行中主轴的排列顺序,**默认是每一个子元素都是0,数值越小排序越靠前</p>\n<p><strong>注:该属性接受负值,且接受的值是整数</strong></p>\n<h4> 10.3.2 flex-grow</h4>\n<p><strong>flex-grow属性设置项目中的子元素在主轴上还有剩余的空间的时候通过设置一个数字来获取对于剩余空间的占比</strong></p>\n<p>默认值是0</p>\n<p><strong>具体用法</strong>:会将所有子元素的flex-grow属性的数字加起来然后用各自的flex-grow的数字除以这个数就是每个子元素再分配得剩余空间大小的量</p>\n<p><strong>公式: 该元素分得剩余空间 = 该元素的flex-grow值 / 所有flex-grow值之和剩余空间大小</strong></p>\n<p><strong>注:该属性不接受负值,允许接受浮点数</strong></p>\n<h4> 10.3.3 flex-shrink</h4>\n<p>flex-shrink属性设置项目中的子元素在主轴上空间不足(这里flex-wrap没有设置为wrap)的时候,通过设置一个数字</p>\n<p>进行对自身比例的缩小从而使得flex-shrink为0的子元素保持其本身设置的大小,该属性的默认值也是0</p>\n<p><strong>具体用法</strong>:会将所有子元素的flex-shrink属性的数字加起来然后用各自的flex-shrink的数字除以这个数就是每个子元素对于超出弹性盒子容积空间占比要缩小的量</p>\n<p><strong>公式:该元素缩小空间=该元素的flex-shrink值/所有flex-shink值之和超出弹性盒子空间大小</strong></p>\n<p><strong>注:该属性不接受负值,允许接受浮点数</strong></p>\n<h4> 10.3.4 flex-basis</h4>\n<p>flex-basis属性定义项目对空间分配行为时,项目的实际大小(这个属性会和width和heigth等属性起冲突,在弹性盒子中有这个属性width或heigth将会无效),同时只要用这个属性设置了固定的大小,该元素就不会受到扩大或者收缩的影响</p>\n<p><strong>合法值：\"auto\"、\"inherit\" 或一个后跟 \"%\"、\"px\"、\"em\" 或任何其他长度单位的数字</strong></p>\n<p><strong>注意:</strong></p>\n<ul>\n<li><strong>如果该元素占据的那一行占满了弹性盒子长度,那么后面的元素会自动到下一行</strong></li>\n<li><strong>有这个属性的元素的最大长度不能超过弹性盒子长度</strong></li>\n</ul>\n<p><strong>注意:上面三个属性用flex代替的时候用flex-grow flex-shrink flex-basis 的顺序,默认值为0 1 auto</strong></p>\n<h4> 10.3.5 align-self</h4>\n<p><strong>align-self 属性定义flex子项单独在侧轴方向上的对齐方式</strong>,默认值是auto，继承父元素的align-items属性的值</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>auto</td>\n<td>默认值。元素继承了它的父容器的  align-items 属性。如果没有父容器则为 \"stretch\"。</td>\n</tr>\n<tr>\n<td>stretch</td>\n<td>元素被拉伸以适应容器。</td>\n</tr>\n<tr>\n<td>center</td>\n<td>元素位于容器的中心。</td>\n</tr>\n<tr>\n<td>flex-start</td>\n<td>元素位于容器的开头。</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>元素位于容器的结尾。</td>\n</tr>\n<tr>\n<td>baseline</td>\n<td>元素位于容器的基线上。</td>\n</tr>\n<tr>\n<td>initial</td>\n<td>设置该属性为它的默认值</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>从父元素继承该属性</td>\n</tr>\n</tbody>\n</table>\n<h2> 11. 响应式布局</h2>\n<h3> 11.1 响应式布局的引入</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 11.2 媒体查询</h3>\n<p><strong>media 查询可以针对不同的媒体类型或者不同的屏幕尺寸设置不同的样式</strong></p>\n<p><strong>@media常用于响应式页面的布局</strong></p>\n<p>@media在对媒体类型设置的时候一般都是screen,用于电脑屏幕,平板电脑,智能手机等，同时在设计screen尺寸样式的时候也是一般通过max-width和min-width来设置</p>\n<p><strong>max-width可以理解为宽度小于等于最大宽度的时候样式才生效,min-width可以理解为宽度大于等于最小宽度的时候样式才生效</strong></p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>注意:</strong></p>\n<p>在都设置的是最小宽度的时候,min-width按照从小到大的顺序写,在都设置的是最大宽度的时候,max-width按照从大到小的顺序写,这样写是为了后面写的到了合适的时候会覆盖前面的内容,如果写反了就会只有一种样式</p>\n<h3> 11.3 常用要素</h3>\n<h4> 11.3.1 媒体类型</h4>\n<table>\n<thead>\n<tr>\n<th>语法</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>all</td>\n<td>所有媒体</td>\n</tr>\n<tr>\n<td>braille</td>\n<td>盲文触觉设备</td>\n</tr>\n<tr>\n<td>embossed</td>\n<td>盲文打印机</td>\n</tr>\n<tr>\n<td>print</td>\n<td>手持设备</td>\n</tr>\n<tr>\n<td>projection</td>\n<td>打印预览</td>\n</tr>\n<tr>\n<td>screen</td>\n<td>彩色屏幕</td>\n</tr>\n<tr>\n<td>speech</td>\n<td>“听觉”类似的媒体设备</td>\n</tr>\n<tr>\n<td>tty</td>\n<td>不适用像素的设备</td>\n</tr>\n<tr>\n<td>tv</td>\n<td>电视</td>\n</tr>\n</tbody>\n</table>\n<h4> 11.3.2 媒体特性</h4>\n<p>min-width：分辨率宽度大于设置值的时候识别</p>\n<p>max-width：分辨率宽度小于设置值的时候识别</p>\n<p>orientation：portrait  ：竖屏</p>\n<p>orientation：landscape：横屏</p>\n<p>min-device-pixel-ratio：像素比</p>\n<h4> 11.3.3 关键字</h4>\n<p>and 连接媒体特性</p>\n<p>not 排除指定媒体类型</p>\n<p>only 指定某种特定的媒体类型</p>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "写在后面-对H5&CSS的补充",
      "url": "https://harryxiong24.github.io/zh/front-end/html-css/hint.html",
      "id": "https://harryxiong24.github.io/zh/front-end/html-css/hint.html",
      "summary": "[[TOC]] 浅谈父元素高度塌陷问题 文档流 文档流处在网页的最底层，它表示的是一个页面中的位置，我们所创建的元素默认都处在文档流中 元素在文档流中的特点： 块元素 1. 块元素在文档流中会独占一行，块元素会自上向下排列。 2. 块元素在文档流中默认宽度是父元素的100% 3. 块元素在文档流中的高度默认被内容撑开 内联元素 1. 内联元素在文档流中...",
      "content_html": "<h1> 写在后面-对H5&amp;CSS的补充</h1>\n\n<h2> 浅谈父元素高度塌陷问题</h2>\n<h3> 文档流</h3>\n<p>文档流处在网页的最底层，它表示的是一个页面中的位置，我们所创建的元素默认都处在文档流中</p>\n<p>元素在文档流中的特点：</p>\n<p><strong>块元素</strong></p>\n<ol>\n<li>\n<p>块元素在文档流中会独占一行，块元素会自上向下排列。</p>\n</li>\n<li>\n<p>块元素在文档流中默认宽度是父元素的100%</p>\n</li>\n<li>\n<p>块元素在文档流中的高度默认被内容撑开</p>\n</li>\n</ol>\n<p><strong>内联元素</strong></p>\n<ol>\n<li>内联元素在文档流中只占自身的大小，会默认从左向右排列，如果一行中不足以容纳所有的内联元素，则换到下一行，继续自左向右。</li>\n<li>在文档流中，内联元素的宽度和高度默认都被内容撑开</li>\n</ol>\n<h3> 浮动解释</h3>\n<p>块元素在文档流中默认垂直排列，所以这个三个div自上至下依次排开，如果希望块元素在页面中水平排列，可以使块元素脱离文档流</p>\n<p><strong>使用float来使元素浮动，从而脱离文档流</strong></p>\n<p>可选值：\nnone，默认值，元素默认在文档流中排列\nleft，元素会立即脱离文档流，向页面的左侧浮动\nright，元素会立即脱离文档流，向页面的右侧浮动</p>\n<p>注意：</p>\n<ol>\n<li>当为一个元素设置浮动以后（float属性是一个非none的值），元素会立即脱离文档流，元素脱离文档流以后，它下边的元素会立即向上移动</li>\n<li>元素浮动以后，会尽量向页面的左上或这是右上漂浮，<strong>直到遇到父元素的边框或者其他的浮动元素</strong></li>\n<li><strong>如果浮动元素上边是一个没有浮动的块元素，则浮动元素不会超过块元素</strong></li>\n<li><strong>浮动的元素不会超过他上边的兄弟元素</strong>，最多最多一边齐</li>\n<li><strong>浮动的元素不会盖住文字</strong>，文字会自动环绕在浮动元素的周围，所以我们可以通过浮动来设置文字环绕图片的效果</li>\n<li>在文档流中，子元素的宽度默认占父元素的全部</li>\n<li>当元素设置浮动以后，会完全脱离文档流，<strong>块元素脱离文档流以后，高度和宽度都被内容撑开</strong></li>\n<li>开启span的浮动，<strong>内联元素脱离文档流以后会变成块元素</strong>（内联元素本身设置宽高没有意义）</li>\n</ol>\n<h3> 高度塌陷问题来由</h3>\n<p>在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。</p>\n<p>但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。</p>\n<p>由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。</p>\n<h3> 解决高度塌陷</h3>\n<h4> 方法一</h4>\n<p>​\t我们可以将<strong>父元素的高度写死</strong>，以避免塌陷的问题出现，但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是<strong>不推荐使用</strong>的。</p>\n<h4> 方法二</h4>\n<p>根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context，简称<strong>BFC</strong>，该属性可以设置打开或者关闭，默认是关闭的。</p>\n<p>当开启元素的BFC以后，元素将会具有如下的特性：</p>\n<ol>\n<li>\n<p>父元素的垂直外边距不会和子元素重叠</p>\n</li>\n<li>\n<p>开启BFC的元素不会被浮动元素所覆盖</p>\n</li>\n<li>\n<p>开启BFC的元素可以包含浮动的子元素</p>\n</li>\n</ol>\n<p>如何开启元素的BFC</p>\n<ol>\n<li>\n<p>设置元素浮动，使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题</p>\n</li>\n<li>\n<p>设置元素绝对定位</p>\n</li>\n<li>\n<p>设置元素为inline-block，可以解决问题，但是会导致宽度丢失，不推荐使用这种方式</p>\n</li>\n<li>\n<p><strong>将元素的overflow设置为一个非visible的值</strong>，此为推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。</p>\n</li>\n</ol>\n<p>但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，该属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题</p>\n<p>开启方式很多，我们直接使用一种副作用最小的：</p>\n<p>直接将元素的zoom设置为1即可</p>\n<p>zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍\nzoom:1 表示不放大元素，但是通过该样式可以开启hasLayout\nzoom这个样式，只在IE中支持，其他浏览器都不支持</p>\n<h4> 方法三</h4>\n<h5> 清楚浮动介绍</h5>\n<p>我们有时希望清除掉其他元素浮动对当前元素产生的影响，这时可以使用clear来完成功能</p>\n<p>clear可以用来清除其他浮动元素对当前元素的影响</p>\n<p>可选值：</p>\n<p>none，默认值，不清除浮动</p>\n<p>left，清除左侧浮动元素对当前元素的影响</p>\n<p>right，清除右侧浮动元素对当前元素的影响</p>\n<p>both，清除两侧浮动元素对当前元素的影响</p>\n<h5> 解法</h5>\n<p>可以直接在高度塌陷的父元素的最后，添加一个空白的div</p>\n<p>由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后在对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，</p>\n<p>基本没有副作用，使用这种方式虽然可以解决问题，但是会在页面中添加多余的结构。</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 定位问题再描述</h2>\n<h3> Position</h3>\n<p><strong>定位指的就是将指定的元素摆放到页面的任意位置</strong>，通过定位可以任意的摆放元素</p>\n<p>通过position属性来设置元素的定位</p>\n<p>可选值：</p>\n<ol>\n<li><code>static</code>：默认值，元素没有开启定位</li>\n<li><code>relative</code>：开启元素的相对定位</li>\n<li><code>absolute</code>：开启元素的绝对定位</li>\n<li><code>fixed</code>：开启元素的固定定位（也是绝对定位的一种）</li>\n</ol>\n<p>当开启了元素的定位（position属性值是一个非static的值）时，可以通过left right top bottom四个属性来设置元素的偏移量</p>\n<p><code>left</code>：元素相对于其定位位置的左侧偏移量</p>\n<p><code>right</code>：元素相对于其定位位置的右侧偏移量</p>\n<p><code>top</code>：元素相对于其定位位置的上边的偏移量</p>\n<p><code>bottom</code>：元素相对于其定位位置下边的偏移量</p>\n<p>通常偏移量只需要使用两个就可以对一个元素进行定位，一般选择水平方向的一个偏移量和垂直方向的偏移量来为一个元素进行定位</p>\n<h3> 相对定位</h3>\n<p>当元素的position属性设置为relative时，则开启了元素的相对定位</p>\n<ol>\n<li>\n<p>当开启了元素的相对定位以后，而不设置偏移量时，元素不会发生任何变化</p>\n</li>\n<li>\n<p><strong>相对定位是相对于元素在文档流中原来自身的位置进行定位</strong></p>\n</li>\n<li>\n<p><strong>相对定位的元素不会脱离文档流</strong></p>\n</li>\n<li>\n<p><strong>相对定位会使元素提升一个层级</strong></p>\n</li>\n<li>\n<p><strong>相对定位不会改变元素的性质，块还是块，内联还是内联</strong></p>\n</li>\n</ol>\n<h3> 绝对定位</h3>\n<p>当position属性值设置为absolute时，则开启了元素的绝对定位</p>\n<p>绝对定位：</p>\n<ol>\n<li>\n<p><strong>开启绝对定位，会使元素脱离文档流</strong></p>\n</li>\n<li>\n<p>开启绝对定位以后，如果不设置偏移量，则元素的位置不会发生变化</p>\n</li>\n<li>\n<p>绝对定位是<strong>相对于离他最近的开启了定位的祖先元素进行定位</strong>的（一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位），<strong>如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位</strong></p>\n</li>\n<li>\n<p><strong>绝对定位会使元素提升一个层级</strong></p>\n</li>\n<li>\n<p>绝对定位会改变元素的性质，<strong>内联元素变成块元素，块元素的宽度和高度默认都被内容撑开</strong></p>\n</li>\n</ol>\n<h3> 固定定位</h3>\n<p>当元素的position属性设置fixed时，则开启了元素的固定定位</p>\n<p>固定定位也是一种绝对定位，它的大部分特点都和绝对定位一样</p>\n<p>不同的是：</p>\n<ol>\n<li>\n<p>固定定位永远都会相对于浏览器窗口进行定位</p>\n</li>\n<li>\n<p>固定定位会固定在浏览器窗口某个位置，不会随滚动条滚动</p>\n</li>\n<li>\n<p>IE6不支持固定定位</p>\n</li>\n</ol>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "HTML",
      "url": "https://harryxiong24.github.io/zh/front-end/html-css/html.html",
      "id": "https://harryxiong24.github.io/zh/front-end/html-css/html.html",
      "summary": "[[toc]] 1. meta的用法和结构 2. HTML 5 标记 注意： 除了a标签以外的所有内联都不能嵌套块级标签; 块级标签可以嵌套任意标签,但是p不能嵌套块级标签,因为嵌套关系如果P标签里面是块级就会把P标签分割成 ; 两个独立的P标签,那个块级元素就在中间 2.1 文本标签 < pre >< pre />标记保留了文本的所有换行与空 < h...",
      "content_html": "<h1> HTML</h1>\n\n<h2> 1. meta的用法和结构</h2>\n<div class=\"language-html\" data-ext=\"html\"></div><h2> 2. HTML 5 标记</h2>\n<p><strong>注意：</strong></p>\n<ul>\n<li>\n<p><strong>除了a标签以外的所有内联都不能嵌套块级标签</strong></p>\n</li>\n<li>\n<p><strong>块级标签可以嵌套任意标签,但是p不能嵌套块级标签</strong>,因为嵌套关系如果P标签里面是块级就会把P标签分割成\n两个独立的P标签,那个块级元素就在中间</p>\n</li>\n</ul>\n<h3> 2.1 文本标签</h3>\n<p>&lt; pre &gt;&lt; pre /&gt;标记保留了文本的所有换行与空</p>\n<p>&lt; hr &gt;&lt; /hr &gt;用法与&lt; br &gt;相同，只是在中间加了一条水平线</p>\n<p>&lt; cite&gt;&lt; /cite&gt;标记用来定义作品的标题，从视觉效果上表现为斜体形式</p>\n<p>&lt; ins&gt;&lt; /ins&gt;表示插入的文本</p>\n<p>&lt; dle&gt;&lt; /dle&gt;表示删除的文本</p>\n<p>&lt; sub&gt;&lt; /sub&gt;定义下标文本   &lt; sup&gt;&lt; /sup&gt;定义上标文本</p>\n<p>&lt; ruby &gt;&lt; /ruby &gt;标记需要定义被旁注的文本</p>\n<p>&lt; rt&gt; 定义文本的注音或解释 （用做直接出现在文字上方）</p>\n<p>&lt; rp&gt;&lt; /rp&gt;出现在文字右方（用做不被浏览器支持的时候）</p>\n<p><strong>文本可编辑属性contenteditable</strong></p>\n<p>该属性可以让在页面不能够被编辑的内容变成像表单一样的可编辑状态</p>\n<p>需要在对应的标签上加上contenteditable=true的属性</p>\n<h3> 2.2 列表</h3>\n<p>&lt; ul &gt;&lt; /ul &gt;表示无序列表</p>\n<p>&lt; ol &gt;&lt; /ol &gt;表示有序列表</p>\n<p>&lt; ol reversed=\"reversed\"&gt;能够使序号倒序</p>\n<p>ol标签有一个type属性,默认是让序号为阿拉伯数字,如果要是其他的样子需要用其他的字母作为值type=\"a\"就是让序号为abcd这种,也可以写罗马数字这种</p>\n<p>&lt; dl &gt;&lt; /dl &gt;表示描述列表</p>\n<p>&lt; dt&gt;&lt; /dt&gt;标记定义列表项（相当于标题）</p>\n<p>&lt; dd&gt;&lt; /dd&gt;标记用于描述列表中的项目</p>\n<div class=\"language-html\" data-ext=\"html\"></div><h2> 3. 媒体</h2>\n<h3> 3.1 图片标签</h3>\n<div class=\"language-html\" data-ext=\"html\"></div><p><strong>注意：如果只填了高或者宽，则另一个会按照比例变化</strong></p>\n<h3> 3.2 视频标签</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.3 音频标签</h3>\n<div class=\"language-html\" data-ext=\"html\"></div><h3> 3.4 兼容写法</h3>\n<h4> 3.4.1 source兼容</h4>\n<p><strong>&lt; source&gt;&lt; source&gt;可以连接不同的媒体文件</strong></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.4.2 插入flash文件</h4>\n<p>用embed标签实现对flash文件的插入</p>\n<div class=\"language-html\" data-ext=\"html\"></div><h4> 3.4.3 figure标签</h4>\n<div class=\"language-html\" data-ext=\"html\"></div><h4> 3.4.4 详情和概要标签</h4>\n<div class=\"language-html\" data-ext=\"html\"></div><h4> 3.4.5 marquee标签</h4>\n<p><strong>注意marquee标签不是W3C官方支持的标签，在官方无线查询，但是各大浏览器都支持且效果很好</strong></p>\n<p><strong>作用：跑马灯，相当于弹幕</strong></p>\n<p>&lt; marquee&gt;&lt; /marquee&gt;</p>\n<p><strong>属性：</strong></p>\n<p>direction=\"\"控制方向 默认从右往左 right从左往右 up:从下往上 down</p>\n<p>scrollamounts=“”设置滚动速度 值越大滚动越快 1 2 3</p>\n<p>loop=\"\"设置滚动次数1代表只滚动一次 默认是-1也就是无限</p>\n<p>behavior=\"\"设置滚动类型slide设置滚到边界就不滚动了alternate让弹幕到边界就不断弹回</p>\n<h2> 4.超链接</h2>\n<h3> 4.1 a标签</h3>\n<div class=\"language-html\" data-ext=\"html\"></div><h3> 4.2 map标签</h3>\n<div class=\"language-html\" data-ext=\"html\"></div><h3> 4.3 base标签</h3>\n<div class=\"language-html\" data-ext=\"html\"></div><h3> 4.4 iframe标签</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-html\" data-ext=\"html\"></div><h2> 5.表格</h2>\n<p><strong>表格是网页制作的元老级别标签,这个标签以前用做制作网页主体,所以有许多独属于表格的属性和用法</strong></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>table样式</strong></p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>表格的特性</strong></p>\n<ul>\n<li>表格有一个属于自己的表现形式就是display:table</li>\n<li>表格的子标签td,th等的表现形式为display:table-cell意味表格细胞</li>\n<li>独占一行</li>\n<li>不给宽高的时候,高度和宽度由内容撑开,不向块级标签一样宽度默认是百分之百</li>\n<li>支持margin属性并且支持margin:0 auto这样的形式,但是对padding属性的支持效果特别奇怪,只有当不写其余和高度宽度等相关属性的时候才生\n效,所以可以说是不支持padding属性的</li>\n</ul>\n<h2> 6.表单</h2>\n<h3> 6.1 form标签</h3>\n<div class=\"language-html\" data-ext=\"html\"></div><h3> 6.2 input标签</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 6.3 textarea标签</h3>\n<div class=\"language-html\" data-ext=\"html\"></div><h3> 6.4 select标签</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>拓展标签datalist(不推荐使用)</strong></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 6.5 label标签</h3>\n<div class=\"language-html\" data-ext=\"html\"></div><h3> 6.6 fieldset标签</h3>\n<div class=\"language-html\" data-ext=\"html\"></div>",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "AJAX",
      "url": "https://harryxiong24.github.io/zh/front-end/jquery/ajax.html",
      "id": "https://harryxiong24.github.io/zh/front-end/jquery/ajax.html",
      "summary": "章节过时 目前，一套代码已经可以在多个浏览器上运行良好了，所以 jQuery 的意义并不大。在 Node 中，我们使用 axios 来进行请求。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">章节过时</p>\n<p>目前，一套代码已经可以在多个浏览器上运行良好了，所以 jQuery 的意义并不大。在 Node 中，我们使用 <a href=\"/zh/nodeJS/package/axois.html\" target=\"blank\">axios</a> 来进行请求。</p>\n</div>\n<!-- more -->\n<p>用 JavaScript 写 AJAX 前面已经介绍过了，主要问题就是不同浏览器需要写不同代码，并且状态和错误处理写起来很麻烦。</p>\n<p>用 jQuery 的相关对象来处理 AJAX，不但不需要考虑浏览器问题，代码也能大大简化。</p>\n<h2> ajax</h2>\n<p>jQuery 在全局对象 jQuery (也就是 <code>$</code>) 绑定了 <code>ajax()</code> 函数，可以处理 AJAX 请求。<code>ajax(url, settings)</code> 函数需要接收一个 URL 和一个可选的 settings 对象，常用的选项如下:</p>\n<ul>\n<li>\n<p>async: 是否异步执行 AJAX 请求，默认为 <code>true</code>；</p>\n</li>\n<li>\n<p>method: 发送的 Method，缺省为 <code>'GET'</code>，可指定为 <code>'POST'</code> 、<code>'PUT'</code> 等；</p>\n</li>\n<li>\n<p>contentType: 发送 POST 请求的格式，默认值为 <code>'application/x-www-form-urlencoded; charset=UTF-8'</code>，也可以指定为 <code>text/plain</code>、<code>application/json</code>；</p>\n</li>\n<li>\n<p>data: 发送的数据，可以是字符串、数组或 object。如果是 <code>GET</code> 请求，data 将被转换成 <code>query</code> 附加到 URL 上，如果是 <code>POST</code> 请求，根据 <code>contentType</code> 把 <code>data</code> 序列化成合适的格式；</p>\n</li>\n<li>\n<p>headers: 发送的额外的 HTTP 头，必须是一个 object；</p>\n</li>\n<li>\n<p>dataType: 接收的数据格式，可以指定为 <code>'html'</code>、<code>'xml'</code>、<code>'json'</code>、<code>'text'</code> 等，缺省情况下根据响应的 <code>Content-Type</code> 猜测。</p>\n</li>\n</ul>\n<p>下面的例子发送一个 <code>GET</code> 请求，并返回一个 JSON 格式的数据:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>不过，如何用回调函数处理返回的数据和出错时的响应呢？</p>\n<p>还记得 Promise 对象吗？jQuery 的 <code>jqXHR</code> 对象类似一个 Promise 对象，我们可以用链式写法来处理各种回调:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> get</h2>\n<p>对常用的 AJAX 操作，jQuery 提供了一些辅助方法。由于 GET 请求最常见，所以 jQuery 提供了 <code>get()</code> 方法，可以这么写:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>第二个参数如果是 object，jQuery 自动把它变成 <code>query string</code> 然后加到 URL 后面，实际的 URL 是:</p>\n<p><code>/path/to/resource?name=Bob%20Lee&amp;check=1</code></p>\n<p>这样我们就不用关心如何用 URL 编码并构造一个 <code>query string</code> 了。</p>\n<h2> post</h2>\n<p><code>post()</code> 和 <code>get()</code> 类似，但是传入的第二个参数默认被序列化为 <code>application/x-www-form-urlencoded</code>:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>实际构造的数据 <code>name=Bob%20Lee&amp;check=1</code> 作为 POST 的 body 被发送。</p>\n<h2> getJSON</h2>\n<p>由于 JSON 用得越来越普遍，所以 jQuery 也提供了 <code>getJSON()</code> 方法来快速通过 GET 获取一个 JSON 对象:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 安全限制</h2>\n<p>jQuery 的 AJAX 完全封装的是 JavaScript 的 AJAX 操作，所以它的安全限制和前面讲的用 JavaScript 写 AJAX 完全一样。</p>\n<p>如果需要使用 JSONP，可以在 <code>ajax()</code> 中设置 <code>jsonp: 'callback'</code>，让 jQuery 实现 JSONP 跨域加载数据。</p>\n<p>关于跨域的设置请参考浏览器 AJAX 一节中 CORS 的设置。</p>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "动画",
      "url": "https://harryxiong24.github.io/zh/front-end/jquery/animation.html",
      "id": "https://harryxiong24.github.io/zh/front-end/jquery/animation.html",
      "summary": "章节过时 大部分动画都能够通过 CSS3 的 transition 实现，且 CSS3 开销更小。在复杂动画下，jQuery 更容易触发性能瓶颈。 2020 年浏览器对 CSS3 已经支持的特别良好，所以目前大多数的动画都直接使用 CSS3 的动画库。本章以学习思路为主即可。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">章节过时</p>\n<p>大部分动画都能够通过 CSS3 的 transition 实现，且 CSS3 开销更小。在复杂动画下，jQuery 更容易触发性能瓶颈。</p>\n<p>2020 年浏览器对 CSS3 已经支持的特别良好，所以目前大多数的动画都直接使用 CSS3 的动画库。本章以学习思路为主即可。</p>\n</div>\n<!-- more -->\n<p>用 JavaScript 实现动画，原理非常简单: 我们只需要以固定的时间间隔(例如，0.1 秒)，每次把 DOM 元素的 CSS 样式修改一点(例如，高宽各增加 10%)，看起来就像动画了。</p>\n<p>但是要用 JavaScript 手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。</p>\n<p>使用 jQuery 实现动画，代码已经简单得不能再简化了: 只需要一行代码！</p>\n<p>让我们先来看看 jQuery 内置的几种动画样式:</p>\n<h2> show / hide</h2>\n<p>直接以无参数形式调用 <code>show()</code> 和 <code>hide()</code>，会显示和隐藏 DOM 元素。但是，只要传递一个时间参数进去，就变成了动画:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>时间以毫秒为单位，但也可以是 <code>'slow'</code>，<code>'fast'</code> 这些字符串:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>toggle()</code> 方法则根据当前状态决定是 <code>show()</code> 还是 <code>hide()</code>。</p>\n<h2> slideUp / slideDown</h2>\n<p>您可能已经看出来了，<code>show()</code> 和 <code>hide()</code> 是从左上角逐渐展开或收缩的，而 <code>slideUp()</code> 和 <code>slideDown()</code> 则是在垂直方向逐渐展开或收缩的。</p>\n<p><code>slideUp()</code> 把一个可见的 DOM 元素收起来，效果跟拉上窗帘似的，<code>slideDown()</code> 相反，而 <code>slideToggle()</code> 则根据元素是否可见来决定下一步动作:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> fadeIn / fadeOut</h2>\n<p><code>fadeIn()</code> 和 <code>fadeOut()</code> 的动画效果是淡入淡出，也就是通过不断设置 DOM 元素的 <code>opacity</code> 属性来实现，而 <code>fadeToggle()</code> 则根据元素是否可见来决定下一步动作:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 自定义动画</h2>\n<p>如果上述动画效果还不能满足您的要求，那就祭出最后大招: <code>animate()</code>，它可以实现任意动画效果，我们需要传入的参数就是 DOM 元素最终的 CSS 状态和时间，jQuery 在时间段内不断调整 CSS 直到达到我们设定的值:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>animate()</code> 还可以再传入一个函数，当动画结束时，该函数将被调用:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实际上这个回调函数参数对于基本动画也是适用的。</p>\n<p>有了 <code>animate()</code>，您就可以实现各种自定义动画效果了:</p>\n<h2> 串行动画</h2>\n<p>jQuery 的动画效果还可以串行执行，通过 <code>delay()</code> 方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因为动画需要执行一段时间，所以 jQuery 必须不断返回新的 Promise 对象才能后续执行操作。简单地把动画封装在函数中是不够的。</p>\n<h2> 为什么有的动画没有效果</h2>\n<p>您可能会遇到，有的动画如 <code>slideUp()</code> 根本没有效果。这是因为 jQuery 动画的原理是逐渐改变 CSS 的值，如 <code>height</code> 从 <code>100px</code> 逐渐变为 <code>0</code>。但是很多不是 block 性质的 DOM 元素，对它们设置 <code>height</code> 根本就不起作用，所以动画也就没有效果。</p>\n<p>此外，jQuery 也没有实现对 <code>background-color</code> 的动画效果，用 <code>animate()</code> 设置 <code>background-color</code> 也没有效果。这种情况下可以使用 CSS3 的 <code>transition</code> 实现动画效果。</p>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "事件",
      "url": "https://harryxiong24.github.io/zh/front-end/jquery/event.html",
      "id": "https://harryxiong24.github.io/zh/front-end/jquery/event.html",
      "summary": "章节过时 由于目前各浏览器 API 已经基本统一，无需使用 jQuery 绑定事件了。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">章节过时</p>\n<p>由于目前各浏览器 API 已经基本统一，无需使用 jQuery 绑定事件了。</p>\n</div>\n<!-- more -->\n<p>因为 JavaScript 在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的 JavaScript 代码被执行完后，就只能依赖触发事件来执行 JavaScript 代码。</p>\n<p>浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的 DOM 节点上触发相应的事件。如果该节点已经绑定了对应的 JavaScript 处理函数，该函数就会自动调用。</p>\n<p>由于不同的浏览器绑定事件的代码都不太一样，所以用 jQuery 来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。</p>\n<p>举个例子，假设要在用户点击了超链接时弹出提示框，我们用 jQuery 这样绑定一个 <code>click</code> 事件:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>on</code> 方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。</p>\n<p>另一种更简化的写法是直接调用 <code>click()</code> 方法:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>两者完全等价。我们通常用后面的写法。</p>\n<p>jQuery 能够绑定的事件主要包括:</p>\n<h2> 鼠标事件</h2>\n<ul>\n<li><code>click</code>: 鼠标单击时触发；</li>\n<li><code>dblclick</code>: 鼠标双击时触发；</li>\n<li><code>mouseenter</code>: 鼠标进入时触发；</li>\n<li><code>mouseleave</code>: 鼠标移出时触发；</li>\n<li><code>mousemove</code>: 鼠标在 DOM 内部移动时触发；</li>\n<li><code>hover</code>: 鼠标进入和退出时触发两个函数，相当于 <code>mouseenter</code> 加上 <code>mouseleave</code>。</li>\n</ul>\n<h2> 键盘事件</h2>\n<p>键盘事件仅作用在当前焦点的 DOM 上，通常是 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code>。</p>\n<ul>\n<li><code>keydown</code>: 键盘按下时触发；</li>\n<li><code>keyup</code>: 键盘松开时触发；</li>\n<li><code>keypress</code>: 按一次键后触发。</li>\n</ul>\n<h2> 其他事件</h2>\n<ul>\n<li><code>focus</code>: 当 DOM 获得焦点时触发；</li>\n<li><code>blur</code>: 当 DOM 失去焦点时触发；</li>\n<li><code>change</code>: 当 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 或 <code>&lt;textarea&gt;</code> 的内容改变时触发；</li>\n<li><code>submit</code>: 当<code>&lt;form&gt;</code>提交时触发；</li>\n<li><code>ready</code>: 当页面被载入并且 DOM 树完成初始化后触发。</li>\n</ul>\n<p>其中，<code>ready</code> 仅作用于 document 对象。由于 ready 事件在 DOM 完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。假设我们想给一个 <code>&lt;form&gt;</code> 表单绑定 submit 事件，下面的代码没有预期的效果:</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因为 JavaScript 在此执行的时候，<code>&lt;form&gt;</code> 尚未载入浏览器，所以 <code>$('#testForm)</code> 返回 <code>[]</code>，并没有绑定事件到任何 DOM 上。</p>\n<p>所以我们自己的初始化代码必须放到 document 对象的 <code>ready</code> 事件中，保证 DOM 已完成初始化:</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样写就没有问题了。因为相关代码会在 DOM 树初始化后再执行。</p>\n<p>由于 <code>ready</code> 事件使用非常普遍，所以可以这样简化:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>甚至还可以再简化为:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>上面的这种写法最为常见。如果您遇到 <code>$(function () {...})</code> 的形式，牢记这是 document 对象的 <code>ready</code> 事件处理函数。</p>\n<p>完全可以反复绑定事件处理函数，它们会依次执行:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 事件参数</h2>\n<p>有些事件，如 <code>mousemove</code> 和 <code>keypress</code>，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入 Event 对象作为参数，可以从 Event 对象上获取到更多的信息:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 取消绑定</h2>\n<p>一个已被绑定的事件可以解除绑定，通过 <code>off('click', function)</code> 实现:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这是因为两个匿名函数虽然长得一模一样，但是它们是两个不同的函数对象，<code>off('click', function () {...})</code> 无法移除已绑定的第一个匿名函数。</p>\n<p>为了实现移除效果，可以使用 <code>off('click')</code> 一次性移除已绑定的 click 事件的所有处理函数。</p>\n<p>同理，无参数调用 <code>off()</code> 一次性移除已绑定的所有类型的事件处理函数。</p>\n<h2> 事件触发条件</h2>\n<p>一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>当用户在文本框中输入时，就会触发 <code>change</code> 事件。但是，如果用 JavaScript 代码去改动文本框的值，将不会触发 <code>change</code> 事件:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>有些时候，我们希望用代码触发 <code>change</code> 事件，可以直接调用无参数的 <code>change()</code> 方法来触发该事件:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>input.change()</code> 相当于 <code>input.trigger('change')</code>，它是 <code>trigger()</code> 方法的简写。</p>\n<p>为什么我们希望手动触发一个事件呢？如果不这么做，很多时候，我们就得写两份一模一样的代码。</p>\n<h2> 浏览器安全限制</h2>\n<p>在浏览器中，有些 JavaScript 代码只有在用户触发下才能执行，例如，<code>window.open()</code>函数:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这些 “敏感代码” 只能由用户操作来触发:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当用户点击 button1 时，<code>click</code> 事件被触发，由于 <code>popupTestWindow()</code> 在 <code>click</code> 事件处理函数内执行，这是浏览器允许的，而 button2 的 <code>click</code> 事件并未立刻执行 <code>popupTestWindow()</code>，延迟执行的 <code>popupTestWindow()</code> 将被浏览器拦截。</p>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "扩展",
      "url": "https://harryxiong24.github.io/zh/front-end/jquery/extend.html",
      "id": "https://harryxiong24.github.io/zh/front-end/jquery/extend.html",
      "summary": "当我们使用 jQuery 对象的方法时，由于 jQuery 对象可以操作一组 DOM，而且支持链式操作，所以用起来非常方便。 但是 jQuery 内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些 DOM 元素，用 jQuery 可以这么实现: 总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个 highlight(...",
      "content_html": "<p>当我们使用 jQuery 对象的方法时，由于 jQuery 对象可以操作一组 DOM，而且支持链式操作，所以用起来非常方便。</p>\n<p>但是 jQuery 内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些 DOM 元素，用 jQuery 可以这么实现:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个 <code>highlight()</code> 方法？</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>答案是肯定的。我们可以扩展 jQuery 来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写 jQuery 插件。</p>\n<h2> 编写 jQuery 插件</h2>\n<p>给 jQuery 对象绑定一个新方法是通过扩展 <code>$.fn</code> 对象实现的。让我们来编写第一个扩展—— <code>highlight1()</code>:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意到函数内部的 <code>this</code> 在调用时被绑定为 jQuery 对象，所以函数内部代码可以正常调用所有 jQuery 对象的方法。</p>\n<p>对于如下的 HTML 结构:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>来测试一下 <code>highlight1()</code> 的效果:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>细心的您可能发现了，为什么最后要 <code>return this</code> ;？因为 jQuery 对象支持链式操作，我们自己写的扩展方法也要能继续链式下去:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>不然，用户调用的时候，就不得不把上面的代码拆成两行。</p>\n<p>但是这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办？</p>\n<p>我们可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的 <code>highlight2()</code>:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>对于如下 HTML 结构:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>来实测一下带参数的 <code>highlight2()</code>:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>对于默认值的处理，我们用了一个简单的 <code>&amp;&amp;</code> 和 <code>||</code> 短路操作符，总能得到一个有效的值。</p>\n<p>另一种方法是使用 jQuery 提供的辅助方法 <code>$.extend(target, obj1, obj2, ...)</code>，它把多个 object 对象的属性合并到第一个 target 对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>紧接着用户对 <code>highlight2()</code> 提出了意见: 每次调用都需要传入自定义的设置，能不能让我自己设定一个缺省值，以后的调用统一使用无参数的 <code>highlight2()</code>？</p>\n<p>也就是说，我们设定的默认值应该能允许用户修改。</p>\n<p>那默认值放哪比较合适？放全局变量肯定不合适，最佳地点是 <code>$.fn.highlight2</code> 这个函数对象本身。</p>\n<p>于是最终版的 <code>highlight()</code> 终于诞生了:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这次用户终于满意了。用户使用时，只需一次性设定默认值:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>然后就可以非常简单地调用 <code>highlight()</code> 了。</p>\n<p>对如下的 HTML 结构:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>实测一下修改默认值的效果:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最终，我们得出编写一个 jQuery 插件的原则:</p>\n<ul>\n<li>给 <code>$.fn</code> 绑定函数，实现插件的代码逻辑；</li>\n<li>插件函数最后要 <code>return this</code> ;以支持链式调用；</li>\n<li>插件函数要有默认值，绑定在 <code>$.fn.&lt;pluginName&gt;.defaults</code>上；</li>\n<li>用户在调用时可传入设定值以便覆盖默认值。</li>\n</ul>\n<h2> 针对特定元素的扩展</h2>\n<p>我们知道 jQuery 对象的有些方法只能作用在特定 DOM 元素上，比如 <code>submit()</code> 方法只能针对 form。如果我们编写的扩展只能针对某些类型的 DOM 元素，应该怎么写？</p>\n<p>还记得 jQuery 的选择器支持 <code>filter()</code> 方法来过滤吗？我们可以借助这个方法来实现针对特定元素的扩展。</p>\n<p>举个例子，现在我们要给所有指向外链的超链接加上跳转提示，怎么做？</p>\n<p>先写出用户调用的代码:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>然后按照上面的方法编写一个 <code>external</code> 扩展:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对如下的 HTML 结构:</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实测外链效果:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 小结</h2>\n<p>扩展 jQuery 对象的功能十分简单，但是我们要遵循 jQuery 的原则，编写的扩展方法能支持链式调用、具备默认值和过滤特定元素，使得扩展方法看上去和 jQuery 本身的方法没有什么区别。</p>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "介绍",
      "url": "https://harryxiong24.github.io/zh/front-end/jquery/intro.html",
      "id": "https://harryxiong24.github.io/zh/front-end/jquery/intro.html",
      "summary": "jQuery 是 JavaScript 世界中使用最广泛的一个库。鼎盛时期全世界大约有 80~90%的网站直接或间接地使用了 jQuery。 jQuery 能帮我们干这些事情: 消除浏览器差异: 您不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写 AJAX 等代码； 简洁的操作 DOM 的方法: 写 $('#test') 肯定比 document.getElementById('test') 来得简洁； 轻松实现动画、修改 CSS 等各种操作。 jQuery 的理念 “Write Less, Do More“，让您写更少的代码，完成更多的工作！",
      "content_html": "<p>jQuery 是 JavaScript 世界中使用最广泛的一个库。鼎盛时期全世界大约有 80~90%的网站直接或间接地使用了 jQuery。</p>\n<p>jQuery 能帮我们干这些事情:</p>\n<ul>\n<li>消除浏览器差异: 您不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写 AJAX 等代码；</li>\n<li>简洁的操作 DOM 的方法: 写 <code>$('#test')</code> 肯定比 <code>document.getElementById('test')</code> 来得简洁；</li>\n<li>轻松实现动画、修改 CSS 等各种操作。</li>\n<li>jQuery 的理念 “Write Less, Do More“，让您写更少的代码，完成更多的工作！</li>\n</ul>\n<!-- more -->\n<h2> jQuery 版本</h2>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>jQuery 的 <code>1.x</code> 版本 兼容 ie678，<code>2.x</code> 为了精简代码体积移除了 ie678 的兼容。<code>3.x</code> 只兼容最新的一批浏览器，是官方还在更新维护的把呢不能</p>\n<p>由于已经 2020 年了，直接选用 jQuery<code>3.x</code>版本即可。</p>\n</div>\n<p>从 jQuery 官网可以下载最新版本。jQuery 只是一个 jquery-xxx.js 文件，但您会看到有 compressed(已压缩)和 uncompressed(未压缩)两种版本，使用时完全一样，但如果您想深入研究 jQuery 源码，那就用 uncompressed 版本。</p>\n<h2> 使用 jQuery</h2>\n<p>使用 jQuery 只需要在页面的 <code>&lt;head&gt;</code> 引入 jQuery 文件即可:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><h2> $ 符号</h2>\n<p><code>$</code> 是著名的 jQuery 符号。实际上，jQuery 把所有功能全部封装在一个全局变量 jQuery 中，而 <code>$</code> 也是一个合法的变量名，它是变量 jQuery 的别名:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>$</code> 本质上就是一个函数，但是函数也是对象，于是 <code>$</code> 除了可以直接调用外，也可以有很多其他属性。</p>\n<p>注意，您看到的 <code>$</code> 函数名可能不是 <code>jQuery(selector, context)</code>，因为很多 JavaScript 压缩工具可以对函数名和参数改名，所以压缩过的 jQuery 源码 <code>$</code> 函数可能变成<code>a(b, c)</code>。</p>\n<p>绝大多数时候，我们都直接用 <code>$</code> (因为写起来更简单嘛)。但是，如果 <code>$</code> 这个变量不幸地被占用了，而且还不能改，那我们就只能让 jQuery 把 <code>$</code> 变量交出来，然后就只能使用 <code>jQuery</code> 这个变量:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种黑魔法的原理是 jQuery 在占用<code>$</code>之前，先在内部保存了原来的<code>$</code>,调用 <code>jQuery.noConflict()</code> 时会把原来保存的变量还原。</p>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "修改 DOM 结构",
      "url": "https://harryxiong24.github.io/zh/front-end/jquery/modify-dom.html",
      "id": "https://harryxiong24.github.io/zh/front-end/jquery/modify-dom.html",
      "summary": "章节过时 而且目前浏览器 API 已经基本统一，除非兼容旧版本 IE，否则无需针对不同浏览器写不同的代码。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">章节过时</p>\n<p>而且目前浏览器 API 已经基本统一，除非兼容旧版本 IE，否则无需针对不同浏览器写不同的代码。</p>\n</div>\n<!-- more -->\n<p>直接使用浏览器提供的 API 对 DOM 结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。</p>\n<p>有了 jQuery，我们就专注于操作 jQuery 对象本身，底层的 DOM 操作由 jQuery 完成就可以了，这样一来，修改 DOM 也大大简化了。</p>\n<h2> 添加 DOM</h2>\n<p>要添加新的 DOM 节点，除了通过 jQuery 的 <code>html()</code> 这种暴力方法外，还可以用 <code>append()</code> 方法，例如:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>如何向列表新增一个语言？首先要拿到 <code>&lt;ul&gt;</code> 节点:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>然后，调用 <code>append()</code> 传入 HTML 片段:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>除了接受字符串，<code>append()</code> 还可以传入原始的 DOM 对象，jQuery 对象和函数对象:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>传入函数时，要求返回一个字符串、DOM 对象或者 jQuery 对象。因为 jQuery 的 <code>append()</code> 可能作用于一组 DOM 节点，只有传入函数才能针对每个 DOM 生成不同的子节点。</p>\n<p><code>append()</code> 把 DOM 添加到最后，<code>prepend()</code> 则把 DOM 添加到最前。</p>\n<p>另外注意，如果要添加的 DOM 节点已经存在于 HTML 文档中，它会首先从文档移除，然后再添加，也就是说，用 <code>append()</code>，您可以移动一个 DOM 节点。</p>\n<p>如果要把新节点插入到指定位置，例如，JavaScript 和 Python 之间，那么，可以先定位到 JavaScript，然后用 <code>after()</code> 方法:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>也就是说，同级节点可以用 <code>after()</code> 或者 <code>before()</code> 方法。</p>\n<h2> 删除节点</h2>\n<p>要删除 DOM 节点，拿到 jQuery 对象后直接调用 <code>remove()</code> 方法就可以了。如果 jQuery 对象包含若干 DOM 节点，实际上可以一次删除多个 DOM 节点:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "操作 DOM",
      "url": "https://harryxiong24.github.io/zh/front-end/jquery/operate-dom.html",
      "id": "https://harryxiong24.github.io/zh/front-end/jquery/operate-dom.html",
      "summary": "章节过时 目前，新型的框架大多遵循 MVVM 逻辑，及把逻辑层的数据绑定到视图层去显示。这种思路下，无需也不应操作 DOM。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">章节过时</p>\n<p>目前，新型的框架大多遵循 MVVM 逻辑，及把逻辑层的数据绑定到视图层去显示。这种思路下，无需也不应操作 DOM。</p>\n</div>\n<!-- more -->\n<p>jQuery 的选择器很强大，用起来又简单又灵活，但是搞了这么久，我拿到了 jQuery 对象，到底要干什么？</p>\n<p>答案当然是操作对应的 DOM 节点啦！</p>\n<p>回顾一下修改 DOM 的 CSS、文本、设置 HTML 有多么麻烦，而且有的浏览器只有 innerHTML，有的浏览器支持 innerText，有了 jQuery 对象，不需要考虑浏览器差异了，全部统一操作！</p>\n<h2> 修改 Text 和 HTML</h2>\n<p>jQuery 对象的 <code>text()</code> 和 <code>html()</code> 方法分别获取节点的文本和原始 HTML 文本，例如，如下的 HTML 结构:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>分别获取文本和 HTML:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如何设置文本或 HTML ? jQuery 的 API 设计非常巧妙: 无参数调用 <code>text()</code> 是获取文本，传入参数就变成设置文本，HTML 也是类似操作，自己动手试试:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><div class=\"language-markdown\" data-ext=\"md\"></div><p>一个 jQuery 对象可以包含 0 个或任意个 DOM 对象，它的方法实际上会作用在对应的每个 DOM 节点上。在上面的例子中试试:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>所以 jQuery 对象的另一个好处是我们可以执行一个操作，作用在对应的一组 DOM 节点上。即使选择器没有返回任何 DOM 节点，调用 jQuery 对象的方法仍然不会报错:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这意味着 jQuery 帮您免去了许多 if 语句。</p>\n<h2> 修改 CSS</h2>\n<p>jQuery 对象有“批量操作”的特点，这用于修改 CSS 实在是太方便了。考虑下面的 HTML 结构:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>要高亮显示动态语言，调用 jQuery 对象的 <code>css('name', 'value')</code> 方法，我们用一行语句实现:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><div class=\"language-markdown\" data-ext=\"md\"></div><p>注意，jQuery 对象的所有方法都返回一个 jQuery 对象(可能是新的也可能是自身)，这样我们可以进行链式调用，非常方便。</p>\n<p>jQuery 对象的 <code>css()</code> 方法可以这么用:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>为了和 JavaScript 保持一致，CSS 属性可以用 <code>'background-color'</code> 和 <code>'backgroundColor'</code> 两种格式。</p>\n<p><code>css()</code> 方法将作用于 DOM 节点的 style 属性，具有最高优先级。如果要修改 class 属性，可以用 jQuery 提供的下列方法:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 显示和隐藏 DOM</h2>\n<p>要隐藏一个 DOM，我们可以设置 CSS 的 <code>display</code> 属性为 <code>none</code>，利用 <code>css()</code> 方法就可以实现。不过，要显示这个 DOM 就需要恢复原有的 <code>display</code> 属性，这就得先记下来原有的 <code>display</code> 属性到底是 <code>block</code> 还是 <code>inline</code> 还是别的值。</p>\n<p>考虑到显示和隐藏 DOM 元素使用非常普遍，jQuery 直接提供<code>show()</code>和<code>hide()</code>方法，我们不用关心它是如何修改 display 属性的，总之它能正常工作:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，隐藏 DOM 节点并未改变 DOM 树的结构，它只影响 DOM 节点的显示。这和删除 DOM 节点是不同的。</p>\n<h2> 获取 DOM 信息</h2>\n<p>利用 jQuery 对象的若干方法，我们直接可以获取 DOM 的高宽等信息，而无需针对不同浏览器编写特定代码:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>attr()</code> 和 <code>removeAttr()</code> 方法用于操作 DOM 节点的属性:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>prop()</code> 方法和 <code>attr()</code> 类似，但是 HTML5 规定有一种属性在 DOM 节点中可以没有值，只有出现与不出现两种，例如:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>等价于:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p><code>attr()</code> 和 <code>prop()</code> 对于属性 <code>checked</code> 处理有所不同:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>prop()</code> 返回值更合理一些。不过，用 <code>is()</code> 方法判断更好:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>类似的属性还有 <code>selected</code>，处理时最好用 <code>is(':selected')</code>。</p>\n<h2> 操作表单</h2>\n<p>对于表单元素，jQuery 对象统一提供 <code>val()</code> 方法获取和设置对应的 <code>value</code> 属性:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可见，一个 <code>val()</code> 就统一了各种输入框的取值和赋值的问题。</p>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "jQuery",
      "url": "https://harryxiong24.github.io/zh/front-end/jquery/",
      "id": "https://harryxiong24.github.io/zh/front-end/jquery/",
      "summary": "jQuery 是一款能够方便快捷的操作 DOM，并兼容所有主流浏览器的框架，目前最新版本是 3.5.1。 提示 由于目前前端应用的愈加复杂，前端开发者大多数转向 MVVM 框架，目前世界比较流行的三大 MVVM 框架是 Vue React Angular。可以说，在 2020 年，jQuery 已经过时了！ 不过 jQuery 无论说从代码实现还是从写法上，到今天都是值得借鉴的。 所以如果您只想简单了解并掌握前端开发，而不是深入地从事相关行业，您可以直接 跳过本章节。 本章节应以理解写法与思路为主，无需刻意记忆。",
      "content_html": "<p>jQuery 是一款能够方便快捷的操作 DOM，并兼容所有主流浏览器的框架，目前最新版本是 3.5.1。</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>由于目前前端应用的愈加复杂，前端开发者大多数转向 MVVM 框架，目前世界比较流行的三大 MVVM 框架是 Vue React Angular。可以说，在 2020 年，<strong>jQuery 已经过时了</strong>！</p>\n<p>不过 jQuery 无论说从代码实现还是从写法上，到今天都是值得借鉴的。</p>\n<p>所以如果您只想简单了解并掌握前端开发，而不是深入地从事相关行业，您可以直接 <a href=\"/zh/vue/\" target=\"blank\">跳过本章节</a>。</p>\n<p>本章节应以理解写法与思路为主，无需刻意记忆。</p>\n</div>\n<!-- more -->\n<h2> 教程目录</h2>\n<ul>\n<li>\n<p><a href=\"/zh/front-end/jquery/intro.html\" target=\"blank\">jQuery 简介</a></p>\n</li>\n<li>\n<p><a href=\"/zh/front-end/jquery/selector.html\" target=\"blank\">选择器</a></p>\n</li>\n<li>\n<p><a href=\"/zh/front-end/jquery/operateDOM.html\" target=\"blank\">操作 DOM</a></p>\n</li>\n<li>\n<p><a href=\"/zh/front-end/jquery/modifyDOM.html\" target=\"blank\">修改 DOM 结构</a></p>\n</li>\n<li>\n<p><a href=\"/zh/front-end/jquery/event.html\" target=\"blank\">事件</a></p>\n</li>\n<li>\n<p><a href=\"/zh/front-end/jquery/animation.html\" target=\"blank\">动画</a></p>\n</li>\n<li>\n<p><a href=\"/zh/front-end/jquery/AJAX.html\" target=\"blank\">AJAX</a></p>\n</li>\n<li>\n<p><a href=\"/zh/front-end/jquery/extend.html\" target=\"blank\">扩展</a></p>\n</li>\n</ul>\n",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    },
    {
      "title": "选择器",
      "url": "https://harryxiong24.github.io/zh/front-end/jquery/selector.html",
      "id": "https://harryxiong24.github.io/zh/front-end/jquery/selector.html",
      "summary": "选择器是 jQuery 的核心。一个选择器写出来类似 $('#dom-id')。",
      "content_html": "<p>选择器是 jQuery 的核心。一个选择器写出来类似 <code>$('#dom-id')</code>。</p>\n<!-- more -->\n<p>为什么 jQuery 要发明选择器？回顾一下 DOM 操作中我们经常使用的代码:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这些代码实在太繁琐了，并且，在层级关系中，例如，查找 <code>&lt;table class=\"green\"&gt;</code> 里面的所有 <code>&lt;tr&gt;</code>，一层循环实际上是错的，因为 <code>&lt;table&gt;</code> 的标准写法是:</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>很多时候，需要递归查找所有子节点。</p>\n<p>jQuery 的选择器就是帮助我们快速定位到一个或多个 DOM 节点。</p>\n<h2> 简单选择器</h2>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>jQuery 的选择器特别像 CSS 的选择器</p>\n</div>\n<h3> 按 ID 查找</h3>\n<p>如果某个 DOM 节点有 id 属性，利用 jQuery 查找如下:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>注意，<code>#abc</code> 以 <code>#</code> 开头。返回的对象是 jQuery 对象。</p>\n<p>什么是 jQuery 对象？jQuery 对象类似数组，它的每个元素都是一个引用了 DOM 节点的对象。</p>\n<p>以上面的查找为例，如果 id 为 <code>abc</code> 的 <code>&lt;div&gt;</code> 存在，返回的 jQuery 对象如下:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>如果 id 为 abc 的 <code>&lt;div&gt;</code> 不存在，返回的 jQuery 对象如下:</p>\n<p><code>[]</code></p>\n<p>总之 jQuery 的选择器不会返回 <code>undefined</code> 或者 <code>null</code>，这样的好处是您不必在下一行判断<code>if (div === undefined)</code>。</p>\n<p>jQuery 对象和 DOM 对象之间可以互相转化:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>通常情况下您不需要获取 DOM 对象，直接使用 jQuery 对象更加方便。如果您拿到了一个 DOM 对象，那可以简单地调用 <code>$(aDomObject)</code> 把它变成 jQuery 对象，这样就可以方便地使用 jQuery 的 API 了。</p>\n<h3> 按 tag 查找</h3>\n<p>按 tag 查找只需要写上 tag 名称就可以了:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 按 class 查找</h3>\n<p>按 class 查找注意在 class 名称前加一个 <code>.</code>:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>通常很多节点有多个 <strong>class</strong>，我们可以查找同时包含 <code>red</code> 和 <code>green</code> 的节点:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 按属性查找</h3>\n<p>一个 DOM 节点除了 id 和 class 外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>当属性的值包含空格等特殊字符时，需要用双引号括起来。</p>\n<p>按属性查找还可以使用前缀查找或者后缀查找:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这个方法尤其适合通过 class 属性查找，且不受 class 包含多个名称的影响:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 组合查找</h3>\n<p>组合查找就是把上述简单选择器组合起来使用。如果我们查找 <code>$('[name=email]')</code>，很可能把表单外的 <code>&lt;div name=\"email\"&gt;</code> 也找出来，但我们只希望查找 <code>&lt;input&gt;</code>，就可以这么写:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>同样的，根据 tag 和 class 来组合查找也很常见:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 多项选择器</h2>\n<p>多项选择器就是把多个选择器用，组合起来一块选:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>要注意的是，选出来的元素是按照它们在 HTML 中出现的顺序排列的，而且不会有重复元素。例如，<code>&lt;p class=\"red green\"&gt;</code> 不会被上面的 <code>$('p.red,p.green')</code> 选择两次。</p>\n<h2> 层级选择器</h2>\n<p>除了基本的选择器外，jQuery 的层级选择器更加灵活，也更强大。</p>\n<p>因为 DOM 的结构就是层级结构，所以我们经常要根据层级关系进行选择。</p>\n<h3> 层级选择器 (Descendant Selector)</h3>\n<p>如果两个 DOM 元素具有层级关系，就可以用 <code>$('ancestor descendant')</code> 来选择，层级之间用空格隔开。例如:</p>\n<div class=\"language-html\" data-ext=\"html\"></div><p>要选出 JavaScript，可以用层级选择器:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>因为<code>&lt;div&gt;</code>和<code>&lt;ul&gt;</code>都是<code>&lt;li&gt;</code>的祖先节点，所以上面两种方式都可以选出相应的<code>&lt;li&gt;</code>节点。</p>\n<p>要选择所有的<code>&lt;li&gt;</code>节点，用:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>这种层级选择器相比单个的选择器好处在于，它缩小了选择范围，因为首先要定位父节点，才能选择相应的子节点，这样避免了页面其他不相关的元素。</p>\n<p>例如:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>就把选择范围限定在 <code>name</code> 属性为 <code>upload</code> 的表单里。如果页面有很多表单，其他表单的 <code>&lt;input&gt;</code> 不会被选择。</p>\n<p>多层选择也是允许的:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 子选择器(Child Selector)</h2>\n<p>子选择器 <code>$('parent&gt;child')</code> 类似层级选择器，但是限定了层级关系必须是父子关系，就是<code>&lt;child&gt;</code>节点必须是<code>&lt;parent&gt;</code>节点的直属子节点。还是以上面的例子:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 过滤器(Filter)</h2>\n<p>过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 表单相关</h2>\n<p>针对表单元素，jQuery 还有一组特殊的选择器:</p>\n<ul>\n<li>\n<p><code>:input</code>: 可以选择 <code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code> 和 <code>&lt;button&gt;</code>；</p>\n</li>\n<li>\n<p><code>:file</code>: 可以选择 <code>&lt;input type=\"file\"&gt;</code>，和 <code>input[type=file]</code> 一样；</p>\n</li>\n<li>\n<p><code>:checkbox</code>: 可以选择复选框，和 <code>input[type=checkbox]</code> 一样；</p>\n</li>\n<li>\n<p><code>:radio</code>: 可以选择单选框，和 <code>input[type=radio]</code> 一样；</p>\n</li>\n<li>\n<p><code>:focus</code>: 可以选择当前输入焦点的元素，例如把光标放到一个<code>&lt;input&gt;</code>上，用<code>$('input:focus')</code>就可以选出；</p>\n</li>\n<li>\n<p><code>:checked</code>: 选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如<code>$('input[type=radio]:checked')</code>；</p>\n</li>\n<li>\n<p><code>:enabled</code>: 可以选择可以正常输入的<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>等，也就是没有灰掉的输入；</p>\n</li>\n<li>\n<p><code>:disabled</code>: 和<code>:enabled</code>正好相反，选择那些不能输入的。</p>\n</li>\n</ul>\n<p>此外，jQuery 还有很多有用的选择器，例如，选出可见的或隐藏的元素:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h2> 查找和过滤</h2>\n<p>通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个 jQuery 对象后，还可以以这个对象为基准，进行查找和过滤。</p>\n<h3> 查找</h3>\n<p>最常见的查找是在某个节点的所有子节点中查找，使用 <code>find()</code> 方法，它本身又接收一个任意的选择器。例如如下的 HTML 结构:</p>\n<div class=\"language-markdown\" data-ext=\"md\"></div><div class=\"language-html\" data-ext=\"html\"></div><p>用 <code>find()</code> 查找:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>如果要从当前节点开始向上查找，使用 <code>parent()</code> 方法:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>对于位于同一层级的节点，可以通过 <code>next()</code> 和 <code>prev()</code> 方法，例如:</p>\n<p>当我们已经拿到 Swift 节点后:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><h3> 过滤</h3>\n<p>和函数式编程的 <code>map</code>、<code>filter</code> 类似，jQuery 对象也有类似的方法。</p>\n<p><code>filter()</code> 方法可以过滤掉不符合选择器条件的节点:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>或者传入一个函数，要特别注意函数内部的 <code>this</code> 被绑定为 DOM 对象，不是 jQuery 对象:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p><code>map()</code> 方法把一个 jQuery 对象包含的若干 DOM 节点转化为其他对象:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div><p>此外，一个 jQuery 对象如果包含了不止一个 DOM 节点，<code>first()</code>、<code>last()</code> 和 <code>slice()</code> 方法可以返回一个新的 jQuery 对象，把不需要的 DOM 节点去掉:</p>\n<div class=\"language-javascript\" data-ext=\"js\"></div>",
      "date_published": "2023-06-15T10:30:18.000Z",
      "date_modified": "2023-06-15T10:30:18.000Z",
      "authors": [],
      "tags": [
        "Web前端"
      ]
    }
  ]
}