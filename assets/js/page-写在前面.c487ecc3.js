(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{762:function(t,e,s){"use strict";s.r(e);var r=s(1),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"写在前面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#写在前面"}},[t._v("#")]),t._v(" 写在前面")]),t._v(" "),s("p",[t._v("Web 界面由 DOM 树来构成，当其中某一部分发生变化时，其实就是对应的某个 DOM 节点发生了变化。")]),t._v(" "),s("p",[t._v("在 React 中，构建 UI 界面的思路是由当前状态决定界面。")]),t._v(" "),s("p",[t._v("前后两个状态就对应两套界面，然后由 React 来比较两个界面的区别，这就需要对 DOM 树进行 Diff 算法分析。即给定任意两棵树，找到最少的转换步骤。")]),t._v(" "),s("p",[t._v("但是标准的的 Diff 算法复杂度需要 "),s("code",[t._v("O(n^3)")]),t._v("，这显然无法满足性能要求。要达到每次界面都可以整体刷新界面的目的，势必需要对算法进行优化。这看上去非常有难度，然而 Facebook 工程师却做到了，他们结合 Web 界面的特点做出了两个简单的假设，使得 Diff 算法复杂度直接降低到"),s("code",[t._v("O(n)")])]),t._v(" "),s("ol",[s("li",[t._v("两个相同组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构")]),t._v(" "),s("li",[t._v("对于同一层次的一组子节点，它们可以通过唯一的 id 进行区分")])]),t._v(" "),s("p",[t._v("算法上的优化是 React 整个界面 Render 的基础，事实也证明这两个假设是合理而精确的，保证了整体界面构建的性能。")])])}),[],!1,null,null,null);e.default=a.exports},933:function(t,e,s){"use strict";s.r(e);var r=s(1),a=Object(r.a)({},(function(){var t=this.$createElement,e=this._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h1",{attrs:{id:"写在前面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#写在前面"}},[this._v("#")]),this._v(" 写在前面")])])}),[],!1,null,null,null);e.default=a.exports}}]);